{"meta":{"title":"locize - localization as a service","subtitle":null,"description":"Bridging the gap between translation and development.","author":"inweso GmbH","url":"https://locize.com/blog","root":"/blog/"},"pages":[{"title":"Page Not Found","date":"un33fin33","updated":"un33fin33","comments":false,"path":"/404.html","permalink":"https://locize.com/blog/404.html","excerpt":"","text":"Sorry, but the page you were trying to view does not exist --- perhaps you can try searching for it below. var GOOG_FIXURL_LANG = 'en'; var GOOG_FIXURL_SITE = 'https://www.locize.com/blog/'"}],"posts":[{"title":"Interview with WebsitePlanet","slug":"websiteplanet-interview","date":"un22fin22","updated":"un11fin11","comments":true,"path":"websiteplanet-interview/","link":"","permalink":"https://locize.com/blog/websiteplanet-interview/","excerpt":"","text":"We&#39;re thrilled to share our recent interview with WebsitePlanet, where we delve into the fascinating story behind locize, explore the diverse range of services we offer, unveil our mission to simplify global expansion, and understand what sets locize apart from the rest. Join us as we take you on a journey through our history, showcase our comprehensive localization services, and illustrate why locize is your ultimate platform for achieving global reach. Read the full interview and gain insights into the future of localization here: Innovating Software Localization: A Conversation with the CTO of locize.","raw":"---\ntitle: \"Interview with WebsitePlanet\"\ndescription: Explore how Locize is revolutionizing software localization and breaking language barriers in our in-depth interview with WebsitePlanet.\n\ndate: 2023-10-24\ntags:\n  - localization\n  - internationalization\n  - guest post\n\nthumbnail: websiteplanet-interview/title.jpg\n---\n\n![](title.jpg)\n\nWe're thrilled to share our recent interview with WebsitePlanet, where we delve into the fascinating story behind [locize](/), explore the diverse range of services we offer, unveil our mission to simplify global expansion, and understand what sets locize apart from the rest.\n\nJoin us as we take you on a journey through our history, showcase our comprehensive localization services, and illustrate why locize is your ultimate platform for achieving global reach.\n\nRead the full interview and gain insights into the future of localization here: [Innovating Software Localization: A Conversation with the CTO of locize](https://www.websiteplanet.com/blog/interview-locize/).\n\n[![](websiteplanet.png)](https://www.websiteplanet.com/blog/interview-locize/)\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"guest post","slug":"guest-post","permalink":"https://locize.com/blog/tags/guest-post/"}]},{"title":"Common Misconceptions About i18n: Debunking the Myths","slug":"i18n-misconceptions","date":"un11fin11","updated":"un00fin00","comments":true,"path":"i18n-misconceptions/","link":"","permalink":"https://locize.com/blog/i18n-misconceptions/","excerpt":"","text":"i18n, or internationalization, is a critical aspect of software development that allows applications to adapt to different languages and cultural norms. However, despite its importance, there are still a number of misconceptions about i18n that persist in the tech community. In this article, we will take a humorous and satirical look at some of the most common myths and misconceptions about i18n. So put on your sarcastic hats and let&#39;s dive into the world of i18n! Myth 1: i18n Is Only Important for Multinational CompaniesMany people believe that i18n is only relevant to large multinational corporations with customers around the world. This couldn&#39;t be further from the truth. In today&#39;s globalized world, even small businesses can benefit from i18n. By making your application available in multiple languages, you can expand your customer base and increase your revenue. Who wouldn&#39;t want that? Myth 2: i18n Is Just TranslationAnother common misconception about i18n is that it&#39;s just about translating text from one language to another. In fact, i18n is much more than that. It involves adapting user interfaces, date and time formats, and even cultural norms such as currency symbols and units of measurement. So if you thought i18n was just about running text through Google Translate, think again! Myth 3: i18n Is Too Expensive and Time-ConsumingSome developers believe that implementing i18n in their application is too expensive and time-consuming. Sure, it may take some extra effort up front, but the benefits far outweigh the costs. By making your application available to users around the world, you can reach new markets and increase your profits. And with translation management software tools, like locize, implementing i18n has never been easier or more affordable. Myth 4: i18n Is Only Relevant to Certain IndustriesSome people believe that i18n is only relevant to certain industries, such as e-commerce or travel. This could not be further from the truth. Virtually any type of application can benefit from i18n, from social media platforms to video games. After all, everyone deserves to be able to use an application in their own language and according to their own cultural norms. Play the game and try to make your application ready for localization! Myth 5: i18n Is Only Relevant to Non-English LanguagesFinally, some people believe that i18n is only relevant to non-English languages. In fact, i18n is just as important for English-language applications. After all, English is not the native language of everyone who uses it. And different English-speaking countries have their own cultural norms and inguistic quirks. By implementing i18n, you can ensure that your application is accessible to all English-speaking users, regardless of where they&#39;re from. ConclusionIn summary, i18n is a critical aspect of software development that is often misunderstood. By debunking these common misconceptions, we hope to help more developers realize the importance of i18n and incorporate it into their applications. So the next time someone tries to tell you that i18n is just translation or too expensive, you can set them straight. And who knows, maybe one day we&#39;ll all be speaking the same language... or not.","raw":"---\ntitle: \"Common Misconceptions About i18n: Debunking the Myths\"\ndescription: The article discusses and debunks common misconceptions about i18n (internationalization) in a humorous and satirical tone.\n\ndate: 2023-10-16\ntags:\n  - localization\n  - l10n\n  - i18n\n  - internationalization\n  - translation\n  - machine translation\n\nthumbnail: i18n-misconceptions/title.jpg\n\nlabel: i18n-misconceptions\nlang: en\n---\n\n![](title.jpg)\n\n[i18n](../what-is-i18n/), or internationalization, is a critical aspect of software development that allows applications to adapt to different languages and cultural norms. However, despite its importance, there are still a number of misconceptions about i18n that persist in the tech community. In this article, we will take a humorous and satirical look at some of the most common myths and misconceptions about i18n. So put on your sarcastic hats and let's dive into the world of i18n!\n\n\n## Myth 1: i18n Is Only Important for Multinational Companies\n\nMany people believe that i18n is only relevant to large multinational corporations with customers around the world. This couldn't be further from the truth. In today's globalized world, even small businesses can benefit from i18n. By making your application available in multiple languages, you can expand your customer base and [increase your revenue](../grow-online-business/). Who wouldn't want that?\n\n## Myth 2: i18n Is Just Translation\n\nAnother common misconception about i18n is that it's just about translating text from one language to another. In fact, i18n is much more than that. It involves adapting user interfaces, date and time formats, and even cultural norms such as currency symbols and units of measurement. So if you thought i18n was just about running text through [Google Translate](../google-translate-accuracy/), think again!\n\n## Myth 3: i18n Is Too Expensive and Time-Consuming\n\nSome developers believe that implementing i18n in their application is too expensive and time-consuming. Sure, it may take some extra effort up front, but the benefits far outweigh the costs. By making your application available to users around the world, you can reach new markets and increase your profits. And with [translation management software](../i18n-l10n-t9n-tms/) tools, like [locize](), implementing i18n has never been easier or more affordable.\n\n## Myth 4: i18n Is Only Relevant to Certain Industries\n\nSome people believe that i18n is only relevant to certain industries, such as e-commerce or travel. This could not be further from the truth. Virtually any type of application can benefit from i18n, from social media platforms to video games. After all, everyone deserves to be able to use an application in their own language and according to their own cultural norms. [Play the game](../is-your-software-ready-for-localization/) and try to make your application ready for localization!\n\n## Myth 5: i18n Is Only Relevant to Non-English Languages\n\nFinally, some people believe that i18n is only relevant to non-English languages. In fact, i18n is just as important for English-language applications. After all, English is not the [native language of everyone](../grow-online-business/) who uses it. And different English-speaking countries have their own cultural norms and inguistic quirks. By implementing i18n, you can ensure that your application is accessible to all English-speaking users, regardless of where they're from.\n\n## Conclusion\n\nIn summary, i18n is a critical aspect of [software development](../what-is-software-localization/) that is often misunderstood. By debunking these common misconceptions, we hope to help more developers realize the importance of i18n and incorporate it into their applications. So the next time someone tries to tell you that i18n is just translation or too expensive, you can set them straight. And who knows, maybe one day we'll all be speaking the same language... or not.\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"machine translation","slug":"machine-translation","permalink":"https://locize.com/blog/tags/machine-translation/"}]},{"title":"Say Hello to CAT (Computer-Assisted Translation): The Personal Translator in Your Pocket","slug":"cat","date":"un11fin11","updated":"un11fin11","comments":true,"path":"cat/","link":"","permalink":"https://locize.com/blog/cat/","excerpt":"","text":"Welcome to the world of CATs, or Computer-Assisted Translation Software! These handy little programs are like having a personal translator in your pocket (or on your computer, whichever you prefer). But what exactly is a CAT, you ask? Well, it&#39;s pretty much exactly what it sounds like. It&#39;s software that helps you translate text from one language to another. Think of it like having a bilingual friend who you can text whenever you come across a word or phrase you don&#39;t understand. Now, I know what you might be thinking: &quot;But wait, don&#39;t we already have Google Translate?&quot; And yes, you&#39;re right! Google Translate is a great tool for quick and easy translations. But CATs are a bit different. They&#39;re specifically designed for professional translators and are much more powerful than your average online translator. One of the most important features of CATs is their ability to &quot;remember&quot; translations. So, if you&#39;re working on a big project and you keep coming across the same phrase over and over again, the CAT will remember how you translated it the first time and will automatically use the same translation for all future instances. This can save you a lot of time and make your translations much more consistent. Another great feature of CATs is their ability to work with &quot;translation memories&quot;. These are databases of previously translated text, which can be used to help speed up the translation process and ensure consistency. So, if you&#39;re translating a document and you come across a sentence that&#39;s already been translated before, the CAT will pull up the previous translation and suggest it to you. Pretty cool, right? So, to sum it up, CATs are like having your own personal translator who never forgets anything and can access a vast library of translations. If you&#39;re a professional translator, they&#39;re an absolute must-have tool. And if you&#39;re not, they can still be a handy tool to have around for those times when you need to translate something quickly and easily. Also locize has a CAT. For example the global view: Or the focus view: But there&#39;s also an in-context view: In conclusion, CATs are the perfect tool for professional translators and anyone who needs a helping hand with translations! So, don&#39;t be shy, give them a try!","raw":"---\ntitle: \"Say Hello to CAT (Computer-Assisted Translation): The Personal Translator in Your Pocket\"\ndescription: Discover the power of Computer-Assisted Translation Software (CAT) for professional translators and anyone in need of a helping hand with translations. CATs are like having a personal translator that remembers everything and can access a vast library of translations, making your work faster and more consistent.\n\ndate: 2023-10-02\ntags:\n  - localization\n  - l10n\n  - translation\n  - machine translation\n\nthumbnail: cat/title.jpg\n\nlabel: cat\nlang: en\n---\n\n![](title.jpg)\n\nWelcome to the world of CATs, or Computer-Assisted Translation Software! These handy little programs are like having a personal translator in your pocket (or on your computer, whichever you prefer).\n\nBut what exactly is a [CAT](https://en.wikipedia.org/wiki/Computer-assisted_translation), you ask? Well, it's pretty much exactly what it sounds like. It's software that helps you translate text from one language to another. Think of it like having a bilingual friend who you can text whenever you come across a word or phrase you don't understand.\n\nNow, I know what you might be thinking: \"But wait, don't we already have [Google Translate](../google-translate-accuracy/)?\" And yes, you're right! Google Translate is a great tool for quick and easy translations. But CATs are a bit different. They're specifically designed for professional translators and are much more powerful than your average online translator.\n\nOne of the most important features of CATs is their ability to \"remember\" translations. So, if you're working on a big project and you keep coming across the [same phrase](https://docs.locize.com/whats-inside/glossary) over and over again, the CAT will remember how you translated it the first time and will automatically use the same translation for all future instances. This can save you a lot of time and make your translations much more consistent.\n\nAnother great feature of CATs is their ability to work with \"[translation memories](https://docs.locize.com/whats-inside/translation-memory)\". These are databases of previously translated text, which can be used to help speed up the translation process and ensure consistency. So, if you're translating a document and you come across a sentence that's already been translated before, the CAT will pull up the previous translation and suggest it to you. Pretty cool, right?\n\nSo, to sum it up, CATs are like having your own personal translator who never forgets anything and can access a vast library of translations. If you're a professional translator, they're an absolute must-have tool. And if you're not, they can still be a handy tool to have around for those times when you need to translate something quickly and easily.\n\nAlso locize has a CAT.\n<br />\nFor example the [global view](https://docs.locize.com/different-views/global):\n![](global.webp)\n<br />\nOr the [focus view](https://docs.locize.com/different-views/focus):\n![](focus.webp)\n<br />\nBut there's also an [in-context view](https://docs.locize.com/different-views/incontext):\n![](incontext.webp)\n\nIn conclusion, CATs are the perfect tool for professional translators and anyone who needs a helping hand with translations! So, don't be shy, give them a try!\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"machine translation","slug":"machine-translation","permalink":"https://locize.com/blog/tags/machine-translation/"}]},{"title":"What is i18n and what is its purpose (2024) | locize","slug":"what-is-i18n","date":"un55fin55","updated":"un00fin00","comments":true,"path":"what-is-i18n/","link":"","permalink":"https://locize.com/blog/what-is-i18n/","excerpt":"","text":"Today you&#39;re going to be introduced to a topic every growing business should be aware of. Find out more about the popular Big Mac from McDonald&#39;s and how it relates to this topic. In fact, this is the same topic that has helped many of our clients in growing even faster. i18n The number 18 represents letters between the first and last character, abbreviating 'internationalization' to 'i18n.' It's key for effectively localizing a product for diverse target markets. So, what exactly is i18n? Essentially, the meaning of it is a shortcut to internationalization, to make better use of it while write short instead of longer word. There is an easy way to master all your needs for i18n in relation to software. The best part? You don&#39;t need to make a huge investment in a technology stack. Let&#39;s get started. Table of contents What is internationalization How the industry treat it The different steps during internationalization The benefits of i18n-localization How are developers affected from it How to measure the success Conclusion Additional links What is internationalization In general, it refers to the process of bringing businesses into international markets. Typically, this type of company is led by an entrepreneur who thinks globally and has a good understanding of global cultures. As stated in the introduction, i18n is a shorthand for internationalization and is commonly used in the software industry. As a result of going global, companies&#39; product design and development suffer. You plan to enter foreign markets with your company, there is a huge demand for localizing an application, website content, or any document related. During this business transformation, the managers of those businesses must consider the new culture, region, and language. We live in an undeniably digital world, and things are only going to get faster. As a result, the software industry has developed it&#39;s own business model, with providers assisting with various digital services while entering new markets. These services are also known as localization-service. Finally, the terms internationalization and internationalizing-software are frequently used interchangeably, so we can answer &quot;what is i18n&quot; with an industry-term for businesses going international. It is not always given the attention it deserves In our opinion, the process of managing software to support local circumstances is in growing companies still a manual procedure. In this stage the company is in, a professional way is appreciated for the clients. Here are some interesting facts about internet surfers in Europe that showing how important localization is: Only a fraction of enterprises uses advanced digital technologies 56% of individuals in the EU have at least basic digital skills This demonstrates that only a few businesses are utilizing technology as they should today. According to the article, many more people will develop digital skills over the next decade. If you are a growing international business, i18n can assist you in meeting the needs of internet users. In the same vein, you will be able to improve the quality of your products or services by utilizing advanced digital technologies. Finally, according to data from the US Bureau of Economic Analysis, US businesses are increasingly providing services to foreigners. For the past few years, there has been a more than 15% increase. These figures show that every company must be aware of the internationalization of its operations, particularly its software. The software can be viewed as the primary means of achieving digital transformation. This leads us to the next subject on which you should brush up on your internationalization knowledge: The different steps during internationalization This can be used as step-by-step procedure: Build your team Evaluate the right translation management software Preparing your software (date, time, strings, languages, etc.) Take care of compliance Optimize marketing in app store and search engines Test your localization Learn and amend your solution An i18n-framework can be used for the preparation of your software during the process. In our ecosystem we have the i18next-framework which is more than just a collection of basic i18n functionalities (plurals, context, interpolation, format). It offers a comprehensive solution for localizing your product from the web to mobile and desktop. Bonus Tip Who knows a culture better than the people who live there? Make use of local specialists in each of your target markets. As a result, your team will be able to provide users with the most accurate, user-experience possible. This is, without a doubt, a very important aspect of i18n-approach. A translation-marketplace can help you find a translator very quickly, and your i18n will be far more effective. The benefits of i18n-localization There are numerous advantages to deploying your digital infrastructure with the appropriate technologies. If you choose the right partner, you can deliver comprehensive localization automation solutions that enable you to integrate localization into your continuous delivery workflow. Increase your consumer base Increase internet users&#39; contentment (user-experience) Enter new markets quickly and strategically Reduce your time, money, and effort All languages&#39; source code is centralized, making future modifications simple The internet market&#39;s reach is rapidly expanding Use global marketing to your advantage Businesses should study local consumer behaviors to tailor their product offerings and marketing strategies. For example the Big Mac Index provides a simplified way to understand the complexities of international markets. The Big Mac is a globally standardized product, allowing for a straightforward comparison of prices across countries. The Switzerland&#39;s $7.73 Big Mac, compared to the U.S. ($5.58) and the Euro area ($5.82), highlights the significance of adapting product pricing and strategies through internationalization (i18n) to account for local market conditions and consumer purchasing power. Localization goes beyond pricing; it includes adapting products, marketing messages, and customer experiences to align with local cultures and norms. Businesses should be aware of cultural nuances and tailor their offerings accordingly. Grow global with locize We at locize are specialists to make your internationalization a success story. ➡️ Check out the features of our localization management platform How are developers affected from it This is where l10n enters the picture. L10n, or localization, is the software component or service of internationalization. As a result, the developers who are involved are a critical component of your internationalization&#39;s success. i18n is the process by which developers prepare a software product for use in markets other than the one in which their company operates. Developers are indirectly responsible for the results that appear in search engine results such as Google. You can optimize Google Search results for your site if it provides different content to users in different languages, countries, or regions. This guide will help you on that. What is software-localizationWhen adapting a web product to a new customer base in a different region, a developer must take care of software localization. Typically, the process necessitates the complete modification of text and multimedia for a software product. As JavaScript and its frameworks are the most famous programming-languages today, there needs to be discussed how JavaScript applications can be adjusted for global audience. Following three main points with JavaScript are very well for localizing any application or website: JavaScript can detect the user’s preferred locale before giving them the option to manually select their own. This increases the user-experience and will result in more trust for your brand. There are functions help to handle right to left languages like Arabic or Persian. This ensures to expand also to countries with right-to-left language. If you don&#39;t want to reinvent the wheel, you can select a library that includes plugins for almost every situation. For example, i18next is an excellent choice for medium and large applications that require a significant amount of internationalization. Find your way of i18n This guide of JavaScript localization helps you find the right solution for your software-localization need with JavaScript. In this guide you will find also more information about how to manage locale at React-, Vue- or Angular application or more supported frameworks e.g. Flutter, Rails and more. How to measure the success You may ask yourself how you can track the progress of your project regarding internationalization. How many translations are left to be done? Is the localized-content also be used from website-visitors? Is your code on good quality or not? The integration of locize brings you the extra level of tracking and support. By accessing very important data of the project through the locize dashboard, this saves you endless time spent on localization. locize help to measure the progress: Allows for continuous localization Reporting on progress Reporting on usage Keep track of new translations Find out translated, fuzzy, warnings or untranslated keys Obtains your missing keys and sends them directly to the project Track user metrics on individual level (e.g. words) Review workflow when user changes language data as well as history of it Detect issues in the translation-keys Find out more at the locize documentation for issue detection. Conclusion How do you manage the internationalization of your application? Either way, let us know by write us an email to support@locize.com or leave us a comment on twitter or facebook right now. The term &quot;i18n&quot; is mostly associated with the software business. It defines the development operations required when a corporation expands into new countries or markets. i18n refers to a complete business that was created to meet the needs of clients who needed to convert their programs, websites, or video-games. If you&#39;re just starting out and want to learn more about &quot;what is i18n,&quot; the following links can be helpful. Additional links ➡️ Create a free new user account for advanced i18n-experience with locize ➡️ Find out more about react-i18n ➡️ Check out real examples at website-localization","raw":"---\ntitle: What is i18n and what is its purpose (2024) | locize\ndescription: Everything you need to know about internationalization. An easy-to-understand guide of what i18n is and what it's used for.\n\ndate: 2023-09-29\ntags:\n  - internationalization\n  - i18n\n  - website internationalization\n  - best practices\n  - web app translation\n\nthumbnail: what-is-i18n/what-is-i18n.webp\n\nlabel: what-is-i18n\nlang: en\n---\n\n![What is i18n](what-is-i18n.webp)\n\nToday you're going to be introduced to a topic every growing business should be aware of.\n\nFind out more about the popular Big Mac from McDonald's and how it relates to this topic.\n\nIn fact, this is the same topic that has helped many of our clients in growing even faster.\n\n<div id=\"term-i18n\" style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h2 style=\"color:orange;\"> i18n</h2>\n<p>The number 18 represents letters between the first and last character, abbreviating 'internationalization' to 'i18n.' It's key for effectively localizing a product for diverse target markets.</p>\n\n\n</div>\n\n\n\n\nSo, **what exactly is i18n**?\n\nEssentially, the meaning of it is a shortcut to internationalization, to make better use of it while write short instead of longer word.\n\n![i18n term](i18n-term.webp)\n\nThere is an easy way to master all your needs for i18n in relation to software.\n\nThe best part?\n\nYou don't need to make a huge investment in a technology stack.\n\nLet's get started.\n\n\n### Table of contents\n  * [What is internationalization](#intro)\n  * [How the industry treat it](#industry)\n  * [The different steps during internationalization](#fields)\n  * [The benefits of i18n-localization](#benefits)\n  * [How are developers affected from it](#developers)\n  * [How to measure the success](#measure)\n  * [Conclusion](#conclusion)\n  * [Additional links](#links)\n\n### What is internationalization <a name=\"intro\"></a>\n\nIn general, it refers to the process of bringing businesses into international markets. \n\nTypically, this type of company is led by an entrepreneur who thinks globally and has a good understanding of global cultures. As stated in the introduction, i18n is a shorthand for internationalization and is commonly used in the software industry. \n\nAs a result of going global, companies' product design and development suffer.\n\nYou plan to enter foreign markets with your company, there is a huge demand for localizing an application, website content, or any document related. During this business transformation, the managers of those businesses must consider the new culture, region, and language.\n\nWe live in an undeniably digital world, and things are only going to get faster. As a result, the software industry has developed it's own business model, with providers assisting with various digital services while entering new markets. \n\nThese services are also known as <a href=\"/\" title=\"localization-service\">localization-service</a>. Finally, the terms internationalization and internationalizing-software are frequently used interchangeably, so we can answer <b>\"what is i18n\"</b> with an industry-term for businesses going international.\n\n![international business](international-business.jpg)\n\n### It is not always given the attention it deserves <a name=\"industry\"></a>\n\nIn our opinion, the process of managing software to support local circumstances is in growing companies still a manual procedure. In this stage the company is in, a professional way is appreciated for the clients. Here are some interesting <a href=\"https://ec.europa.eu/commission/presscorner/detail/en/ip_21_5481\" title=\"facts about internet surfers in Europe\">facts about internet surfers in Europe</a> that showing how important localization is:\n\n- Only a fraction of enterprises uses advanced digital technologies\n- 56% of individuals in the EU have at least basic digital skills\n\nThis demonstrates that only a few businesses are utilizing technology as they should today. According to the article, many more people will develop digital skills over the next decade.\n\nIf you are a growing international business, i18n can assist you in meeting the needs of internet users. In the same vein, you will be able to improve the quality of your products or services by utilizing advanced digital technologies.\n\nFinally, according to <a href=\"https://www.bea.gov/data/intl-trade-investment/international-services-expanded\" title=\"data\">data</a> from the US Bureau of Economic Analysis, US businesses are increasingly providing services to foreigners. For the past few years, there has been a more than 15% increase.\n\nThese figures show that every company must be aware of the internationalization of its operations, particularly its software. The software can be viewed as the primary means of achieving digital transformation. This leads us to the next subject on which you should brush up on your internationalization knowledge:\n\n### The different steps during internationalization  <a name=\"fields\"></a>\nThis can be used as step-by-step procedure:\n\n- Build your team\n- Evaluate the right translation management software\n- Preparing your software (date, time, strings, languages, etc.)\n- Take care of compliance\n- Optimize marketing in app store and search engines\n- Test your localization\n- Learn and amend your solution\n\nAn i18n-framework can be used for the preparation of your software during the process. In our ecosystem we have the <a href=\"https://www.i18next.com/\" title=\"i18next\">i18next-framework</a> which is more than just a collection of basic i18n functionalities (plurals, context, interpolation, format). It offers a comprehensive solution for localizing your product from the web to mobile and desktop.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\"> Bonus Tip</h3>\n<p style=\"color:grey;\">Who knows a culture better than the people who live there? Make use of local specialists in each of your target markets. As a result, your team will be able to provide users with the most accurate, user-experience possible. \n  <br><br>\n  This is, without a doubt, a very important aspect of i18n-approach. A translation-marketplace can help you <a href=\"/services.html#translationservices\" title=\"find a translator\">find a translator</a> very quickly, and your i18n will be far more effective.</p>\n</div>\n\n### The benefits of i18n-localization <a name=\"benefits\"></a>\nThere are numerous advantages to deploying your digital infrastructure with the appropriate technologies. If you choose the right partner, you can deliver comprehensive localization automation solutions that enable you to integrate localization into your continuous delivery workflow.\n\n- Increase your consumer base\n- Increase internet users' contentment (user-experience)\n- Enter new markets quickly and strategically\n- Reduce your time, money, and effort\n- All languages' source code is centralized, making future modifications simple\n- The internet market's reach is rapidly expanding\n- Use global marketing to your advantage\n\nBusinesses should study local consumer behaviors to tailor their product offerings and marketing strategies.\n\nFor example the Big Mac Index provides a simplified way to understand the complexities of international markets. The Big Mac is a globally standardized product, allowing for a straightforward comparison of prices across countries. \n\n![big mac](bigmac.jpg)\n\n\n<a href=\"https://www.statista.com/statistics/274326/big-mac-index-global-prices-for-a-big-mac/\" title=\"The Switzerland's $7.73 Big Mac\">The Switzerland's $7.73 Big Mac</a>, compared to the U.S. ($5.58) and the Euro area ($5.82), highlights the significance of adapting product pricing and strategies through internationalization (i18n) to account for local market conditions and consumer purchasing power. \n\nLocalization goes beyond pricing; it includes adapting products, marketing messages, and customer experiences to align with local cultures and norms. Businesses should be aware of cultural nuances and tailor their offerings accordingly.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\"> Grow global with locize</h3>\nWe at locize are specialists to make your internationalization a success story.<br>\n➡️ Check out the features of our <a href=\"https://locize.com/#features\" title=\"localization management platform\">localization management platform</a>\n\n\n</div>\n\n### How are developers affected from it <a name=\"developers\"></a>\n\nThis is where l10n enters the picture. L10n, or localization, is the software component or service of internationalization. As a result, the developers who are involved are a critical component of your internationalization's success.\n\ni18n is the process by which developers prepare a software product for use in markets other than the one in which their company operates.\n\nDevelopers are indirectly responsible for the results that appear in search engine results such as Google. You can optimize Google Search results for your site if it provides different content to users in different languages, countries, or regions. \n\nThis <a href=\"https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-sites?visit_id=637780250358013835-1550662745&rd=1\" title=\"guide\">guide</a>  will help you on that.\n\n\n#### What is software-localization\nWhen adapting a web product to a new customer base in a different region, a developer must take care of [software localization](../what-is-software-localization/). Typically, the process necessitates the complete modification of text and multimedia for a software product.\n\nAs JavaScript and its frameworks are the most famous programming-languages today, there needs to be discussed how JavaScript applications can be adjusted for global audience. \n\nFollowing three main points with JavaScript are very well for localizing any application or website:\n\n- JavaScript can detect the user’s preferred locale before giving them the option to manually select their own. This increases the user-experience and will result in more trust for your brand.\n- There are functions help to handle right to left languages like Arabic or Persian. This ensures to expand also to countries with right-to-left language.\n- If you don't want to reinvent the wheel, you can select a library that includes plugins for almost every situation. For example, [i18next](https://www.i18next.com/) is an excellent choice for medium and large applications that require a significant amount of internationalization.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\">Find your way of i18n</h3>\nThis guide of <a href=\"/javascript-localization.html\" title=\"javascript localization\">JavaScript localization</a> helps you find the right solution for your software-localization need with JavaScript. In this guide you will find also more information about how to manage locale at React-, Vue- or Angular application or more supported frameworks e.g. Flutter, Rails and more.  \n</div>\n\n\n### How to measure the success <a name=\"measure\"></a>\n\nYou may ask yourself how you can track the progress of your project regarding internationalization. How many translations are left to be done? Is the localized-content also be used from website-visitors? Is your code on good quality or not?\n\n![locize](locize-dashboard.png)\n\nThe integration of locize brings you the extra level of tracking and support. By accessing very important data of the project through the locize dashboard, this saves you endless time spent on localization.\n\nlocize help to measure the progress:\n- Allows for continuous localization\n- Reporting on progress\n- Reporting on usage\n- Keep track of new translations\n- Find out translated, fuzzy, warnings or untranslated keys\n- Obtains your missing keys and sends them directly to the project\n- Track user metrics on individual level (e.g. words)\n- Review workflow when user changes language data as well as history of it\n- Detect issues in the translation-keys\n\n\nFind out more at the <a href=\"https://docs.locize.com/issues\" title=\"locize documentation for checks\">locize documentation for issue detection</a>.\n\n\n### Conclusion <a name=\"conclusion\"></a>\nHow do you manage the internationalization of your application? \n\n<b>Either way, let us know by write us an email to <a href=\"mailto:support@locize.com\" title=\"support@locize.com\">support@locize.com</a> or leave us a comment on <a href=\"https://twitter.com/locize\" title=\"twitter locize\">twitter</a> or <a href=\"https://www.facebook.com/locize\" title=\"facebook locize\">facebook</a> right now.</b>\n\nThe term \"i18n\" is mostly associated with the software business. \n\nIt defines the development operations required when a corporation expands into new countries or markets. \n\ni18n refers to a complete business that was created to meet the needs of clients who needed to convert their programs, websites, or <a href=\"../what-is-video-game-localization/\" title=\"video-games\">video-games</a>.\n\nIf you're just starting out and want to learn more about \"what is i18n,\" the following links can be helpful.\n\n\n### Additional links <a name=\"links\"></a>\n\n\n➡️ Create a free new [user account](https://www.locize.app/register) for advanced i18n-experience with locize\n\n➡️ Find out more about [react-i18n](../react-i18next/)\n\n➡️ Check out real examples at [website-localization](../website-localization/)","categories":[],"tags":[{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"website internationalization","slug":"website-internationalization","permalink":"https://locize.com/blog/tags/website-internationalization/"},{"name":"best practices","slug":"best-practices","permalink":"https://locize.com/blog/tags/best-practices/"},{"name":"web app translation","slug":"web-app-translation","permalink":"https://locize.com/blog/tags/web-app-translation/"}]},{"title":"Localization concept - a guide to adaption | locize","slug":"localization","date":"un44fin44","updated":"un44fin44","comments":true,"path":"localization/","link":"","permalink":"https://locize.com/blog/localization/","excerpt":"","text":"If you are asking yourself, what is localization, then this blog is here to help you. We take a closer look at what this means and how it can help you. What is localization Localization involves adapting a product or service to align with the language, culture, or preferences of a specific audience. A successful localization effort results in a product or service that seamlessly integrates with the local culture, giving the impression that it was originally created for that specific market. For international brands and organizations, it is essential in helping to give their customers the very best experience possible. An effective localization-process can transform a business, helping to increase reach and maximize engagements, but what exactly is it? Let&#39;s get started. Table of contents What is the concept of localization Real-life examples of successful localization-efforts Information on localization-strategies What are the goals of localization Resources related to the importance of localization in international markets Guides on how to implement localization Final thoughts What does localization mean So while language translation is the process of converting written content from one language into another, localization goes beyond this. It will look at things such as: LanguageTranslating text and ensuring it&#39;s culturally appropriate, considering idiomatic expressions, slang, and terminology specific to the target language. Content AdaptationAdapting content to align with the cultural norms, beliefs, and values of the target audience. This includes imagery, symbols, colors, and references that might be sensitive or offensive in a particular culture. Regional PreferencesCustomizing the product or content to cater to regional preferences, such as date formats, currencies, units of measurement, and other regional differences. User Interface (UI)Adjusting the user interface, layout, and design to accommodate different languages and reading directions (e.g., right-to-left for Arabic or Hebrew). Legal and Regulatory ComplianceEnsuring that the product or content complies with local laws, regulations, and industry standards. FunctionalityModifying features or functionality that may not be relevant or practical in the target market or adding features that are specific to that market. TestingRigorously testing the localized product or content to identify and resolve issues related to linguistic, cultural, or technical aspects. Localization is a crucial strategy for businesses of all sizes because it makes their content more appealing to the audience they are trying to reach. The process of first enabling a product to be localized, then localizing it for various national audiences is sometimes know as globalization. According to this article 40% of consumers have said that they will never purchase from a website that wasn’t in their native language. While 75% have said that they would be more likely to use a business again if their aftersales care was in their native language. With the help of this article, you can learn how to adapt your service or product to a specific language, culture, or target market, regardless of the industry you work in. Additionally, we will explain how to adapt content or products for various markets and geographical areas. But first, let&#39;s look at some successful examples of well-known brands using it. Real-life examples of successful localization-efforts Business Example Internationalization is becoming increasingly more common, and businesses are now interacting with clients and customers from across the globe. Localization should now be an essential part of their growth strategy, covering everything from company websites and marketing materials to legal documents and product manuals. One great example of this is Airbnb, which has successfully been able to expand its business into over 220 countries, each one offering a personal and localized touch to the consumer. Source: airbnb Software Example Localization is also a vital strategy in the world of software development. Everything from user experience to overall design will need to be considered to ensure that customers are getting the very best experience. A good example of software-localization is Netflix. The global streaming giant has become synonymous with efforts on both the translation side of things and on the developer side. The technology and processes that they utilize are translated and localized in every region, meaning the interface and apps change, as do the subtitles and voice dubbing of content. Even the films and TV shows they develop are localized for specific countries. Source: netflix Check out our more real-life examples on this page. What are the goals of localization The ultimate goal is to develop a clear user experience that helps to drive your marketing and support you in achieving your goals. However, there are many benefits that can come from implementing it, including: Enter new marketsOne of the main goals of a localization-strategy is to help brands to easily enter new markets. It will help overcome any logistical or legal hurdles, ensuring smooth communication across every partner. Secure a competitive edgeImplementing localization can also help companies to develop a competitive edge. Going against competitors in a local market can be incredibly challenging as they often have the trust of local audiences. It will help you to build that trust, giving you the edge. Improve customer satisfactionAnother important goal is that it helps to improve customer satisfaction. When they are seeing content in their own language and in a style they are more comfortable with; they are more likely to buy or use your products and services. Increase brand loyaltyWhen you are able to improve customer satisfaction, you will also increase brand loyalty. Communicating with customers in their own language and style will help you to secure their trust, increasing the likelihood of them returning. Maximize your profitAbove all, though, the main goal of a strategy is to help companies maximize their profit. When reach a much bigger and truly global audience you need to engage with them in a personal way, that you maximize the number of customers and in the end also the revenue. Resources related to the importance of localization in international markets Language Localization Language localization is the process of adapting content, software, or products to a specific language or linguistic region. Learn more Localization-Strategy A localization strategy is a comprehensive plan that outlines how a company adapts its products, services, or content for specific markets and cultures. Learn More Software Localization It's the process of customizing software applications and its UI/UX-design to function seamlessly in different languages and regions. Learn More Javascript Localization JavaScript localization is the practice of adapting JavaScript code and web applications to function effectively in multiple languages and regions. Learn More Website Localization Website localization involves adapting a website's content, design, and functionality to cater to diverse cultural and linguistic preferences of global audiences. Learn More Marketing Localization Marketing localization focuses on adapting marketing strategies and campaigns to resonate with the cultural nuances and preferences of target international markets. Learn More Guides on how to implement localization 1. Identifying what needs localization The first thing that you need to do is to determine if the content that you are needing to adapt. 2. The importance of comprehensive research Identifying these changes often requires comprehensive research into the culture and behaviors of your new target audience. 3. Professional assistance in making changes Once you have identified what changes are required, it is then time to begin making these changes. 4. Quality assurance for a seamless end product When all of those changes have been made, they will then need to go through an extensive Quality Assurance process. 5. Localization for various content types No matter whether you are looking to localize your website, marketing material, legal documents, or computer game. Check out this video to explore how our software can help you improve your process in terms of managing translations: Final thoughts Hopefully, this blog has helped to answer the initial question and given you more of an idea on how it can benefit your business. Implementing localization can be applied to any aspect of your business, and our highly experienced team has years of experience in helping clients. These are companies, software developers, and project-managers with all of their translation- and localization-management needs. We have worked with thousands of clients over the years, giving them the skills and knowledge to transform their operations. Have a question about localization? Leave us a message to support@locize.com right now. ➡️ Find out more about our website-localization-service ➡️ Create a free new user account to start free trial of our software ➡️ Want to read more about the topic? Then this article about software-localization is for you","raw":"---\ntitle: Localization concept - a guide to adaption | locize\t\ndescription: How to adapt a product or service to meet the needs of a particular language, culture, or desired population's look-and-feel. \n\ndate: 2023-09-21\ntags:\n  - localization\n  - l10n\nthumbnail: localization/localization.webp\n\nlabel: localization\nlang: en\n---\n\n\n![what is localization](localization.webp)\n\nIf you are asking yourself, <strong>what is localization</strong>, then this blog is here to help you. We take a closer look at what this means and how it can help you. \n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h2 style=\"color:orange;\">What is localization</h2>\n<p style=\"color:grey;\">Localization involves adapting a product or service to align with the language, culture, or preferences of a specific audience. A successful localization effort results in a product or service that seamlessly integrates with the local culture, giving the impression that it was originally created for that specific market.</p>\n</div>\n\n\n\nFor international brands and organizations, it is essential in helping to give their customers the very best experience possible. An effective localization-process can transform a business, helping to increase reach and maximize engagements, but what exactly is it?\n\nLet's get started.\n\n\n## Table of contents\n  * [What is the concept of localization](#concept)\n  * [Real-life examples of successful localization-efforts](#examples)\n  * [Information on localization-strategies](#examples)\n  * [What are the goals of localization](#goal)\n  * [Resources related to the importance of localization in international markets](#resources)\n  * [Guides on how to implement localization](#guides)\n  * [Final thoughts](#thoughts)\n\n## What does localization mean <a name=\"concept\"></a>\n\nSo while language translation is the process of converting written content from one language into another, localization goes beyond this. It will look at things such as:\n\n### Language\nTranslating text and ensuring it's culturally appropriate, considering idiomatic expressions, slang, and terminology specific to the target language.\n\n### Content Adaptation\nAdapting content to align with the cultural norms, beliefs, and values of the target audience. This includes imagery, symbols, colors, and references that might be sensitive or offensive in a particular culture.\n\n### Regional Preferences\nCustomizing the product or content to cater to regional preferences, such as date formats, currencies, units of measurement, and other regional differences.\n\n### User Interface (UI)\nAdjusting the user interface, layout, and design to accommodate different languages and reading directions (e.g., right-to-left for Arabic or Hebrew).\n\n### Legal and Regulatory Compliance\nEnsuring that the product or content complies with local laws, regulations, and industry standards.\n\n### Functionality\nModifying features or functionality that may not be relevant or practical in the target market or adding features that are specific to that market.\n\n### Testing\nRigorously testing the localized product or content to identify and resolve issues related to linguistic, cultural, or technical aspects.\n\n\nLocalization is a crucial strategy for businesses of all sizes because it makes their content more appealing to the audience they are trying to reach. The process of first enabling a product to be localized, then localizing it for various national audiences is sometimes know as <a href=\"/blog/globalization-vs-localization/\" title=\"globalization\">globalization</a>.\n\nAccording to [this article](https://insights.csa-research.com/reportaction/305013126/Marketing) 40% of consumers have said that they will never purchase from a website that wasn’t in their native language. While 75% have said that they would be more likely to use a business again if their aftersales care was in their native language.\n\nWith the help of this article, you can learn how to adapt your service or product to a specific language, culture, or target market, regardless of the industry you work in. \n\nAdditionally, we will explain how to adapt content or products for various markets and geographical areas.\n\nBut first, let's look at some successful examples of well-known brands using it.\n\n\n![populations look and feel](populations-look-and-feel.webp)\n\n\n## Real-life examples of successful localization-efforts <a name=\"examples\"></a>\n\n\n<div style=\"display: flex; background-color: #f0f0f0; padding: 20px;\">\n<div style=\"flex: 1; margin-right: 20px;\">\n    <img src=\"airbnb.png\" alt=\"Airbnb Image\">\n    <h3>Business Example</h3>\n    <p>Internationalization is becoming increasingly more common, and businesses are now interacting with clients and customers from across the globe. Localization should now be an essential part of their growth strategy, covering everything from company websites and marketing materials to legal documents and product manuals.</p>\n    <p>One great example of this is Airbnb, which has successfully been able to expand its business into over 220 countries, each one offering a personal and localized touch to the consumer.</p>\n    <span style=\"font-size:0.7rem\">Source: <a href=\"https://www.airbnb.com/\" title=\"airbnb\">airbnb</a></span>\n</div>\n\n<div style=\"flex: 1;\">\n    <img src=\"netflix.png\" alt=\"Netflix Image\">\n    <h3>Software Example</h3>\n    <p>Localization is also a vital strategy in the world of software development. Everything from user experience to overall design will need to be considered to ensure that customers are getting the very best experience.</p>\n    <p>A good example of software-localization is Netflix. The global streaming giant has become synonymous with efforts on both the translation side of things and on the developer side. The technology and processes that they utilize are translated and localized in every region, meaning the interface and apps change, as do the subtitles and voice dubbing of content. Even the films and TV shows they develop are localized for specific countries.</p>\n    <span style=\"font-size:0.7rem\">Source: <a href=\"https://www.netflix.com/\" title=\"netflix\">netflix</a></span>\n\n  </div>\n</div>\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<p style=\"color:grey;\">Check out our more real-life examples <a href=\"/customers.html\" title=\"Customer Success Stories\">on this page</a>.</p>\n</div>\n\n\n## What are the goals of localization <a name=\"goal\"></a>\nThe ultimate goal is to develop a clear user experience that helps to drive your marketing and support you in achieving your goals. However, there are many benefits that can come from implementing it, including:\n\n#### Enter new markets \nOne of the main goals of a <a href=\"/blog/localization-strategy\" title=\"localization-strategy\">localization-strategy</a> is to help brands to easily enter new markets. It will help overcome any logistical or legal hurdles, ensuring smooth communication across every partner. \n\n\n#### Secure a competitive edge \nImplementing localization can also help companies to develop a competitive edge. Going against competitors in a local market can be incredibly challenging as they often have the trust of local audiences. It will help you to build that trust, giving you the edge. \n\n#### Improve customer satisfaction \nAnother important goal is that it helps to improve customer satisfaction. When they are seeing content in their own language and in a style they are more comfortable with; they are more likely to buy or use your products and services. \n\n#### Increase brand loyalty \nWhen you are able to improve customer satisfaction, you will also increase brand loyalty. Communicating with customers in their own language and style will help you to secure their trust, increasing the likelihood of them returning. \n\n#### Maximize your profit\nAbove all, though, the main goal of a strategy is to help companies maximize their profit. When reach a much bigger and truly global audience you need to engage with them in a personal way, that you maximize the number of customers and in the end also the revenue. \n\n\n## Resources related to the importance of localization in international markets\n\n<div style=\"background-color: #1976d2;\">\n    <div style=\"display: flex; justify-content: space-around; flex-wrap: wrap; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\">\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Language Localization</h3>\n            <p style=\"min-height: 120px;\">Language localization is the process of adapting content, software, or products to a specific language or linguistic region.</p>\n            <a href=\"/blog/language-localization/\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn more</button>\n            </a>\n        </div>\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Localization-Strategy</h3>\n            <p style=\"min-height: 120px;\">A localization strategy is a comprehensive plan that outlines how a company adapts its products, services, or content for specific markets and cultures.</p>\n            <a href=\"/blog/localization-strategy/\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn More</button>\n            </a>\n        </div>\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Software Localization</h3>\n            <p style=\"min-height: 120px;\">\n                It's the process of customizing software applications and its UI/UX-design to function seamlessly in different languages and regions.</p>\n            <a title=\"Software Localization\" href=\"/blog/what-is-software-localization/\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn More</button>\n            </a>\n        </div>\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Javascript Localization</h3>\n            <p style=\"min-height: 120px;\">\nJavaScript localization is the practice of adapting JavaScript code and web applications to function effectively in multiple languages and regions. </p>\n            <a title=\"Javascript Localization\" href=\"/javascript-localization.html\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn More</button>\n            </a>\n        </div>\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Website Localization</h3>\n            <p style=\"min-height: 120px;\">Website localization involves adapting a website's content, design, and functionality to cater to diverse cultural and linguistic preferences of global audiences.</p>\n            <a title=\"Website Localization\" href=\"/blog/website-localization/\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn More</button>\n            </a>\n        </div>\n        <div style=\"flex: 0 0 calc(45% - 10px); margin: 10px; color: white;\">\n            <h3>Marketing Localization</h3>\n            <p style=\"min-height: 120px;\">Marketing localization focuses on adapting marketing strategies and campaigns to resonate with the cultural nuances and preferences of target international markets.</p>\n            <a  title=\"Marketing Localization\" href=\"/blog/localization-marketing/\" style=\"text-decoration: none;\">\n                <button style=\"background-color: #1b2431; color: #fff; padding: 10px 20px; border: none; border-radius: 5px;\">Learn More</button>\n            </a>\n        </div>\n    </div>\n</div>\n\n\n\n\n\n## Guides on how to implement localization <a name=\"guides\"></a>\n\n<ol style=\"list-style-type: none; padding: 1rem; background-color: #f0f0f0;\">\n  \n  <li style=\"margin-bottom: 20px;\">\n    <h3 style=\"font-weight: bold;\">1. Identifying what needs localization</h3>\n    <p>The first thing that you need to do is to determine if the content that you are needing to adapt.</p>\n  </li>\n  <li style=\"margin-bottom: 20px;\">\n    <h3 style=\"font-weight: bold;\">2. The importance of comprehensive research</h3>\n    <p>Identifying these changes often requires comprehensive research into the culture and behaviors of your new target audience.</p>\n  </li>\n  <li style=\"margin-bottom: 20px;\">\n    <h3 style=\"font-weight: bold;\">3. Professional assistance in making changes</h3>\n    <p>Once you have identified what changes are required, it is then time to begin making these changes.</p>\n  </li>\n  <li style=\"margin-bottom: 20px;\">\n    <h3 style=\"font-weight: bold;\">4. Quality assurance for a seamless end product</h3>\n    <p>When all of those changes have been made, they will then need to go through an extensive Quality Assurance process.</p>\n  </li>\n  <li style=\"margin-bottom: 20px;\">\n    <h3 style=\"font-weight: bold;\">5. Localization for various content types</h3>\n    <p>No matter whether you are looking to localize your website, marketing material, legal documents, or computer game.</p>\n  </li>\n  \n</ol>\n\n\n\n*Check out this [video](https://youtu.be/YQryHo1iHb8) to explore how our software can help you improve your process in terms of managing translations:*\n{% youtube YQryHo1iHb8 %}\n\n\n## Final thoughts <a name=\"thoughts\"></a>\n\nHopefully, this blog has helped to answer the initial question and given you more of an idea on how it can benefit your business. Implementing localization can be applied to any aspect of your business, and our highly experienced team has years of experience in helping clients. These are companies, software developers, and project-managers with all of their translation- and localization-management needs.\n\nWe have worked with thousands of clients over the years, giving them the skills and knowledge to transform their operations. Have a question about localization? Leave us a message to <a href=\"mailto:support@locize.com\" title=\"support@locize.com\">support@locize.com</a> right now.</b>\n\n\n➡️ Find out more about our <a href=\"/website-localization-services.html\" title=\"website-localization-service\">website-localization-service</a>\n\n➡️ Create a free new [user account](https://www.locize.app/register) to start free trial of our software\n\n➡️ Want to read more about the topic? Then this <a href=\"/blog/what-is-software-localization/\" title=\"article about software-localization\">article about software-localization</a> is for you\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"}]},{"title":"What is Software Localization? (2023 Update)","slug":"what-is-software-localization","date":"un44fin44","updated":"un44fin44","comments":true,"path":"what-is-software-localization/","link":"","permalink":"https://locize.com/blog/what-is-software-localization/","excerpt":"","text":"According to a recent study, the global market for software localization generated $5.9 billion in revenue in 2022 and is predicted to grow even more until 2032, when it is predicted to reach $15.6 billion. Since the COVID-19 pandemic, as businesses shifted operations online and broadened their global reach as a result of increased business focus on global expansion, this topic has become even more important. Software localization can be an expensive process, especially for small and medium-sized businesses (SMEs) with tight budgets, and it takes time and resources to ensure high-quality results in localization projects. What is it about and what benefits can it offer your business? If you are faced with this issue, you can get started with these details. Let&#39;s go! Table of contents What is software localization? How does localization take place? Why localization of software is important Successful implementation Who needs localization of software? Test our solution for free What is software localization? Software localization helps to adapt software to the language and circumstances of the target market while retaining its originality. This means that not only is the text being adapted into the relevant language, but the design and overall user experience (UX) are amended to ensure that it meets the needs of the target audience. While internationalization (i18n) is about developing a product to meet the demands of a specific culture or audience, localization of software is a far more in-depth solution. The process usually requires the complete modification of text and multimedia for a software product. For example, trying to localize a piece of software that is in English into Chinese is not simply a case of translating the wording. The length of text and symbols are entirely different, meaning the whole visual layout will need to be amended to ensure the overall user experience (UX) remains the same. Software localization goes much further than that, too. It also looks at the resources and links being used, the time- and date-format, the use of images or gestures to ensure they are culturally appropriate, and even the direction the text needs to be read in. This makes the whole process incredibly complex and time-consuming process, but it is a worthwhile investment for any developer. How does localization take place? Software can be localised in two core areas, internationsalisation and then localization. The internationalization process covers the design and development, which means you should: review your application framework to ensure it can support your requirements thoroughly plan your content, including understanding how much space translated text will require. incorporate the needs regarding content into the design, helping to make the localization more effective. code your strings to allow you to expand when required. externalize any strings that have been prepped for localization Once you have successfully completed the internationalization phase, you should then begin to incorporate the localization phase. This is the process of translating your content utilizing a skilled translator and ensuring they are covering every part of your software. The translation is one of the most important parts of your localization, so once complete, you must thoroughly review everything. This includes checking the accuracy of the content, the quality of the language, and the terminology being used. Once finished, you will then need to copy the translations into your software and begin testing it in every locality you are targeting. When you are certain that the software is working as designed and free from bugs, it can then be released to the public. Waterfall vs continuous localization: What’s the difference?For localization of software there are different workflows. The most traditional is to break down the activities into linear sequential phases - the so called waterfall workflow, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. Continuous software localization combines software development and localization into one process so that software developers work in parallel with the localization team from the very beginning: Why localization of software is important? Thanks to the advancement of technology, we now live in a highly connected world. We are able to communicate with companies and organizations across the globe in a matter of seconds. However, while communication has never been more accessible, being able to understand the nuances and cultural differences of these communities is crucial. Globalization gives software developers the chance to access hundreds of millions of potential new customers. In order to do this successfully, though, they need to ensure they are offering every client the very best user experience. There are many benefits to focusing on the software-localization-process, including: Maximizing your salesLocalization gives you the chance to enjoy success on an international scale. When you are able to provide the end user with the very best experience, no matter where in the world they might be located, it will ensure you can quickly and easily enter new markets. Not only will this help to maximize your sales, but it can also help to strengthen your position in both the local and international market. Improving user experienceHigh-quality localization can ensure everyone is able to enjoy the very best experience when using your products. Not only will they be able to clearly understand what you are saying, but they will get the most out of your software too. This improves the overall user experience, giving them a greater impression of your brand. Staying ahead of your competitorsIn the fast-paced world that we live in, keeping your brand ahead of your competitors has never been more important. The software localization definition is about giving your customers the very best experience possible. That will allow you to stand out from the crowd, minimizing the risk of losing potential customers while also helping you to attract even more customers. Enhancing feedbackAnother significant benefit of the localization process, but one that is often overlooked, is that it can help you enjoy more feedback. When you have more users engaging with your software, it will help you to develop more in-depth feedback and generate more ideas for the future. 9 steps to successfully implement software localization This guide will walk you through the essential steps to successfully implement software localization in your company. Whether you&#39;re a small startup or a large enterprise, embracing localization can help your software resonate with international users and drive business growth. 1) Assessment and PlanningChoose the languages and markets you want to target. Check to see if your software is localization-ready with these questions: Is your code dependable and bug-free? Has your main language UI been put into place? Is your text in main language complete? Is your character encoding correct? 2) TranslationChoose professional translators or translation tools. Maintain context and accuracy during the translation process. A professional translation management system has integrations with platforms offering translation services. A TMS supports increased project effectiveness, lower manual error rates, and guarantee timely delivery of localized software. 3) Visual Elements / Graphic DesignCustomize visual elements to align with local preferences. Respect cultural norms and sensitivities. It would help if you also considered implementing a style guide, covering things such as your branding, tone of voice, and formality. This will ensure a consistent and clear approach, no matter where in the world your users are accessing your software. 4) Compliance with Legal and Regulatory RequirementsEnsure compliance with local laws and regulations. Conduct a thorough analysis of legal and regulatory requirements that pertain to your software, including data privacy laws like GDPR, accessibility standards such as WCAG , and industry-specific regulations. 5) TestingThoroughly test the localized software for functionality and display. Identify and fix issues during the testing phase. 6) Quality Assurance (QA)Establish a QA process to ensure the quality of localized versions. Address any bugs or issues found during QA. 7) Documentation and SupportTranslate user documentation and support materials. Offer customer support in the localized languages. 8) Release and DistributionPrepare localized versions for distribution. Update marketing materials to promote the new languages. 9) Maintenance and UpdatesRegularly update localized versions while maintaining quality. See it as an extension of your software developmentTo make sure the localization-process is as efficient and effective as possible, you should see it as an extension of your development. That means rather than seeing it as a task to complete in the final stages, you should incorporate it in every step of your software development. By adopting this approach, you can ensure that you are maximizing the user experience, and it can also help to speed up the delivery time. Use a localization platformEffective software localization is a vast project, and utilizing a proven localization management platform can help to make the process easier. When choosing a platform, you should ensure that it has been developed specifically for localization. This will help to offer greater customization and allow you to integrate essential tools. For example react localization is made incredibly simple for developers when used in conjunction with the i18next framework. You may use locize to make the process of the localization-projects of your company easier. Locize is the platform for effectively localizing your website, mobile app, video game or any other web product. Who needs localization of software? The next decision is whether it is right for you. If your software targets a specific community or a selected region, localization might not be required. However, if you are looking to expand into wider communities or give yourself the opportunity to do that at a later date, then it is something you should consider. Even if you are not considering an international move just yet, you should prepare as much as you can during the development stage. The industry you work in should also be a major consideration. Software localization should be a major consideration for those working in the e-commerce, legal, or governmental sectors. Of course, it is not just limited to these sectors, so make sure you consider both your current and future requirements when deciding if you need l10n. In this technology-driven world, globalization means seeing an increasing number of organizations and companies working beyond their traditional localities. Software localization is crucial in helping you to successfully expand your business to other countries, allowing you to maximize your sales, boost your profits, and stand out from the crowd. You definitely will need it when your business plan targets multiple regions or is region specific you&#39;re developing your software code right now. It&#39;s easy to take care of localization at this stage you have a many-to-many business model and are planning to grow exponentially. These types of developers should take care of localization: Web developers Developing code that tells websites and web applications how to operate. SaaS or cloud developers Developing cloud-based applications and making it available to end users. Desktop application developers Writing code for software applications that run natively on operating systems. Virtual Reality application developers Creating and testing applications in virtual reality or metaverse. Mobile app developers Developing software applications for smartphones and other mobile devices. Video game developers Helping transform games from a concept to a playable reality. Blockchain developers Enabling secure digital transactions by creating systems to record and store blockchain data in a way that prevents changes or hacks. Integration developers Responsible for the complete life cycle of information systems. Localization of software in parallel to development Connect your project directly to locize and automatically have new &quot;non-translated&quot; parts of your application sent to locize. You will be able to use locize CDN translations or translate within your web application directly. All newly generated keys in the reference language are automatically translated into the target languages using machine translation, such as Google Translate, when this option is selected. Now we want to turn it over to you: Do you plan to invest in software localiztion? Will you change the way development and translation are handled? You might also have a query regarding something you read. Either way, let us know by leaving a message to &#x73;&#x75;&#112;&#112;&#111;&#x72;&#116;&#x40;&#x6c;&#111;&#99;&#105;&#x7a;&#101;&#46;&#99;&#x6f;&#x6d; right now. Register for freeFor a 14-day free trial period, register for free below and start your localization experience today! Or learn more about the platform&#39;s features, benefits, and if it is the right solution for you. register Learn more","raw":"---\ntitle: What is Software Localization? (2023 Update)\ndescription: Software localization is to adapt software to the language and circumstances of the target market while retaining its originality.\n\ndate: 2023-09-07\ntags:\n  - workflow\n  - process\n  - testing\n  - software development\nthumbnail: what-is-software-localization/software-localization.webp\n---\n\n![software localization](software-localization.webp \"Software Localization\")\n\n\nAccording to a <a href=\"https://finance.yahoo.com/news/software-localization-market-reach-15-140100165.html\" title=\"recent study\">recent study</a>, the global market for software localization generated $5.9 billion in revenue in 2022 and is predicted to grow even more until 2032, when it is predicted to reach $15.6 billion.\n\nSince the COVID-19 pandemic, as businesses shifted operations online and broadened their global reach as a result of increased business focus on global expansion, this topic has become even more important.\n\nSoftware localization can be an expensive process, especially for small and medium-sized businesses (SMEs) with tight budgets, and it takes time and resources to ensure high-quality results in localization projects. \n\n\nWhat is it about and what benefits can it offer your business?\n\nIf you are faced with this issue, you can get started with these details. \n\nLet's go!\n\n\n## Table of contents\n  * [What is software localization?](#what)\n  * [How does localization take place?](#undertaken)\n  * [Why localization of software is important](#important)\n  * [Successful implementation](#process)\n  * [Who needs localization of software?](#who)\n  * [Test our solution for free](#nextlevel)\n\n\n## What is software localization? <a name=\"what\"></a>\nSoftware localization helps to adapt software to the language and circumstances of the target market while retaining its originality. This means that not only is the text being adapted into the relevant language, but the design and overall user experience (UX) are amended to ensure that it meets the needs of the target audience.\n\nWhile [internationalization (i18n)](../what-is-i18n/) is about developing a product to meet the demands of a specific culture or audience, localization of software is a far more in-depth solution. The process usually requires the complete modification of text and multimedia for a software product. \n\nFor example, trying to localize a piece of software that is in English into Chinese is not simply a case of translating the wording. The length of text and symbols are entirely different, meaning the whole visual layout will need to be amended to ensure the overall user experience (UX) remains the same.\n\nSoftware localization goes much further than that, too. It also looks at the resources and links being used, the time- and date-format, the use of images or gestures to ensure they are culturally appropriate, and even the direction the text needs to be read in.\n\nThis makes the whole process incredibly complex and time-consuming process, but it is a worthwhile investment for any developer.\n\n## How does localization take place? <a name=\"undertaken\"></a>\nSoftware can be localised in two core areas, internationsalisation and then localization. The <b>internationalization</b> process <b>covers the design and development</b>, which means you should:\n* review your application framework to ensure it can support your requirements\n* thoroughly plan your content, including understanding how much space translated text will require. \n* incorporate the needs regarding content into the design, helping to make the localization more effective.\n* code your strings to allow you to expand when required.\n* externalize any strings that have been prepped for localization\n\nOnce you have successfully completed the internationalization phase, you should then begin to incorporate the <b>localization</b> phase. This is <b>the process of translating your content utilizing a skilled translator</b> and ensuring they are covering every part of your software.\n\nThe translation is one of the most important parts of your localization, so once complete, you must thoroughly review everything. This includes checking the accuracy of the content, the quality of the language, and the terminology being used.\n\nOnce finished, you will then need to copy the translations into your software and begin testing it in every locality you are targeting. When you are certain that the software is working as designed and free from bugs, it can then be released to the public.\n\n\n### Waterfall vs continuous localization: What’s the difference?\n\nFor localization of software there are different workflows. The most traditional is to break down the activities into linear sequential phases - the so called waterfall workflow, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks.\n\n![waterfall workflow](waterfall-workflow.webp \"waterfall workflow\")\n\n[Continuous software localization](/blog/modern-continuous-localization/\n) combines software development and localization into one process so that software developers work in parallel with the localization team from the very beginning:\n\n![continous workflow](continous-workflow.webp \"continous workflow\")\n\n\n## Why localization of software is important? <a name=\"important\"></a>\nThanks to the advancement of technology, we now live in a highly connected world. We are able to communicate with companies and organizations across the globe in a matter of seconds. However, while communication has never been more accessible, being able to understand the nuances and cultural differences of these communities is crucial.\n\n<b>Globalization</b> gives software developers the chance to access <b>hundreds of millions of potential new customers</b>. In order to do this successfully, though, they need to ensure they are offering every client the very best user experience.\n\nThere are many benefits to focusing on the software-localization-process, including:\n\n### Maximizing your sales\nLocalization gives you the chance to enjoy success on an international scale. When you are able to provide the end user with the very best experience, no matter where in the world they might be located, it will ensure you can quickly and easily enter new markets. Not only will this help to maximize your sales, but it can also help to strengthen your position in both the local and international market.\n\n###\tImproving user experience\nHigh-quality localization can ensure everyone is able to enjoy the very best experience when using your products. Not only will they be able to clearly understand what you are saying, but they will get the most out of your software too. This improves the overall user experience, giving them a greater impression of your brand.\n\n### Staying ahead of your competitors\nIn the fast-paced world that we live in, keeping your brand ahead of your competitors has never been more important. The software localization definition is about giving your customers the very best experience possible. That will allow you to stand out from the crowd, minimizing the risk of losing potential customers while also helping you to attract even more customers.\n\n### Enhancing feedback\nAnother significant benefit of the localization process, but one that is often overlooked, is that it can help you enjoy more feedback. When you have more users engaging with your software, it will help you to develop more in-depth feedback and generate more ideas for the future.\n\n![project managers](project-managers.webp \"project managers\")\n\n\n## 9 steps to successfully implement software localization <a name=\"process\"></a>\n\nThis guide will walk you through the essential steps to successfully implement software localization in your company. Whether you're a small startup or a large enterprise, embracing localization can help your software resonate with international users and drive business growth.\n\n### 1) Assessment and Planning\n\nChoose the languages and markets you want to target.\nCheck to see if your software is localization-ready with these questions:\n- Is your code dependable and bug-free?\n- Has your main language UI been put into place?\n- Is your text in main language complete?\n- Is your character encoding correct?\n\n\n### 2) Translation\n\nChoose professional translators or translation tools. Maintain context and accuracy during the translation process. A professional [translation management system](/blog/tms/\n) has integrations with platforms offering translation services. A TMS supports increased project effectiveness, lower manual error rates, and guarantee timely delivery of localized software. \n\n### 3) Visual Elements / Graphic Design\nCustomize visual elements to align with local preferences. Respect cultural norms and sensitivities. It would help if you also considered implementing a style guide, covering things such as your branding, tone of voice, and formality. This will ensure a consistent and clear approach, no matter where in the world your users are accessing your software.\n\n### 4) Compliance with Legal and Regulatory Requirements\nEnsure compliance with local laws and regulations. Conduct a thorough analysis of legal and regulatory requirements that pertain to your software, including data privacy laws like <a href=\"https://gdpr-info.eu/\" title=\"GDPR\">GDPR</a>, accessibility standards such as <a href=\"https://en.wikipedia.org/wiki/Web_Content_Accessibility_Guidelines\" title=\"WCAG\">WCAG</a> , and industry-specific regulations.\n\n\n\n### 5) Testing\nThoroughly test the localized software for functionality and display. Identify and fix issues during the testing phase.\n\n### 6) Quality Assurance (QA)\n\n\nEstablish a <a href=\"https://www.techtarget.com/searchsoftwarequality/definition/quality-assurance\" title=\"QA\">QA</a>  process to ensure the quality of localized versions. Address any bugs or issues found during QA.\n\n### 7) Documentation and Support\nTranslate user documentation and support materials. Offer customer support in the localized languages.\n\n### 8) Release and Distribution\nPrepare localized versions for distribution. Update marketing materials to promote the new languages.\n\n### 9) Maintenance and Updates\nRegularly update localized versions while maintaining quality.\n\n\n\n\n### See it as an extension of your software development\nTo make sure the localization-process is as efficient and effective as possible, you should see it as an extension of your development. That means rather than seeing it as a task to complete in the final stages, you should incorporate it in every step of your software development. By adopting this approach, you can ensure that you are maximizing the user experience, and it can also help to speed up the delivery time.\n\n\n\n### Use a localization platform\nEffective software localization is a vast project, and utilizing a proven <a href=\"https://locize.com\" title=\"localization management platform\">localization management platform</a> can help to make the process easier. When choosing a platform, you should ensure that it has been developed specifically for localization. This will help to offer greater customization and allow you to integrate essential tools. For example <a href=\"/blog/react-i18next/\" title=\"react localization\">react localization</a> is made incredibly simple for developers when used in conjunction with the <a href=\"https://www.i18next.com/\" title=\"i18next\">i18next</a> framework.\n\nYou may use locize to make the process of the localization-projects of your company easier. Locize is the platform for effectively localizing your website, mobile app, video game or any other web product.\n![process](software_localization_process.png \"software_localization_process\")\n\n\n\n\n## Who needs localization of software? <a name=\"who\"></a>\nThe next decision is whether it is right for you. If your software targets a specific community or a selected region, localization might not be required.\n\nHowever, if you are looking to expand into wider communities or give yourself the opportunity to do that at a later date, then it is something you should consider. Even if you are not considering an international move just yet, you should prepare as much as you can during the development stage.\n\nThe industry you work in should also be a major consideration. <b>Software localization should be a major consideration</b> for those working in the e-commerce, legal, or governmental sectors. Of course, it is not just limited to these sectors, so make sure you consider both your current and future requirements when deciding if you need l10n.\n\nIn this technology-driven world, globalization means seeing an increasing number of organizations and companies working beyond their traditional localities. Software localization is crucial in helping you to successfully expand your business to other countries, allowing you to maximize your sales, boost your profits, and stand out from the crowd.\n\nYou definitely will need it when\n\n* your business plan targets multiple regions or is region specific\n* you're developing your software code right now. It's easy to take care of localization at this stage\n* you have a many-to-many business model and are planning to grow exponentially. \n\nThese types of developers should take care of localization:\n\n<div style=\"display:flex;flex-wrap:wrap;\">\n\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Web developers</h3>\n<p>Developing code that tells websites and web applications how to operate.</p>\n</div>\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\"><a href=\"https://en.wikipedia.org/wiki/Software_as_a_service\" target=\"__blank\" title=\"Saas\">SaaS</a> or cloud <br>developers</h3>\n<p>Developing cloud-based applications and making it available to end users.</p>\n</div>\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Desktop application developers</h3>\n<p>Writing code for software applications that run natively on operating systems.</p>\n</div>\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Virtual Reality application developers</h3>\n<p>Creating and testing applications in virtual reality or metaverse.</p>\n</div>\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Mobile app developers</h3>\n<p>Developing software applications for smartphones and other mobile devices.</p>\n</div>\n\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Video game developers</h3>\n<p>Helping transform games from a concept to a playable reality.</p>\n</div>\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Blockchain developers</h3>\n<p>Enabling secure digital transactions by creating systems to record and store blockchain data in a way that prevents changes or hacks.</p>\n</div>\n\n\n\n<div style=\"width:400px;margin:1rem;\">\n<h3 style=\"text-decoration:underline\">Integration developers</h3>\n<p>Responsible for the complete life cycle of information systems.</p>\n</div>\n\n</div>\n\n![](locize.jpg \"locize\")\n\n## Localization of software in parallel to development <a name=\"nextlevel\"></a>\nConnect your project directly to locize and automatically have new \"non-translated\" parts of your application sent to locize. You will be able to use locize CDN translations or translate within your web application directly. All newly generated keys in the reference language are automatically translated into the target languages using machine translation, such as Google Translate, when this option is selected.\n\nNow we want to turn it over to you:\n\nDo you plan to invest in software localiztion?\n\nWill you change the way development and translation are handled?\n\nYou might also have a query regarding something you read.\n\nEither way, let us know by leaving a message to support@locize.com right now.\n\n#### Register for free\nFor a 14-day free trial period, register for free below and start your localization experience today! Or learn more about the platform's features, benefits, and if it is the right solution for you.\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://www.locize.app/register\" title=\"register to locize\">register</a> <a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://locize.com/how-it-works.html\" title=\"how it works\">Learn more</a>\n\n\n","categories":[],"tags":[{"name":"process","slug":"process","permalink":"https://locize.com/blog/tags/process/"},{"name":"workflow","slug":"workflow","permalink":"https://locize.com/blog/tags/workflow/"},{"name":"testing","slug":"testing","permalink":"https://locize.com/blog/tags/testing/"},{"name":"software development","slug":"software-development","permalink":"https://locize.com/blog/tags/software-development/"}]},{"title":"Breaking Down Language Barriers: A Look into the Future of Translation and Localization","slug":"future-of-translation","date":"un33fin33","updated":"un33fin33","comments":true,"path":"future-of-translation/","link":"","permalink":"https://locize.com/blog/future-of-translation/","excerpt":"","text":"As technology continues to advance, the field of translation and localization is also seeing significant changes. In the coming years, we can expect to see a number of developments that will improve the accuracy and efficiency of language translation, making it easier for people and businesses to communicate across borders. One of the most exciting developments in the field of translation is the use of neural machine translation (NMT), like Google Translate. NMT is a form of artificial intelligence (AI) that is able to learn the intricacies of a particular language and apply that knowledge to translations. This has led to a significant improvement in the quality of translations, particularly for less common languages. Another area where we can expect to see advancements is in the use of natural language processing (NLP) to aid in localization. NLP is a field of AI that deals with the interaction between computers and human language. By using NLP techniques, like ChatGPT, software can be made to understand and respond to language in a more human-like way. This will make localization more accurate and efficient, as software will be able to understand the nuances and idioms of different languages and cultures. With the increasing use of virtual and augmented reality technology, we can expect to see more demand for the translation of multimedia content. The ability to translate and localize video, audio and other multimedia content will become increasingly important as this technology becomes more prevalent. This also present new challenges and possibilities for localization, as translation engine will need to deal with idiomatic language, context, and tone. We can also expect to see an increase in the use of crowdsourcing for translation and localization. By leveraging the power of the crowd, companies will be able to quickly and cost-effectively translate and localize their content into multiple languages. This has already been used in some companies, but will become more mainstream in the future as the approach improves and becomes more accessible. In conclusion, the field of translation and localization is constantly evolving, and we can expect to see a number of exciting advancements in the coming years. The use of neural machine translation, natural language processing, and multimedia localization will improve the accuracy and efficiency of language translation. Additionally, the use of crowdsourcing will make it more cost-effective for businesses to communicate across borders. These developments will have far-reaching implications for industries such as e-commerce, education, entertainment, and many more, breaking down language barriers and making the world a more connected place. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is neural machine translation (NMT), and how is it changing the translation industry?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Neural Machine Translation (NMT) is a form of artificial intelligence (AI) that uses deep learning techniques to understand and translate text from one language to another. It differs from traditional machine translation methods by learning the intricacies of specific languages, resulting in more accurate and contextually relevant translations. NMT has significantly improved the quality of translations, especially for less common languages, making it a game-changer in the translation industry.\" } },{ \"@type\": \"Question\", \"name\": \"How does natural language processing (NLP) contribute to localization efforts, and what benefits does it offer?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Natural Language Processing (NLP) is a branch of AI that focuses on the interaction between computers and human language. In localization, NLP techniques are used to enhance the understanding and response of software to human language, making it more human-like. This benefits localization by enabling software to grasp nuances, idioms, and cultural context, resulting in more accurate and efficient translations across languages and cultures.\" } },{ \"@type\": \"Question\", \"name\": \"Why is the translation of multimedia content becoming increasingly important, and what challenges does it pose?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The translation of multimedia content is gaining importance due to the growing use of virtual and augmented reality technologies. These technologies rely heavily on multimedia, including video, audio, and interactive content. However, translating multimedia content is challenging because it requires addressing idiomatic language, maintaining context, and capturing tone, all of which are crucial for a seamless user experience.\" } },{ \"@type\": \"Question\", \"name\": \"What is crowdsourcing in the context of translation and localization, and how can companies benefit from it?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Crowdsourcing in translation and localization involves tapping into a diverse group of contributors, often from different regions and language backgrounds, to translate and localize content. Companies can benefit from crowdsourcing by gaining access to a large pool of translators, enabling them to translate and localize content quickly and cost-effectively. Crowdsourcing is already being used by some companies and is expected to become more mainstream as it becomes more accessible and efficient.\" } },{ \"@type\": \"Question\", \"name\": \"How will these advancements in translation and localization technology impact various industries, and what are some examples of these impacts?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"These advancements in translation and localization technology will have far-reaching impacts across industries. For example, in e-commerce, accurate and efficient translation can open up new markets and increase global sales. In education, it can provide access to educational materials in multiple languages, promoting global learning. In the entertainment industry, it can enhance the reach of movies, games, and content worldwide. Overall, these advancements will break down language barriers and create more connected and accessible global markets.\" } }] }","raw":"---\ntitle: \"Breaking Down Language Barriers: A Look into the Future of Translation and Localization\"\ndescription: This article explores the latest technology and trend that are shaping the industry of translation and localization. The article highlights the importance of neural machine translation, natural language processing, multimedia localization, and crowdsourcing for efficient and accurate translations.\n\ndate: 2023-09-06\ntags:\n  - international strategy\n  - localization\n  - globalization\n  - l10n\n  - g11n\n  - translation\n  - global localization\n  - machine translation\n\nthumbnail: future-of-translation/title.jpg\n\nlabel: future-of-translation\nlang: en\n---\n\n![](title.jpg)\n\nAs technology continues to advance, the field of translation and localization is also seeing significant changes. In the coming years, we can expect to see a number of developments that will improve the accuracy and efficiency of language translation, making it easier for people and businesses to communicate across borders.\n\nOne of the most exciting developments in the field of translation is the use of neural machine translation (NMT), like [Google Translate](../google-translate-accuracy/). NMT is a form of artificial intelligence (AI) that is able to learn the intricacies of a particular language and apply that knowledge to translations. This has led to a significant improvement in the quality of translations, particularly for less common languages.\n\nAnother area where we can expect to see advancements is in the use of natural language processing (NLP) to aid in localization. NLP is a field of AI that deals with the interaction between computers and human language. By using NLP techniques, like [ChatGPT](../google-translate-accuracy/#google-translate-competitors), software can be made to understand and respond to language in a more human-like way. This will make localization more accurate and efficient, as software will be able to understand the nuances and idioms of different languages and cultures.\n\nWith the increasing use of virtual and augmented reality technology, we can expect to see more demand for the translation of multimedia content. The ability to translate and localize video, audio and other multimedia content will become increasingly important as this technology becomes more prevalent. This also present new challenges and possibilities for localization, as translation engine will need to deal with idiomatic language, context, and tone.\n\nWe can also expect to see an increase in the use of crowdsourcing for translation and localization. By leveraging the power of the crowd, companies will be able to quickly and cost-effectively translate and localize their content into multiple languages. This has already [been used in some companies](https://docs.locize.com/guides-tips-and-tricks/working-with-translators#use-the-crowdbased-service-branched-projects), but will become more mainstream in the future as the approach improves and becomes more accessible.\n\nIn conclusion, the field of translation and localization is constantly evolving, and we can expect to see a number of exciting advancements in the coming years. The use of neural machine translation, natural language processing, and multimedia localization will improve the accuracy and efficiency of language translation. Additionally, the use of crowdsourcing will make it more cost-effective for businesses to communicate across borders. These developments will have far-reaching implications for industries such as e-commerce, education, entertainment, and many more, breaking down language barriers and making the world a more connected place.\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is neural machine translation (NMT), and how is it changing the translation industry?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Neural Machine Translation (NMT) is a form of artificial intelligence (AI) that uses deep learning techniques to understand and translate text from one language to another. It differs from traditional machine translation methods by learning the intricacies of specific languages, resulting in more accurate and contextually relevant translations. NMT has significantly improved the quality of translations, especially for less common languages, making it a game-changer in the translation industry.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does natural language processing (NLP) contribute to localization efforts, and what benefits does it offer?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Natural Language Processing (NLP) is a branch of AI that focuses on the interaction between computers and human language. In localization, NLP techniques are used to enhance the understanding and response of software to human language, making it more human-like. This benefits localization by enabling software to grasp nuances, idioms, and cultural context, resulting in more accurate and efficient translations across languages and cultures.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Why is the translation of multimedia content becoming increasingly important, and what challenges does it pose?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The translation of multimedia content is gaining importance due to the growing use of virtual and augmented reality technologies. These technologies rely heavily on multimedia, including video, audio, and interactive content. However, translating multimedia content is challenging because it requires addressing idiomatic language, maintaining context, and capturing tone, all of which are crucial for a seamless user experience.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is crowdsourcing in the context of translation and localization, and how can companies benefit from it?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Crowdsourcing in translation and localization involves tapping into a diverse group of contributors, often from different regions and language backgrounds, to translate and localize content. Companies can benefit from crowdsourcing by gaining access to a large pool of translators, enabling them to translate and localize content quickly and cost-effectively. Crowdsourcing is already being used by some companies and is expected to become more mainstream as it becomes more accessible and efficient.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How will these advancements in translation and localization technology impact various industries, and what are some examples of these impacts?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"These advancements in translation and localization technology will have far-reaching impacts across industries. For example, in e-commerce, accurate and efficient translation can open up new markets and increase global sales. In education, it can provide access to educational materials in multiple languages, promoting global learning. In the entertainment industry, it can enhance the reach of movies, games, and content worldwide. Overall, these advancements will break down language barriers and create more connected and accessible global markets.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"machine translation","slug":"machine-translation","permalink":"https://locize.com/blog/tags/machine-translation/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"globalization","slug":"globalization","permalink":"https://locize.com/blog/tags/globalization/"},{"name":"g11n","slug":"g11n","permalink":"https://locize.com/blog/tags/g11n/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"}]},{"title":"Uniting Swiss Excellence: Locize and Supertext Join Forces for Seamless Software Localization","slug":"supertext-partnership","date":"un55fin55","updated":"un66fin66","comments":true,"path":"supertext-partnership/","link":"","permalink":"https://locize.com/blog/supertext-partnership/","excerpt":"","text":"In a landmark collaboration that epitomizes Swiss innovation, Locize and Supertext have come together to revolutionize the realm of software localization. Both being Swiss-made, the partnership results in a harmonious blend of precision, efficiency, and quality that promises to reshape the way companies expand their global reach while maintaining a consistent brand voice. The Powerhouses: Locize and SupertextLocize, a trailblazer in software localization, has earned its reputation as a go-to platform for developers and companies looking to enter new international markets. With a focus on simplifying the complexities of translation and localization, Locize empowers teams to seamlessly adapt their software interfaces and digital content across languages and cultures. Having created the foundation with i18next (one of the leading open source internationalization frameworks) it is the perfect translation management fit with a focus on continuous localization. Supertext, on the other hand, has carved out its own niche as a leader in translation, copywriting, and proofreading services. With a carefully curated team of over 3,000 professional translators and copywriters, Supertext has remained steadfast in its mission to free the world from bad copy and ensure that brands&#39; identities remain intact as they venture into new linguistic territories. A Natural Synergy: Why Locize and Supertext Are a Perfect MatchThe union between Locize and Supertext is akin to combining the precision of Swiss watchmaking with the artistry of Swiss chocolatiers. This synergy promises a holistic approach to software localization that preserves the essence of a brand while adapting it to resonate with diverse audiences. At its core, the integration empowers users to seamlessly order Supertext translations directly from within the Locize platform. Here&#39;s how the magic works: 1. Create a Supertext account and API tokenGetting started is easy. If you haven&#39;t already done so, start by creating a Supertext account, where you&#39;ll gain access to a world-class team of linguists ready to transform your content. Create a new API token that acts as the bridge between Locize and Supertext. 1) First, sign in to your Supertext account with your email address and password. 2) Then click on &quot;Settings&quot; in your profile menu: 3) Scroll all the way down until you see the “API authentication tokens” section. There, click on &quot;New API token&quot;, then enter an appropriate label and click on the check mark: 4) Copy the generated API token (we will use it later in Locize) 2. Configuring Supertext in LocizeThis step ensures a secure and seamless connection between the platforms. 1) Navigate to your Locize project settings page: 2) Then select the &quot;ordering&quot; tab, where the Supertext configuration awaits: 3) Click on &quot;configure&quot;: 4) Enter the email associated with your Supertext account and the API token you generated earlier: Optionally, set your default order type (translation or proofreading) and your industry. 3. Effortless Order PlacementWith the groundwork laid, the process of ordering Supertext translations becomes an effortless endeavor. 1) Navigate to the &quot;orders&quot; page: 2) Click on &quot;new order&quot;: 3) Make your appropriate selections and click &quot;get a quote&quot;: 4) Select the desired order type, delivery type and optional comment, then click &quot;confirm &amp; order&quot;: The locize order will now appear on your &quot;orders&quot; page: And the ordered segments are marked as ordered: 5) Follow the progress on Supertext, each language generates a Supertext order: 6) When the translations are finished, they are automatically merged back into Locize: In the focus view, in the history tab, you can see when the translations were merged back. 7) On Supertext, you can give feedback, etc.: A Shared Vision: Embracing the FutureAs this groundbreaking partnership unfolds, it&#39;s clear that both Locize and Supertext share a common vision - to empower companies to overcome language barriers while preserving the essence of their communication. This collaboration not only simplifies the localization journey, but also demonstrates the potential that exists when two Swiss-made companies with a commitment to excellence combine their strengths. At the heart of this alliance, the employees and customers of both Locize and Supertext have reason to celebrate. The journey ahead promises smoother workflows, greater efficiency, and an unwavering commitment to delivering unparalleled localization solutions. In conclusion, as Locize and Supertext embark on this exciting journey together, they invite the world to witness the birth of a new era in software localization. The combination of precision, innovation, and unwavering dedication is set to redefine how brands transcend borders, and with every successful localization, a piece of Switzerland&#39;s legacy travels the globe, connecting cultures and reshaping the future of communication. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is the partnership between Locize and Supertext all about?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The partnership between Locize and Supertext aims to enhance the process of software localization by seamlessly integrating Supertext's expert translation services into the Locize platform. This collaboration allows businesses to efficiently translate and adapt their software interfaces and content for global audiences while maintaining their brand identity.\" } }, { \"@type\": \"Question\", \"name\": \"How does the integration between Locize and Supertext work?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The integration process is designed to be user-friendly. Users can create a Supertext account and generate a dedicated API token. This token acts as a secure bridge between Locize and Supertext. Within the Locize platform, users can configure their Supertext account by entering the associated email and API token. Once configured, users can easily place orders for Supertext translations directly within Locize.\" } }, { \"@type\": \"Question\", \"name\": \"What are the benefits of using Supertext's translation services through Locize?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"By utilizing Supertext's translation services through Locize, businesses can achieve accurate and culturally sensitive software localization without the hassle of manual handoffs between platforms. This integration streamlines the entire localization process, allowing teams to focus on expanding their global reach while Supertext's linguists handle the linguistic intricacies.\" } }, { \"@type\": \"Question\", \"name\": \"Can you provide an overview of the order placement process within the integrated platform?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The order placement process involves a few simple steps: After creating a Supertext account and API token, users configure their Supertext account settings within Locize. To place an order, users navigate to the orders page in Locize, select the content to be translated, and submit the order to Supertext. The translations are automatically merged back into Locize once completed, eliminating the need for manual updates.\" } }, { \"@type\": \"Question\", \"name\": \"What impact does this partnership have on the future of software localization?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The partnership between Locize and Supertext represents a significant step forward in the field of software localization. It showcases how the collaboration of two Swiss-made platforms can redefine how businesses overcome language barriers while preserving their brand integrity. This integration paves the way for smoother workflows, enhanced efficiency, and a commitment to delivering top-tier localization solutions.\" } }] }","raw":"---\ntitle: \"Uniting Swiss Excellence: Locize and Supertext Join Forces for Seamless Software Localization\"\ndescription: \"Swiss software localization pioneers Locize and Supertext form an unparalleled partnership, seamlessly integrating Supertext's expert translation services into the Locize platform, revolutionizing global expansion with precision and artistry.\"\n\ndate: 2023-08-25\ntags:\n  - localization\n  - l10n\n  - translation management\n  - tms\n  - locize\n  - service\n  - order\n  - translation\nthumbnail: supertext-partnership/title.jpg\n\nlabel: supertext-partnership\nlang: en\n---\n\n![](title.jpg)\n\nIn a landmark collaboration that epitomizes Swiss innovation, [Locize](/) and [Supertext](https://www.supertext.ch) have come together to revolutionize the realm of [software localization](../what-is-software-localization/). Both being Swiss-made, the partnership results in a harmonious blend of precision, efficiency, and quality that promises to reshape the way companies expand their [global reach](../grow-online-business/) while maintaining a consistent brand voice.\n\n## The Powerhouses: Locize and Supertext\n\nLocize, a trailblazer in software localization, has earned its reputation as a go-to platform for developers and companies looking to enter new international markets. With a focus on simplifying the complexities of translation and localization, Locize empowers teams to seamlessly adapt their software interfaces and digital content across languages and cultures.\nHaving created the foundation with [i18next](https://www.i18next.com) *(one of the leading [open source](/open-source.html) [internationalization](../what-is-i18n/) frameworks)* it is the perfect [translation management](../how-to-choose-the-right-translation-management-system/) fit with a focus on [continuous localization](../modern-continuous-localization/).\n\nSupertext, on the other hand, has carved out its own niche as a leader in translation, copywriting, and proofreading services. With a carefully curated team of over 3,000 professional translators and copywriters, Supertext has remained steadfast in its mission to free the world from bad copy and ensure that brands' identities remain intact as they venture into new linguistic territories.\n\n![](supertext_hill.jpg)\n\n## A Natural Synergy: Why Locize and Supertext Are a Perfect Match\n\nThe union between Locize and Supertext is akin to combining the precision of [Swiss watchmaking](https://en.wikipedia.org/wiki/Watchmaker#:~:text=The%20majority%20of%20modern%20watchmakers,%20particularly%20in%20Switzerland) with the artistry of [Swiss chocolatiers](https://en.wikipedia.org/wiki/Swiss_chocolate). This synergy promises a holistic approach to software localization that preserves the essence of a brand while adapting it to resonate with [diverse audiences](../language-localization/).\n\nAt its core, the integration empowers users to seamlessly order Supertext translations directly from within the Locize platform. Here's how the magic works:\n\n### 1. Create a Supertext account and API token\n\nGetting started is easy. If you haven't already done so, start by [creating a Supertext account](https://www.supertext.ch/en/signup), where you'll gain access to a world-class team of linguists ready to transform your content. Create a new API token that acts as the bridge between Locize and Supertext.\n\n**1) First, [sign in](https://www.supertext.ch/person/en/account/login) to your Supertext account with your email address and password.**\n\n**2) Then click on \"Settings\" in your profile menu:**\n![](supertext_nav.jpg)\n\n**3) Scroll all the way down until you see the “API authentication tokens” section. There, click on \"New API token\", then enter an appropriate label and click on the check mark:**\n![](supertext_api-key.jpg)\n\n**4) Copy the generated API token (we will use it later in Locize)**\n![](supertext_api-key_copy.jpg)\n\n\n### 2. Configuring Supertext in Locize\n\nThis step ensures a secure and seamless connection between the platforms.\n\n**1) Navigate to your Locize project settings page:**\n![](locize_nav_settings.jpg)\n\n**2) Then select the \"ordering\" tab, where the Supertext configuration awaits:**\n![](locize_nav_ordering.jpg)\n\n**3) Click on \"configure\":**\n![](locize_supertext_config_start.jpg)\n\n**4) Enter the email associated with your Supertext account and the API token you generated earlier:**\n![](locize_supertext_config_set.jpg)\nOptionally, set your default order type (translation or proofreading) and your industry.\n\n\n### 3. Effortless Order Placement\n\nWith the groundwork laid, the process of ordering Supertext translations becomes an effortless endeavor.\n\n**1) Navigate to the \"orders\" page:**\n![](locize_nav_orders.jpg)\n\n**2) Click on \"new order\":**\n![](locize_new_order_start.jpg)\n\n**3) Make your appropriate selections and click \"get a quote\":**\n![](locize_new_order_quote.jpg)\n\n**4) Select the desired order type, delivery type and optional comment, then click \"confirm & order\":**\n![](locize_new_order_order.jpg)\n\nThe locize order will now appear on your \"orders\" page:\n![](locize_orders.jpg)\n\nAnd the ordered segments are marked as ordered:\n![](locize_cat_ordered.jpg)\n\n**5) Follow the progress on Supertext, each language generates a Supertext order:**\n![](supertext_orders.jpg)\n\n**6) When the translations are finished, they are automatically merged back into Locize:**\n![](locize_cat_order_competed.jpg)\n\nIn the [focus view](https://docs.locize.com/different-views/focus), in the [history tab](https://docs.locize.com/whats-inside/history), you can see when the translations were merged back.\n![](locize_cat_focus.jpg)\n\n**7) On Supertext, you can give feedback, etc.:**\n![](supertext_order_feedback.jpg)\n\n\n## A Shared Vision: Embracing the Future\n\nAs this groundbreaking partnership unfolds, it's clear that both [Locize](/) and [Supertext](https://www.supertext.ch) share a common vision - to empower companies to overcome language barriers while preserving the essence of their communication. This collaboration not only simplifies the localization journey, but also demonstrates the potential that exists when two Swiss-made companies with a commitment to excellence combine their strengths.\n\nAt the heart of this alliance, the employees and customers of both Locize and Supertext have reason to celebrate. The journey ahead promises smoother workflows, greater efficiency, and an unwavering commitment to delivering unparalleled localization solutions.\n\nIn conclusion, as Locize and Supertext embark on this exciting journey together, they invite the world to witness the birth of a new era in software localization. The combination of precision, innovation, and unwavering dedication is set to redefine how brands transcend borders, and with every successful localization, a piece of Switzerland's legacy travels the globe, connecting cultures and reshaping the future of communication.\n\n![](switzerland.jpg)\n\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is the partnership between Locize and Supertext all about?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The partnership between Locize and Supertext aims to enhance the process of software localization by seamlessly integrating Supertext's expert translation services into the Locize platform. This collaboration allows businesses to efficiently translate and adapt their software interfaces and content for global audiences while maintaining their brand identity.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How does the integration between Locize and Supertext work?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The integration process is designed to be user-friendly. Users can create a Supertext account and generate a dedicated API token. This token acts as a secure bridge between Locize and Supertext. Within the Locize platform, users can configure their Supertext account by entering the associated email and API token. Once configured, users can easily place orders for Supertext translations directly within Locize.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What are the benefits of using Supertext's translation services through Locize?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"By utilizing Supertext's translation services through Locize, businesses can achieve accurate and culturally sensitive software localization without the hassle of manual handoffs between platforms. This integration streamlines the entire localization process, allowing teams to focus on expanding their global reach while Supertext's linguists handle the linguistic intricacies.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Can you provide an overview of the order placement process within the integrated platform?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The order placement process involves a few simple steps: After creating a Supertext account and API token, users configure their Supertext account settings within Locize. To place an order, users navigate to the orders page in Locize, select the content to be translated, and submit the order to Supertext. The translations are automatically merged back into Locize once completed, eliminating the need for manual updates.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What impact does this partnership have on the future of software localization?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The partnership between Locize and Supertext represents a significant step forward in the field of software localization. It showcases how the collaboration of two Swiss-made platforms can redefine how businesses overcome language barriers while preserving their brand integrity. This integration paves the way for smoother workflows, enhanced efficiency, and a commitment to delivering top-tier localization solutions.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"service","slug":"service","permalink":"https://locize.com/blog/tags/service/"},{"name":"translation management","slug":"translation-management","permalink":"https://locize.com/blog/tags/translation-management/"},{"name":"tms","slug":"tms","permalink":"https://locize.com/blog/tags/tms/"},{"name":"order","slug":"order","permalink":"https://locize.com/blog/tags/order/"}]},{"title":"How to Choose the Best fitting Translation Management System","slug":"how-to-choose-the-right-translation-management-system","date":"un33fin33","updated":"un44fin44","comments":true,"path":"how-to-choose-the-right-translation-management-system/","link":"","permalink":"https://locize.com/blog/how-to-choose-the-right-translation-management-system/","excerpt":"","text":"Multilingual support has become a necessity for web and application development. Enter i18next, a powerful internationalization framework that has redefined language translations for developers since its inception in 2011. As we venture into the realm of i18next and its ideal companion, we explore a seamless integration that empowers projects to flourish on the global stage. TOC I. Introduction A. The Significance of i18next as an Extensible Internationalization Framework B. Introducing a Comprehensive Translation Management Tool C. The Purpose of this Blog Post II. Understanding i18next and the Need for an Effective TMS A. The Background and History of i18next B. The Maturity and Extensibility of i18next C. The Richness of i18next&#39;s Features III. Practical Tips for Evaluating and Selecting a TMS with i18next A. Research and Evaluation B. Trial and Testing C. Collaboration and Feedback D. Support and Documentation E. Pricing and Scalability F. Integration with Developer Tools IV. Key Considerations for Choosing a TMS with i18next A. Compatibility and Integration B. Translation Workflow and Collaboration Features C. Support for Localization File Formats D. Customization and Flexibility V. Introducing locize: A Unique Translation Management Solution A. The Close Alignment with i18next Principles B. Unique Features Setting locize Apart C. locize: The Perfect TMS for i18next-Powered Projects VI. Conclusion: Why locize is the Perfect TMS to Choose I. Introduction A. The Significance of i18next as an Extensible Internationalization Framework In the ever-expanding landscape of web and application development, catering to a global audience is no longer a choice but a necessity. Websites and software products must accommodate users from diverse linguistic backgrounds, making internationalization a crucial aspect of modern development practices. At the forefront of this domain stands i18next, a well-established and highly extensible internationalization framework. Since its inception in late 2011, i18next has grown into one of the most favored open-source solutions for enabling multilingual support in web and mobile applications. Its widespread adoption can be attributed to its maturity, versatility, and continuous evolution to meet the changing needs of the localization community. From handling simple key-value translations to supporting complex pluralization and language detection, i18next has proven itself as a reliable and powerful tool. B. Introducing a Comprehensive Translation Management Tool As i18next&#39;s popularity surged, developers encountered a new challenge - managing translations effectively across projects and keeping up with a growing user base. The demand for a seamless translation management solution became evident, leading to the birth of a new service, a comprehensive translation management system (TMS) and the official sponsor of i18next. What sets it apart from other TMS offerings is its deep integration with i18next, designed to cater to the specific needs of i18next-powered projects. Instead of being just another localization-as-a-service offering, it goes above and beyond to provide a robust ecosystem for internationalization. The creators of i18next, being the founders of a TMS, brought their expertise and experience to ensure that it seamlessly complements the i18next framework. C. The Purpose of this Blog Post In this blog post, we embark on a journey to explore the capabilities of a TMS and its integration with i18next, with a focus on how the system designed by the i18next founders stands out in particular as the perfect TMS for managing translations in i18next projects. We will delve into the unique features that set it apart from alternatives, understanding its role as an essential component in the localization workflow. Throughout this article, we will provide insights and practical tips for developers and localization teams looking to select the right TMS with seamless i18next integration. By the end, readers will have a clear understanding of several advantages, empowering them to make informed decisions when choosing a translation management system that optimizes their i18next-powered localization workflow. Join us as we unravel the strengths of i18next and the capabilities of a good translation management system, offering a powerful combination for efficient and effective software localization in the globalized digital landscape. II. Understanding i18next and the Need for an Effective TMS A. The Background and History of i18next To comprehend the importance of an effective translation management system, it&#39;s essential to grasp the foundation on which it is built - i18next. Born in 2011, i18next emerged as a solution to a critical challenge faced by developers - finding an internationalization library that could seamlessly run on both server-side and client-side single-page applications. From its humble beginnings, i18next quickly gained momentum, becoming one of the most widely used frameworks for translating web and mobile applications. Its success was fueled by an extraordinary response from the community, which led to the establishment of a fast-growing ecosystem around i18next. V2 of i18next, released in 2015, marked a significant milestone. With this release, i18next was completely rebuilt to be highly extensible, ensuring smooth compatibility with previous versions. As a result, developers could effortlessly adopt newer releases without disrupting existing codebases. The robustness of the i18next API, which is still actively tested and supported, solidified its reputation as a dependable choice for internationalization. And nowadays, i18next also offers type safety for your translations. Whenever a developer employs a non-existent or modified i18n key, the TypeScript compiler immediately raises an error, promptly alerting you to the issue before it gives rise to runtime complications. B. The Maturity and Extensibility of i18next Having withstood the test of time, i18next has garnered a reputation for being a mature and reliable framework. Its longevity in the open-source community is a testament to its adaptability, with no i18n case deemed unsolvable by i18next. From small projects to enterprise-grade applications, developers have found i18next to be an indispensable tool for multilingual support. The extensibility of i18next is another compelling aspect. This framework can be integrated into any JavaScript environment, making it compatible with various UI frameworks, i18n formats, and even non-JavaScript platforms such as .NET, Elm, iOS, Android, Ruby, and more. The versatility and flexibility of i18next allow developers to tailor the internationalization process to fit specific project requirements and workflows, catering to the diverse needs of different teams and applications. C. The Richness of i18next&#39;s Features Beyond its core capabilities, i18next stands out for its rich feature set, which surpasses many traditional i18n frameworks. From basic interpolation and formatting to advanced functionalities such as translations from multiple sources, language detection, plural form resolutions, and caching, i18next provides a comprehensive suite of tools for developers to handle multilingual complexities effortlessly. The heart of i18next&#39;s success lies not just in its technical proficiency but also in the vibrant community that surrounds it. Users actively contribute feedback and improvements, enriching the ecosystem with valuable insights. As a result, i18next continues to evolve and adapt, remaining at the forefront of internationalization and setting the stage for a seamless integration with a translation management system. With a solid understanding of i18next&#39;s significance and features, we can now delve deeper into the area of translation management systems and which TMS is the perfect one to complement the power of i18next. III. Key Considerations for Choosing a TMS with i18next When it comes to selecting a translation management system (TMS) that seamlessly integrates with i18next, several key considerations are crucial to ensure a smooth and efficient localization workflow. Let&#39;s explore these essential factors to help you make an informed decision: A. Compatibility and Integration The first and foremost consideration is ensuring compatibility and seamless integration with i18next. A TMS, built with a focus on i18next, should effortlessly fit into your existing i18next-powered projects without major disruptions. Look for features that allow you to link your i18next translations directly to the TMS, ensuring consistent synchronization between your codebase and localization files. B. Translation Workflow and Collaboration Features An effective TMS should simplify your translation workflow and facilitate seamless collaboration between developers, translators, and localization managers. Features like versioning, translation tagging, collaboration, and change tracking are vital to maintain a smooth and efficient localization process. With strong versioning support and integration with third-party translation services, you gain the tools to streamline the translation workflow and optimize collaboration. C. Support for Localization File Formats Ensure that the TMS supports the localization file formats used by i18next. As i18next is compatible with various file formats, such as JSON, YAML, PO, and more, the TMS should seamlessly handle these formats to import and export translations effortlessly. A good TMS is designed with this compatibility in mind, ensuring that i18next developers can continue working with their preferred file formats. D. Customization and Flexibility Every project has unique requirements and workflows. A flexible TMS should offer customizable settings to adapt to your specific needs. This includes the ability to configure language settings, custom translation workflows, and permissions for team members. By providing customization options, a TMS empowers you to tailor the localization process to suit your project&#39;s exact requirements. By carefully considering these key factors, you can confidently select a TMS that aligns with i18next principles and enhances your localization workflow. Now, let&#39;s move on to the practical tips for evaluating and selecting the ideal TMS with seamless i18next integration. IV. Practical Tips for Evaluating and Selecting a TMS with i18next Now that we have explored the key considerations for choosing a TMS that seamlessly integrates with i18next, let&#39;s dive into practical tips to help you evaluate and select the ideal TMS for your localization needs: A. Research and Evaluation Start by conducting thorough research on various TMS options available in the market. Look for TMS solutions that specifically highlight their compatibility with i18next and offer features tailored to support its unique requirements. Read user reviews and testimonials to gain insights into the experiences of other developers and localization teams. B. Trial and Testing Many TMS providers offer free trials or demo versions. Take advantage of these opportunities to test the TMS with your existing i18next projects. This hands-on experience will allow you to assess how well the TMS integrates with i18next and how user-friendly it is for your team. C. Collaboration and Feedback Engage in conversations with your development team and localization managers. Gather their feedback and consider their input when evaluating TMS options. Understanding their specific pain points and requirements will help you make an informed decision that aligns with your team&#39;s preferences and workflow. D. Support and Documentation Reliable customer support is crucial when dealing with complex internationalization and localization tasks. Look for TMS providers that offer responsive customer support and comprehensive documentation - not only for the TMS itself, but also for i18next. Having readily available resources and assistance will ensure that your team can resolve any issues quickly and efficiently. E. Pricing and Scalability Carefully evaluate the pricing models offered by different TMS providers. Consider the scalability of the TMS and how it aligns with your project&#39;s growth potential. Look for transparent pricing structures that suit your project&#39;s needs without hidden costs. Ask yourself: &quot;Do I pay too much just by scratching the border of the next bigger plan? Or does the costs scale with the project growth?&quot; F. Integration with Developer Tools Efficiency is vital in any development process. Check if the TMS integrates smoothly with other tools and platforms that your development team already uses. Seamless integration with code repositories, build systems, and deployment platforms will enhance your team&#39;s productivity. By following these practical tips, you can confidently assess and select a TMS, that ensures smooth integration with i18next and streamlines your localization workflow. V. Introducing locize: A Unique Translation Management Solution A. The Close Alignment with i18next Principles As the official sponsor of i18next, locize is more than just another translation management system; it is a TMS designed to harmonize with the core principles and philosophy of i18next. Developed by the same creators as i18next, locize benefits from a deep understanding of the needs and challenges faced by developers and localization teams. This close alignment ensures that locize seamlessly integrates with i18next, offering a unified and optimized experience for managing translations. By leveraging i18next&#39;s extensible architecture, locize empowers users to leverage the full potential of the framework while providing additional tools and features that go beyond traditional translation management. B. Unique Features Setting locize Apart 1. Strong Support for Versioning and Software Development ProcessOne of locize&#39;s standout features is its robust support for versioning, a critical aspect of software development. Proper versioning ensures that changes to translations are managed efficiently, facilitating collaboration among developers and localization teams. With locize, users can confidently make updates and track progress without the fear of losing previous translations or creating confusion. 2. Freedom from Service Lock-InUnlike some other translation management services, locize believes in giving users the freedom to choose. While locize offers exceptional value as a TMS, it does not lock users into its platform. Instead, users can export their translations and use them with i18next or other preferred localization frameworks. This approach empowers users with full control over their translation data and enhances the flexibility of their localization workflow. 3. Exceptional Support from i18next CreatorsThe backing of the i18next creators ensures that locize users receive unparalleled support and expertise in internationalization and localization. The team behind locize is intimately familiar with the intricacies of i18next, providing developers with valuable guidance and assistance in optimizing their localization workflow. 4. Support for Multiple Namespace/Files and Proper Pluralizationlocize goes beyond standard translation management offerings by providing support for multiple namespaces or files within a project. This allows developers to organize translations efficiently, ensuring clarity and simplicity in the localization process. Additionally, locize understands the complexities of pluralization rules in different languages. By correctly calculating progress in various languages based on distinct pluralization rules, locize ensures that translations are accurate and contextually appropriate, regardless of the language being translated. 5. Integration with Third-Party Translation ServicesTo cater to diverse user needs, locize offers integration with third-party translation services. This feature allows users to leverage additional capabilities provided by these services, such as project finalization, the option to work with preferred translators, approvals, and direct contact with translators. The integration with third-party services streamlines the translation process and allows users to collaborate effectively with translation professionals. 6. Freedom to choose how to serve your translationsWhile you get most comfort out of using the locize CDN, your environment might demand you to bundle the translations with your product (eg. offline usage in areas with restricted internet access or with offline fallback). Using the CDN has three big advantages: You can deploy updates to translations without the need to redeploy/rollout a new version of your application. During development, testing you can set your versions to auto publishing. Doing so your translation changes are reflected immediately in your application and results in a lot easier development process. You can easily set a version to publish in private mode, which means you will need an API key to download your translations. This enables you for example to use locize as before but without leaking any information to the public. If your product demands to download the translations, because you need or prefer to host or bundle them yourself you can do so. Using our CDN is completely optional and get only billed if you’re using it. You can download/export the translations using the API or the locize UI or the CLI, also in various formats. C. locize: The Perfect TMS for i18next-Powered Projects With its deep integration with i18next, locize emerges as the perfect translation management system for developers and localization teams working with i18next-powered projects. Its unique features, built on a foundation of understanding and commitment to i18next principles, make it a standout choice in the realm of translation management. In the next section, we will explore key considerations for selecting a TMS with a focus on seamless i18next integration, ensuring that your localization workflow remains efficient, accurate, and hassle-free. VI. Conclusion: Why locize is the Perfect TMS to Choose Throughout this journey, we have delved into the significance of i18next as a mature and extensible internationalization framework, and the emergence of locize as a unique translation management solution tailored to complement i18next. Now, let&#39;s reinforce why locize stands as the perfect TMS for i18next-powered projects: Deep Integration with i18next Principles:As the official sponsor of i18next, locize's creators have ensured seamless integration with the framework, offering a unified and optimized experience for managing translations. Unique Features and Differentiators:locize goes beyond traditional TMS offerings with features like strong versioning, freedom from service lock-in, support for multiple namespaces/files, and proper pluralization. These unique capabilities set locize apart and enhance the i18next localization workflow. Exceptional Support from i18next Creators:The team behind locize shares the expertise of i18next's creators, providing unrivaled support and guidance in internationalization and localization tasks. Compatibility and Flexibility:locize is designed to be compatible with i18next and allows for customization to adapt to unique project requirements and workflows. Seamless Collaboration:With its collaboration-friendly features, locize streamlines communication between developers and localization teams, enhancing the efficiency of the translation process. Integration with Third-Party Translation Services:locize's integration with third-party translation services expands its capabilities, providing access to additional features and supporting various translation workflows. Efficient Translation Workflow:locize's focus on versioning, collaboration, and change tracking ensures a smooth and efficient translation workflow for i18next-powered projects. Choosing the right TMS is paramount to the success of your localization efforts, and locize emerges as the perfect choice to meet the specific needs of i18next projects. Its compatibility, unique features, and exceptional support make it an invaluable tool in the globalized digital landscape. As you embark on your internationalization journey with i18next, let locize be your steadfast companion in managing translations efficiently and effectively. Embrace the power of this dynamic duo, and watch your projects flourish on the global stage. Try locize today and see the difference it can make for your business. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is i18next, and how does it differ from other internationalization libraries?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is a powerful internationalization framework that enables developers to add multilingual support to web and mobile applications. Unlike other libraries, i18next is highly extensible, compatible with various UI frameworks and i18n formats, making it a versatile choice for internationalization tasks.\" } }, { \"@type\": \"Question\", \"name\": \"How does locize integrate with i18next, and what advantages does it offer?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"locize is the official sponsor of i18next and is designed to align closely with i18next principles. It seamlessly integrates with i18next, offering unique features such as strong versioning, freedom from service lock-in, support for multiple namespaces/files, and proper pluralization. The advantage of locize lies in its deep understanding of i18next and exceptional support from the i18next creators.\" } }, { \"@type\": \"Question\", \"name\": \"Can I export translations from locize and use them with other localization frameworks?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, locize believes in giving users the freedom to choose. While it offers exceptional value as a TMS, it does not lock users into its platform. You can export translations from locize and use them with i18next or other preferred localization frameworks, providing full control over your translation data and enhancing flexibility in your localization workflow.\" } }, { \"@type\": \"Question\", \"name\": \"Does locize support collaboration between developers and translation teams?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, locize provides features that streamline communication and collaboration between developers and translation teams. With versioning support, collaboration-friendly tools, and integration with third-party translation services, locize ensures a smooth and efficient translation workflow, promoting effective teamwork and timely localization.\" } }, { \"@type\": \"Question\", \"name\": \"How does locize handle pluralization rules in different languages?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"locize understands the complexities of pluralization rules in various languages. It correctly calculates progress in multiple languages based on distinct pluralization rules, ensuring that translations are accurate and contextually appropriate, regardless of the language being translated. This feature enhances the precision and quality of translated content in diverse linguistic contexts.\" } }] }","raw":"---\ntitle: \"How to Choose the Best fitting Translation Management System\"\ndescription: \"This blog post explores the unique capabilities of locize, a comprehensive translation management tool closely integrated with i18next, making it the perfect choice to streamline localization workflows and meet the specific needs of i18next-powered projects.\"\n\ndate: 2023-08-02\ntags:\n  - localization\n  - internationalization\n  - tech lead\n  - engineering manager\n  - l10n\n  - i18n\n  - translation management\n  - tms\n  - locize\n  - how to choose\nthumbnail: how-to-choose-the-right-translation-management-system/title.jpg\n---\n\n![](title.jpg)\n\nMultilingual support has become a necessity for web and application development. Enter i18next, a powerful [internationalization](../what-is-i18n/) framework that has redefined language translations for developers since its inception in 2011. As we venture into the realm of i18next and its ideal companion, we explore a seamless integration that empowers projects to flourish on the global stage.\n\n## TOC\n  * [I. Introduction](#introduction)\n    - [A. The Significance of i18next as an Extensible Internationalization Framework](#i18next-significance)\n    - [B. Introducing a Comprehensive Translation Management Tool](#comprehensive-tms)\n    - [C. The Purpose of this Blog Post](#purpose)\n  * [II. Understanding i18next and the Need for an Effective TMS](#i18next-tms)\n    - [A. The Background and History of i18next](#i18next-history)\n    - [B. The Maturity and Extensibility of i18next](#i18next-maturity)\n    - [C. The Richness of i18next's Features](#i18next-features)\n  * [III. Practical Tips for Evaluating and Selecting a TMS with i18next](#tips)\n    - [A. Research and Evaluation](#research-evaluation)\n    - [B. Trial and Testing](#trial-testing)\n    - [C. Collaboration and Feedback](#collaboration-feedback)\n    - [D. Support and Documentation](#support-documentation)\n    - [E. Pricing and Scalability](#pricing-scalability)\n    - [F. Integration with Developer Tools](#integration)\n  * [IV. Key Considerations for Choosing a TMS with i18next](#tms-considerations)\n    - [A. Compatibility and Integration](#compatibility-integration)\n    - [B. Translation Workflow and Collaboration Features](#translation-workflow)\n    - [C. Support for Localization File Formats](#file-formats)\n    - [D. Customization and Flexibility](#customization-flexibility)\n  * [V. Introducing locize: A Unique Translation Management Solution](#locize-solution)\n    - [A. The Close Alignment with i18next Principles](#alignment-with-i18next)\n    - [B. Unique Features Setting locize Apart](#unique-features)\n    - [C. locize: The Perfect TMS for i18next-Powered Projects](#locize-perfect-i18next)\n  * [VI. Conclusion: Why locize is the Perfect TMS to Choose](#locize-perfect-tms)\n\n\n## I. Introduction <a name=\"introduction\"></a>\n\n### A. The Significance of i18next as an Extensible Internationalization Framework <a name=\"i18next-significance\"></a>\n\nIn the ever-expanding landscape of web and application development, catering to a global audience is no longer a choice but a necessity. Websites and software products must accommodate users from diverse linguistic backgrounds, making internationalization a crucial aspect of modern development practices. At the forefront of this domain stands [i18next](https://www.i18next.com), a well-established and highly extensible internationalization framework.\n\nSince its inception in late 2011, i18next has grown into one of the most favored open-source solutions for enabling multilingual support in web and mobile applications. Its widespread adoption can be attributed to its maturity, versatility, and continuous evolution to meet the changing needs of the localization community. From handling simple key-value translations to supporting complex pluralization and language detection, i18next has proven itself as a reliable and powerful tool.\n\n\n### B. Introducing a Comprehensive Translation Management Tool <a name=\"comprehensive-tms\"></a>\n\nAs i18next's popularity surged, developers encountered a new challenge - managing translations effectively across projects and keeping up with a growing user base. The demand for a seamless translation management solution became evident, leading to the birth of a new service, a comprehensive [translation management system (TMS)](../tms/) and the [official sponsor](/i18next.html#official-sponsor) of i18next.\n\nWhat sets it apart from other TMS offerings is its deep integration with i18next, designed to cater to the specific needs of i18next-powered projects. Instead of being just another localization-as-a-service offering, it goes above and beyond to provide a robust ecosystem for internationalization. The creators of i18next, being the founders of a TMS, brought their expertise and experience to ensure that it seamlessly complements the i18next framework.\n\n\n### C. The Purpose of this Blog Post <a name=\"purpose\"></a>\n\nIn this blog post, we embark on a journey to explore the capabilities of a TMS and its integration with i18next, with a focus on how the system designed by the i18next founders stands out in particular as the perfect TMS for managing translations in i18next projects. We will delve into the unique features that set it apart from alternatives, understanding its role as an essential component in the localization workflow.\n\nThroughout this article, we will provide insights and practical tips for developers and localization teams looking to select the right TMS with seamless i18next integration. By the end, readers will have a clear understanding of several advantages, empowering them to make informed decisions when choosing a translation management system that optimizes their i18next-powered localization workflow.\n\nJoin us as we unravel the strengths of i18next and the capabilities of a good translation management system, offering a powerful combination for efficient and effective [software localization](../what-is-software-localization/) in the globalized digital landscape.\n\n\n## II. Understanding i18next and the Need for an Effective TMS <a name=\"i18next-tms\"></a>\n\n### A. The Background and History of i18next <a name=\"i18next-history\"></a>\n\nTo comprehend the importance of an effective translation management system, it's essential to grasp the foundation on which it is built - i18next. [Born in 2011](https://www.i18next.com/misc/the-history-of-i18next), i18next emerged as a solution to a critical challenge faced by developers - finding an internationalization library that could seamlessly run on both server-side and client-side single-page applications.\n\nFrom its humble beginnings, i18next quickly gained momentum, becoming one of the [most widely used](https://npmtrends.com/i18next) frameworks for translating web and mobile applications. Its success was fueled by an extraordinary response from the community, which led to the establishment of a fast-growing [ecosystem](https://www.i18next.com/overview/supported-frameworks) [around i18next](https://www.i18next.com/overview/plugins-and-utils).\n\n[![](npmtrends.jpg)](https://npmtrends.com/i18next)\n\nV2 of i18next, released in 2015, marked a significant milestone. With this release, i18next was completely rebuilt to be highly extensible, ensuring smooth compatibility with previous versions. As a result, developers could effortlessly adopt newer releases without disrupting existing codebases. The robustness of the i18next API, which is still actively tested and supported, solidified its reputation as a dependable choice for internationalization.\n\nAnd nowadays, i18next also offers [type safety for your translations](../i18next-typescript/). Whenever a developer employs a non-existent or modified i18n key, the [TypeScript](../i18next-typescript/) compiler immediately raises an error, promptly alerting you to the issue before it gives rise to runtime complications.\n\n\n### B. The Maturity and Extensibility of i18next <a name=\"i18next-maturity\"></a>\n\nHaving withstood the test of time, i18next has garnered a reputation for being a mature and reliable framework. Its longevity in the open-source community is a testament to its adaptability, with no i18n case deemed unsolvable by i18next. From small projects to enterprise-grade applications, developers have found i18next to be an indispensable tool for multilingual support.\n\nThe extensibility of i18next is another compelling aspect. This framework can be integrated into any JavaScript environment, making it compatible with various [UI frameworks](https://www.i18next.com/overview/supported-frameworks), [i18n formats](https://www.i18next.com/overview/plugins-and-utils#i18n-formats), and even non-JavaScript platforms such as .NET, Elm, iOS, Android, Ruby, and more. The versatility and flexibility of i18next allow developers to tailor the internationalization process to fit specific project requirements and workflows, catering to the diverse needs of different teams and applications.\n\n\n### C. The Richness of i18next's Features <a name=\"i18next-features\"></a>\n\nBeyond its core capabilities, i18next stands out for its rich feature set, which surpasses many traditional i18n frameworks. From basic [interpolation](https://www.i18next.com/translation-function/interpolation) and [formatting](https://www.i18next.com/translation-function/formatting) to advanced functionalities such as translations from [multiple sources](https://www.i18next.com/how-to/backend-fallback), [language detection](https://www.i18next.com/overview/plugins-and-utils#language-detector), [plural form resolutions](https://www.i18next.com/translation-function/plurals), and [caching](https://www.i18next.com/how-to/caching), i18next provides a comprehensive suite of tools for developers to handle multilingual complexities effortlessly.\n\nThe heart of i18next's success lies not just in its technical proficiency but also in the vibrant community that surrounds it. Users actively contribute feedback and improvements, enriching the ecosystem with valuable insights. As a result, i18next continues to evolve and adapt, remaining at the forefront of internationalization and setting the stage for a seamless integration with a translation management system.\n\n![](i18next_ecosystem.webp)\n\nWith a solid understanding of i18next's significance and features, we can now delve deeper into the area of translation management systems and which TMS is the perfect one to complement the power of i18next.\n\n\n## III. Key Considerations for Choosing a TMS with i18next <a name=\"tms-considerations\"></a>\n\nWhen it comes to selecting a [translation management system (TMS)](../tms/) that seamlessly integrates with i18next, several key considerations are crucial to ensure a smooth and efficient localization workflow. Let's explore these essential factors to help you make an informed decision:\n\n\n### A. Compatibility and Integration <a name=\"compatibility-integration\"></a>\n\nThe first and foremost consideration is ensuring compatibility and seamless integration with i18next. A TMS, built with a focus on i18next, should effortlessly fit into your existing i18next-powered projects without major disruptions. Look for features that allow you to link your i18next translations directly to the TMS, ensuring consistent synchronization between your codebase and localization files.\n\n\n### B. Translation Workflow and Collaboration Features <a name=\"translation-workflow\"></a>\n\nAn effective TMS should simplify your translation workflow and facilitate seamless collaboration between developers, translators, and localization managers. Features like versioning, translation tagging, collaboration, and change tracking are vital to maintain a smooth and efficient localization process. With strong versioning support and integration with third-party translation services, you gain the tools to streamline the translation workflow and optimize collaboration.\n\n\n### C. Support for Localization File Formats <a name=\"file-formats\"></a>\n\nEnsure that the TMS supports the localization file formats used by i18next. As i18next is compatible with various file formats, such as JSON, YAML, PO, and more, the TMS should seamlessly handle these formats to import and export translations effortlessly. A good TMS is designed with this compatibility in mind, ensuring that i18next developers can continue working with their preferred file formats.\n\n\n### D. Customization and Flexibility <a name=\"customization-flexibility\"></a>\n\nEvery project has unique requirements and workflows. A flexible TMS should offer customizable settings to adapt to your specific needs. This includes the ability to configure language settings, custom translation workflows, and permissions for team members. By providing customization options, a TMS empowers you to tailor the localization process to suit your project's exact requirements.\n\nBy carefully considering these key factors, you can confidently select a TMS that aligns with i18next principles and enhances your localization workflow. Now, let's move on to the practical tips for evaluating and selecting the ideal TMS with seamless i18next integration.\n\n\n## IV. Practical Tips for Evaluating and Selecting a TMS with i18next <a name=\"tips\"></a>\n\nNow that we have explored the key considerations for choosing a TMS that seamlessly integrates with i18next, let's dive into practical tips to help you evaluate and select the ideal TMS for your localization needs:\n\n\n### A. Research and Evaluation <a name=\"research-evaluation\"></a>\n\nStart by conducting thorough research on various TMS options available in the market. Look for TMS solutions that specifically highlight their compatibility with i18next and offer features tailored to support its unique requirements. Read [user reviews and testimonials](https://www.i18next.com/misc/testimonials) to gain insights into the experiences of other developers and localization teams.\n\n\n### B. Trial and Testing <a name=\"trial-testing\"></a>\n\nMany TMS providers offer free trials or demo versions. Take advantage of these opportunities to test the TMS with your existing i18next projects. This hands-on experience will allow you to assess how well the TMS integrates with i18next and how user-friendly it is for your team.\n\n\n### C. Collaboration and Feedback <a name=\"collaboration-feedback\"></a>\n\nEngage in conversations with your development team and localization managers. Gather their feedback and consider their input when evaluating TMS options. Understanding their specific pain points and requirements will help you make an informed decision that aligns with your team's preferences and workflow.\n\n\n### D. Support and Documentation <a name=\"support-documentation\"></a>\n\nReliable customer support is crucial when dealing with complex internationalization and localization tasks. Look for TMS providers that offer responsive customer support and comprehensive documentation - not only for the TMS itself, but also for i18next. Having readily available resources and assistance will ensure that your team can resolve any issues quickly and efficiently.\n\n\n### E. Pricing and Scalability <a name=\"pricing-scalability\"></a>\n\nCarefully evaluate the pricing models offered by different TMS providers. Consider the scalability of the TMS and how it aligns with your project's growth potential. Look for transparent pricing structures that suit your project's needs without hidden costs. Ask yourself: \"Do I pay too much just by scratching the border of the next bigger plan? Or does the costs scale with the project growth?\"\n\n\n### F. Integration with Developer Tools <a name=\"integration\"></a>\n\nEfficiency is vital in any development process. Check if the TMS integrates smoothly with other tools and platforms that your development team already uses. Seamless integration with code repositories, build systems, and deployment platforms will enhance your team's productivity.\n\nBy following these practical tips, you can confidently assess and select a TMS, that ensures smooth integration with i18next and streamlines your localization workflow.\n\n\n## V. Introducing [locize](/): A Unique Translation Management Solution <a name=\"locize-solution\"></a>\n\n### A. The Close Alignment with i18next Principles <a name=\"alignment-with-i18next\"></a>\n\nAs the [official sponsor](/i18next.html#official-sponsor) of i18next, [locize](/) is more than just another translation management system; it is a TMS designed to harmonize with the core principles and philosophy of i18next. Developed by the same creators as i18next, locize benefits from a deep understanding of the needs and challenges faced by developers and localization teams.\n\nThis close alignment ensures that locize seamlessly integrates with i18next, offering a unified and optimized experience for managing translations. By leveraging [i18next's extensible architecture](/i18next.html#how-does-i18next-work), locize empowers users to leverage the full potential of the framework while providing additional tools and features that go beyond traditional translation management.\n\n[![](i18next_how_it_works.png)](/i18next.html#how-does-i18next-work)\n\n\n### B. Unique Features Setting locize Apart <a name=\"unique-features\"></a>\n\n#### 1. Strong Support for Versioning and Software Development Process\n\nOne of locize's standout features is its robust support for [versioning](https://docs.locize.com/more/versioning), a critical aspect of software development. Proper versioning ensures that changes to translations are managed efficiently, facilitating collaboration among developers and localization teams. With locize, users can confidently make updates and track progress without the fear of losing previous translations or creating confusion.\n\n#### 2. Freedom from Service Lock-In\n\nUnlike some other translation management services, locize believes in giving users the freedom to choose. While locize offers exceptional value as a TMS, it does not lock users into its platform. Instead, users can export their translations and use them with i18next or other preferred localization frameworks. This approach empowers users with full control over their translation data and enhances the flexibility of their localization workflow.\n\n#### 3. Exceptional Support from i18next Creators\n\nThe backing of the i18next creators ensures that locize users receive unparalleled support and expertise in internationalization and localization. The team behind locize is intimately familiar with the intricacies of i18next, providing developers with valuable guidance and assistance in optimizing their localization workflow.\n\n#### 4. Support for Multiple Namespace/Files and Proper Pluralization\n\nlocize goes beyond standard translation management offerings by providing support for multiple [namespaces](https://docs.locize.com/more/namespaces) or files within a project. This allows developers to organize translations efficiently, ensuring clarity and simplicity in the localization process.\n\nAdditionally, locize understands the complexities of [pluralization rules](https://docs.locize.com/more/general-questions/why-do-i-see-strange-new-keys-marked-as-one-few-many-others) in different languages. By correctly calculating progress in various languages based on distinct pluralization rules, locize ensures that translations are accurate and contextually appropriate, regardless of the language being translated.\n\n#### 5. Integration with Third-Party Translation Services\n\nTo cater to diverse user needs, locize offers integration with third-party [translation services](/services.html#translationservices). This feature allows users to leverage additional capabilities provided by these services, such as project finalization, the option to work with preferred translators, approvals, and direct contact with translators. The integration with third-party services streamlines the translation process and allows users to [collaborate effectively with translation professionals](https://docs.locize.com/guides-tips-and-tricks/working-with-translators).\n\n#### 6. Freedom to choose how to serve your translations\n\nWhile you get most comfort out of using the locize [CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network), your environment might demand you to bundle the translations with your product (eg. offline usage in areas with restricted internet access or with [offline fallback](https://docs.locize.com/more/backend-fallback)).\n\nUsing the CDN has three big advantages:\n- You can deploy updates to translations without the need to redeploy/rollout a new version of your application.\n- During development, testing you can set your versions to auto publishing. Doing so your translation changes are reflected immediately in your application and results in a lot easier development process.\n- You can easily set a version to publish in private mode, which means you will need an API key to download your translations. This enables you for example to use locize as before but without leaking any information to the public.\n\nIf your product demands to download the translations, because you need or prefer to host or bundle them yourself you can do so. Using our CDN is completely optional and get only billed if you’re using it.\nYou can download/export the translations using the [API](https://docs.locize.com/integration/api) or the locize UI or the [CLI](https://github.com/locize/locize-cli), also in various [formats](https://docs.locize.com/integration/supported-formats).\n\n\n### C. locize: The Perfect TMS for i18next-Powered Projects <a name=\"locize-perfect-i18next\"></a>\n\nWith its deep integration with i18next, locize emerges as the perfect translation management system for developers and localization teams working with i18next-powered projects. Its unique features, built on a foundation of understanding and commitment to i18next principles, make it a standout choice in the realm of translation management.\n\nIn the next section, we will explore key considerations for selecting a TMS with a focus on seamless i18next integration, ensuring that your localization workflow remains efficient, accurate, and hassle-free.\n\n\n## VI. Conclusion: Why locize is the Perfect TMS to Choose <a name=\"locize-perfect-tms\"></a>\n\nThroughout this journey, we have delved into the significance of i18next as a mature and extensible internationalization framework, and the emergence of locize as a unique translation management solution tailored to complement i18next. Now, let's reinforce why locize stands as the perfect TMS for i18next-powered projects:\n\n\n<ol>\n  <li>\n    <b>Deep Integration with i18next Principles:</b><br/>As the <a href=\"/i18next.html#official-sponsor\">official sponsor</a> of i18next, locize's creators have ensured seamless integration with the framework, offering a unified and optimized experience for managing translations.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Unique Features and Differentiators:</b><br/>locize goes beyond traditional TMS offerings with features like strong <a href=\"https://docs.locize.com/more/versioning\" target=\"_blank\">versioning</a>, freedom from service lock-in, support for multiple <a href=\"https://docs.locize.com/more/namespaces\" target=\"_blank\">namespaces/files</a>, and proper <a href=\"https://docs.locize.com/more/general-questions/why-do-i-see-strange-new-keys-marked-as-one-few-many-others\" target=\"_blank\">pluralization</a>. These unique capabilities set locize apart and enhance the i18next localization workflow.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Exceptional Support from i18next Creators:</b><br/>The team behind locize shares the expertise of i18next's creators, providing unrivaled support and guidance in internationalization and localization tasks.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Compatibility and Flexibility:</b><br/>locize is designed to be compatible with i18next and allows for customization to adapt to unique project requirements and workflows.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Seamless Collaboration:</b><br/>With its collaboration-friendly features, locize streamlines communication between developers and localization <a href=\"/for-your-team.html\">teams</a>, enhancing the efficiency of the translation process.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Integration with Third-Party Translation Services:</b><br/>locize's integration with third-party <a href=\"/services.html#translationservices\">translation services</a> expands its capabilities, providing access to additional features and supporting various translation workflows.\n    <br/>\n    <br/>\n  </li>\n  <li>\n    <b>Efficient Translation Workflow:</b><br/>locize's focus on <a href=\"https://docs.locize.com/more/versioning\" target=\"_blank\">versioning</a>, <a href=\"https://docs.locize.com/guides-tips-and-tricks/working-with-translators\" target=\"_blank\">collaboration</a>, and <a href=\"https://docs.locize.com/whats-inside/history\">change tracking</a> ensures a smooth and efficient translation workflow for i18next-powered projects.\n    <br/>\n    <br/>\n  </li>\n</ol>\n\n\nChoosing the right TMS is paramount to the success of your localization efforts, and locize emerges as the perfect choice to meet the specific needs of i18next projects. Its compatibility, unique features, and exceptional support make it an invaluable tool in the globalized digital landscape.\n\nAs you embark on your internationalization journey with i18next, let [locize](/) be your steadfast companion in managing translations efficiently and effectively. Embrace the power of this dynamic duo, and watch your projects flourish on the global stage.\n\nTry [locize](https://www.locize.app/register) today and see the difference it can make for your business.\n\n{% youtube ds-yEEYP1Ks %}\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next, and how does it differ from other internationalization libraries?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is a powerful internationalization framework that enables developers to add multilingual support to web and mobile applications. Unlike other libraries, i18next is highly extensible, compatible with various UI frameworks and i18n formats, making it a versatile choice for internationalization tasks.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How does locize integrate with i18next, and what advantages does it offer?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"locize is the official sponsor of i18next and is designed to align closely with i18next principles. It seamlessly integrates with i18next, offering unique features such as strong versioning, freedom from service lock-in, support for multiple namespaces/files, and proper pluralization. The advantage of locize lies in its deep understanding of i18next and exceptional support from the i18next creators.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Can I export translations from locize and use them with other localization frameworks?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, locize believes in giving users the freedom to choose. While it offers exceptional value as a TMS, it does not lock users into its platform. You can export translations from locize and use them with i18next or other preferred localization frameworks, providing full control over your translation data and enhancing flexibility in your localization workflow.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Does locize support collaboration between developers and translation teams?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, locize provides features that streamline communication and collaboration between developers and translation teams. With versioning support, collaboration-friendly tools, and integration with third-party translation services, locize ensures a smooth and efficient translation workflow, promoting effective teamwork and timely localization.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How does locize handle pluralization rules in different languages?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"locize understands the complexities of pluralization rules in various languages. It correctly calculates progress in multiple languages based on distinct pluralization rules, ensuring that translations are accurate and contextually appropriate, regardless of the language being translated. This feature enhances the precision and quality of translated content in diverse linguistic contexts.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"tech lead","slug":"tech-lead","permalink":"https://locize.com/blog/tags/tech-lead/"},{"name":"engineering manager","slug":"engineering-manager","permalink":"https://locize.com/blog/tags/engineering-manager/"},{"name":"translation management","slug":"translation-management","permalink":"https://locize.com/blog/tags/translation-management/"},{"name":"tms","slug":"tms","permalink":"https://locize.com/blog/tags/tms/"},{"name":"how to choose","slug":"how-to-choose","permalink":"https://locize.com/blog/tags/how-to-choose/"}]},{"title":"Supercharge Your TypeScript App: Mastering i18next for Type-Safe Translations","slug":"i18next-typescript","date":"un44fin44","updated":"un11fin11","comments":true,"path":"i18next-typescript/","link":"","permalink":"https://locize.com/blog/i18next-typescript/","excerpt":"","text":"As our world becomes increasingly interconnected, the development of web applications that cater to a global audience takes precedence among developers. If you&#39;re a TypeScript developer, you&#39;re likely acquainted with the advantages of static typing and the assurance it provides in your codebase. When it comes to internationalization (i18n) and localization (l10n), maintaining the same level of type safety becomes crucial. This is precisely where i18next, an influential i18n framework, enters the picture. In the past, i18next already furnished TypeScript definitions for its API, enabling developers to benefit from type checking while utilizing the library. However, a significant limitation persisted, specifically the absence of type safety for translation keys. Consequently, if a translation resource was missing or underwent a name change, the TypeScript compiler failed to detect it, resulting in potential errors during runtime. Nevertheless, with the advent of the new iterations of i18next, that limitation has been overcome (thanks largely to Pedro Durek). Now, i18n keys boast complete type safety. Whenever a developer employs a non-existent or modified i18n key, the TypeScript compiler immediately raises an error, promptly alerting you to the issue before it gives rise to runtime complications. In addition, there is also an improved intellisense experience. Within this guide, we will delve into the art of leveraging the latest version of i18next to attain translations that are impervious to type-related errors in your TypeScript applications. We will encompass everything from the fundamentals of i18next setup to advanced techniques. All the while, you will benefit from the added safety net of type checking for your translation keys. By the conclusion of this guide, you will possess a profound comprehension of how to harness the force of i18next&#39;s type-safe translations within your TypeScript projects. You will be equipped to ensure that your translations are not only precise and adaptable but also consistently error-free, courtesy of the seamless integration between i18next and TypeScript. Let us embark on this journey together and furnish you with the knowledge and tools necessary to create localized applications that effortlessly cater to diverse language preferences while maintaining the robustness of your codebase. In-Memory translations For a simple i18next setup, you probably have something like this: 123456789101112131415161718192021import i18next from &#x27;i18next&#x27;;import enNs1 from &#x27;./locales/en/ns1.json&#x27;;import enNs2 from &#x27;./locales/en/ns2.json&#x27;;import deNs1 from &#x27;./locales/de/ns1.json&#x27;;import deNs2 from &#x27;./locales/de/ns2.json&#x27;;i18next.init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, defaultNS: &#x27;ns1&#x27;, resources: &#123; en: &#123; ns1: enNs1, ns2: enNs2, &#125;, de: &#123; ns1: deNs1, ns2: deNs2, &#125;, &#125;,&#125;); You import the translation resources and you&#39;re adding them via i18next init function. To make the translation type-safe, we create an i18next.d.ts file preferably in a @types folder and we import the translation resources of our reference language: 123456789101112import enNs1 from &#x27;../locales/en/ns1.json&#x27;;import enNs2 from &#x27;../locales/en/ns2.json&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; defaultNS: &#x27;ns1&#x27;; resources: &#123; ns1: typeof enNs1; ns2: typeof enNs2; &#125;; &#125;&#125; That's already great! But: We Can Do Better! 😜 With the help of i18next-resources-for-ts we can generate a single resource file that we can use. So install i18next-resources-for-ts and execute the toc command, i.e. something like: i18next-resources-for-ts toc -i ./locales/en -o ./@types/resources.ts So we can modify the i18next.d.ts file like this: 12345678import resources from &#x27;./resources&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; defaultNS: &#x27;ns1&#x27;; resources: typeof resources; &#125;&#125; 🧑‍💻 A complete code example can be found here. Plurals btw: also plural keys works: Fallback Namespace And also fallback namespace handling works: 12345678910// @types/i18next.d.tsimport resources from &#x27;./resources&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; defaultNS: &#x27;ns1&#x27;; fallbackNS: &#x27;fallback&#x27;; resources: typeof resources; &#125;&#125; 12// works because of fallbackNSi18next.t(&#x27;fallbackKey&#x27;) Interpolation Unfortunately, automatic interpolation inference won&#39;t work if your translations are placed in JSON files, only in TS files using as const keyword or an interface in a d.ts file, as long as this TypeScript issue is not addressed. Interface To address this, let&#39;s make use of the interface command, i.e. something like: i18next-resources-for-ts interface -i ./locales/en -o ./@types/resources.d.ts This way we can change the i18next.d.ts file like this: 12345678import Resources from &#x27;./resources&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; defaultNS: &#x27;ns1&#x27;; resources: Resources; &#125;&#125; Now the interpolation inference works and fails if the passed variable name does not match: 🧑‍💻 A complete code example can be found here. React.js A React.js based i18next setup with in-memory translation resources could also look very similar to the above example, so let&#39;s raise the bar a little bit and see what a setup with lazy loading translations like with i18next-http-backend looks like: 1234567891011121314151617import i18next from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import HttpApi from &#x27;i18next-http-backend&#x27;;i18next .use(initReactI18next) .use(HttpApi) .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, defaultNS: &#x27;ns1&#x27;, backend: &#123; loadPath: &#x27;/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27; &#125; &#125;);export default i18next; To make the translation type-safe, we again create an i18next.d.ts file preferably in a @types folder like this: 12345678import Resources from &#x27;./resources&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; defaultNS: &#x27;ns1&#x27;; resources: Resources; &#125;&#125; And again we make use of the interface command, i.e. something like: i18next-resources-for-ts interface -i ./public/locales/en -o ./src/@types/resources.d.ts This way, the translations are loaded at runtime, but the translations are type-checked during development. With the new react-i18next version, when loading multiple namespaces, t function will infer and accept the keys for the first namespace. So this pattern is now accepted: 123456789101112131415import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;;function Comp2() &#123; const &#123;t&#125; = useTranslation([&#x27;ns1&#x27;, &#x27;ns2&#x27;]); return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;t(&#x27;description.part1&#x27;)&#125;&lt;/p&gt; &lt;p&gt;&#123;t(&#x27;description.part1&#x27;, &#123; ns: &#x27;ns1&#x27; &#125;)&#125;&lt;/p&gt; &lt;p&gt;&#123;t(&#x27;description.part2&#x27;, &#123; ns: &#x27;ns2&#x27; &#125;)&#125;&lt;/p&gt; &lt;/div&gt; );&#125;export default Comp2; Trans component And also the Trans component is type-safe: 12345678910111213141516171819import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;function Comp1() &#123; const &#123;t&#125; = useTranslation(); return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;title&quot;&gt; Welcome to react using &lt;code&gt;react-i18next&lt;/code&gt; fully type-safe &lt;/Trans&gt; &lt;/p&gt; &lt;p&gt;&#123;t(&#x27;description.part1&#x27;)&#125;&lt;/p&gt; &lt;p&gt;&#123;t(&#x27;description.part2&#x27;)&#125;&lt;/p&gt; &lt;/div&gt; );&#125;export default Comp1; 🧑‍💻 A complete code example can be found here. No app-bundled/provided translations There is also a way to keep the translations completely separate from your code repository while maintaining type safety. Let&#39;s take the React.js project used in this awesome guide... The final i18next setup in this example looks like this: 123456789101112131415161718192021222324252627282930313233343536373839404142import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const isProduction = process.env.NODE_ENV === &#x27;production&#x27;;const locizeOptions = &#123; projectId: process.env.REACT_APP_LOCIZE_PROJECTID as string, apiKey: process.env.REACT_APP_LOCIZE_APIKEY as string, referenceLng: process.env.REACT_APP_LOCIZE_REFLNG as string, version: process.env.REACT_APP_LOCIZE_VERSION as string&#125;;if (!isProduction) &#123; i18n.use(LastUsed);&#125;i18n .use(locizePlugin) .use(Backend) .use(LanguageDetector) .use(initReactI18next) .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: !isProduction &#125;);i18n.services.formatter?.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng as string).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; So at runtime we load the translation directly from the locize CDN. So how do we get type-safe translations during development? We create some npm scripts to help us: Download the published translations (in reference language) to a temporary directory, i.e.: downloadEn: locize download --project-id=0bbc223a-9aba-4a90-ab93-ab9d7bf7f780 --language=en --ver=latest --clean=true --path=./src/@types/locales Create the appropriate interface definition file, i.e.: interface: i18next-resources-for-ts interface -i ./src/@types/locales -o ./src/@types/resources.d.ts Final script: download, create interface and delete the temporary files, i.e.: update-interface: npm run downloadEn &amp;&amp; npm run interface &amp;&amp; rm -rf ./src/@types/locales Like in the previous example, we now can just import that interface in our i18next.d.ts file: 1234567import Resources from &#x27;./resources&#x27;;declare module &#x27;i18next&#x27; &#123; interface CustomTypeOptions &#123; resources: Resources; &#125;&#125; That&#39;s it! The translations are separated from our code repository and at the same time we maintain type safety with the help of an interface. 🧑‍💻 A complete code example can be found here. There&#39;s also a video about this topic. 🎉🥳 Congratulations 🎊🎁 In conclusion, mastering i18next for type-safe translations empowers TypeScript developers to unlock the full potential of their applications. By ensuring accurate localization, eliminating runtime errors, and leveraging the seamless integration between i18next and TypeScript, developers can create robust, localized applications that cater to diverse language preferences. With the knowledge and tools provided in this guide, you are equipped to supercharge your TypeScript app and deliver exceptional user experiences on a global scale. Happy coding! So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍 { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"Can I use i18next for type-safe translations in JavaScript projects?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"While i18next itself is primarily designed for JavaScript projects, the concept of type-safe translations is most beneficial when using TypeScript. TypeScript provides static type checking, which helps catch errors and provides enhanced developer experience when working with i18next.\" } },{ \"@type\": \"Question\", \"name\": \"How does type safety improve the localization process?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Type safety ensures that translation keys are validated during development, preventing potential runtime errors. It allows developers to catch missing or modified translation keys early, improving the overall quality and reliability of localized applications.\" } },{ \"@type\": \"Question\", \"name\": \"Can I still use i18next with type safety if my project has dynamic translations?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, you can still achieve type safety with dynamic translations. By using techniques like generating resource files or defining interfaces for your translations, you can maintain type safety even with dynamically loaded translation content.\" } },{ \"@type\": \"Question\", \"name\": \"Are there any performance implications when using type-safe translations with i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Type-safe translations themselves do not significantly impact runtime performance. The primary focus is on enhancing developer productivity, reducing errors, and improving code quality. The performance of the application largely depends on how i18next is implemented and the size of translation resources.\" } },{ \"@type\": \"Question\", \"name\": \"Are there any limitations or trade-offs when using type-safe translations with i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"While type-safe translations provide numerous benefits, there are a few limitations to consider. For example, automatic interpolation inference may not work with translations placed in JSON files. Additionally, if your translations are separated from your code repository, you need to ensure synchronization between translation updates and your codebase.\" } }] }","raw":"---\ntitle: \"Supercharge Your TypeScript App: Mastering i18next for Type-Safe Translations\"\ndescription: Discover how to unleash the full potential of i18next in your TypeScript applications by mastering type-safe translations, ensuring accurate localization and eliminating runtime errors, with this guide. ✅\n\ndate: 2023-06-22\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - typescript\n  - types\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: i18next-typescript/title.jpg\n\nlabel: i18next-typescript\nlang: en\n---\n\n![TypeScript Localization made easy with this step-by-step guide using i18next ✅](title.jpg \"TypeScript Localization example\")\n\nAs our world becomes increasingly interconnected, the development of web applications that cater to a [global audience](../grow-online-business/) takes precedence among developers. If you're a TypeScript developer, you're likely acquainted with the advantages of static typing and the assurance it provides in your codebase. When it comes to internationalization ([i18n](../what-is-i18n/)) and localization ([l10n](../what-is-software-localization/)), maintaining the same level of type safety becomes crucial. This is precisely where [i18next](https://www.i18next.com), an influential i18n framework, enters the picture.\n\nIn the past, i18next already furnished TypeScript definitions for its API, enabling developers to benefit from type checking while utilizing the library. However, a significant limitation persisted, specifically the absence of type safety for translation keys. Consequently, if a translation resource was missing or underwent a name change, the TypeScript compiler failed to detect it, resulting in potential errors during runtime.\n\n![](ts_api.jpg)\n\nNevertheless, with the advent of the new iterations of i18next, that limitation has been overcome *(thanks largely to [Pedro Durek](https://github.com/pedrodurek))*. Now, i18n keys boast complete type safety. Whenever a developer employs a non-existent or modified i18n key, the TypeScript compiler immediately raises an error, promptly alerting you to the issue before it gives rise to runtime complications. In addition, there is also an improved intellisense experience.\n\nWithin this guide, we will delve into the art of leveraging the latest version of i18next to attain translations that are impervious to type-related errors in your TypeScript applications. We will encompass everything from the fundamentals of i18next setup to advanced techniques. All the while, you will benefit from the added safety net of type checking for your translation keys.\n\nBy the conclusion of this guide, you will possess a profound comprehension of how to harness the force of i18next's type-safe translations within your TypeScript projects. You will be equipped to ensure that your translations are not only precise and adaptable but also consistently error-free, courtesy of the seamless integration between i18next and TypeScript. Let us embark on this journey together and furnish you with the knowledge and tools necessary to create localized applications that effortlessly cater to diverse language preferences while maintaining the robustness of your codebase.\n\n\n## In-Memory translations <a name=\"in-memory-translations\"></a>\n\nFor a simple i18next setup, you probably have something like this:\n\n```ts\nimport i18next from 'i18next';\nimport enNs1 from './locales/en/ns1.json';\nimport enNs2 from './locales/en/ns2.json';\nimport deNs1 from './locales/de/ns1.json';\nimport deNs2 from './locales/de/ns2.json';\n\ni18next.init({\n  debug: true,\n  fallbackLng: 'en',\n  defaultNS: 'ns1',\n  resources: {\n    en: {\n      ns1: enNs1,\n      ns2: enNs2,\n    },\n    de: {\n      ns1: deNs1,\n      ns2: deNs2,\n    },\n  },\n});\n```\n\nYou import the translation resources and you're adding them via i18next [init](https://www.i18next.com/overview/api#init) function.\n\nTo make the translation type-safe, we create an `i18next.d.ts` file preferably in a `@types` folder and we import the translation resources of our reference language:\n\n```ts\nimport enNs1 from '../locales/en/ns1.json';\nimport enNs2 from '../locales/en/ns2.json';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    defaultNS: 'ns1';\n    resources: {\n      ns1: typeof enNs1;\n      ns2: typeof enNs2;\n    };\n  }\n}\n```\n\n![](inmemory_ts_1.jpg)\n\n<p>\n  That's already great! But: <a target=\"_blank\" rel=\"noopener\" href=\"https://youtu.be/m-lSlJc_5NE\">We Can Do Better</a>! 😜\n  <a target=\"_blank\" rel=\"noopener\" href=\"https://youtu.be/m-lSlJc_5NE\">\n    <img class=\"ignore-gallery-item\" src=\"do_better.gif\" loading=\"lazy\" width=\"480\" height=\"176\" style=\"float: right; margin: 0 0 0 15px;\">\n  </a>\n</p>\n\n<br style=\"clear: both;\" />\n\nWith the help of [i18next-resources-for-ts](https://github.com/i18next/i18next-resources-for-ts) we can generate a single resource file that we can use.\n\nSo install `i18next-resources-for-ts` and execute the `toc` command, i.e. something like: `i18next-resources-for-ts toc -i ./locales/en -o ./@types/resources.ts`\n\nSo we can modify the `i18next.d.ts` file like this:\n\n```ts\nimport resources from './resources';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    defaultNS: 'ns1';\n    resources: typeof resources;\n  }\n}\n```\n\n🧑‍💻 A complete code example can be found [here](https://github.com/locize/i18next-typescript-examples/tree/main/1).\n\n### Plurals <a name=\"plurals\"></a>\n\nbtw: also plural keys works:\n\n![](plurals_ts.jpg)\n\n### Fallback Namespace <a name=\"fallbackns\"></a>\n\nAnd also fallback namespace handling works:\n\n```ts\n// @types/i18next.d.ts\nimport resources from './resources';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    defaultNS: 'ns1';\n    fallbackNS: 'fallback';\n    resources: typeof resources;\n  }\n}\n```\n\n```js\n// works because of fallbackNS\ni18next.t('fallbackKey')\n```\n\n### Interpolation <a name=\"interpolation\"></a>\n\nUnfortunately, automatic interpolation inference won't work if your translations are placed in JSON files, only in TS files using `as const` keyword or an interface in a `d.ts` file, as long as [this TypeScript issue](https://github.com/microsoft/TypeScript/issues/32063) is not addressed.\n\n![](interpolation_ts_nok.jpg)\n\n### Interface <a name=\"in-memory-translations-interface\"></a>\n\nTo address this, let's make use of the `interface` command, i.e. something like: `i18next-resources-for-ts interface -i ./locales/en -o ./@types/resources.d.ts`\n\nThis way we can change the `i18next.d.ts` file like this:\n\n```ts\nimport Resources from './resources';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    defaultNS: 'ns1';\n    resources: Resources;\n  }\n}\n```\n\nNow the interpolation inference works and fails if the passed variable name does not match:\n\n![](interpolation_ts_ok.jpg)\n\n🧑‍💻 A complete code example can be found [here](https://github.com/locize/i18next-typescript-examples/tree/main/2).\n\n\n## React.js <a name=\"react\"></a>\n\nA React.js based i18next setup with in-memory translation resources could also [look very similar](https://github.com/locize/i18next-typescript-examples/tree/main/3) to the above example, so let's raise the bar a little bit and see what a setup with lazy loading translations like with [i18next-http-backend](https://github.com/i18next/i18next-http-backend) looks like:\n\n```ts\nimport i18next from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport HttpApi from 'i18next-http-backend';\n\ni18next\n  .use(initReactI18next)\n  .use(HttpApi)\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    defaultNS: 'ns1',\n    backend: {\n      loadPath: '/locales/{{lng}}/{{ns}}.json'\n    }\n  });\n\nexport default i18next;\n```\n\nTo make the translation type-safe, we again create an `i18next.d.ts` file preferably in a `@types` folder like this:\n\n```ts\nimport Resources from './resources';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    defaultNS: 'ns1';\n    resources: Resources;\n  }\n}\n```\n\nAnd again we make use of the `interface` command, i.e. something like: `i18next-resources-for-ts interface -i ./public/locales/en -o ./src/@types/resources.d.ts`\n\nThis way, the translations are loaded at runtime, but the translations are type-checked during development.\n\nWith the new [react-i18next](https://react.i18next.com) version, when loading multiple namespaces, `t` function will infer and accept the keys for the first namespace. So this pattern is now accepted:\n\n```ts\nimport { useTranslation } from 'react-i18next';\n\nfunction Comp2() {\n  const {t} = useTranslation(['ns1', 'ns2']);\n\n  return (\n    <div className=\"App\">\n      <p>{t('description.part1')}</p>\n      <p>{t('description.part1', { ns: 'ns1' })}</p>\n      <p>{t('description.part2', { ns: 'ns2' })}</p>\n    </div>\n  );\n}\n\nexport default Comp2;\n```\n\n### Trans component <a name=\"trans\"></a>\n\nAnd also the [`Trans` component](https://react.i18next.com/latest/trans-component) is type-safe:\n\n```ts\nimport { useTranslation, Trans } from 'react-i18next';\n\nfunction Comp1() {\n  const {t} = useTranslation();\n\n  return (\n    <div className=\"App\">\n      <p>\n        <Trans i18nKey=\"title\">\n          Welcome to react using <code>react-i18next</code> fully type-safe\n        </Trans>\n      </p>\n      <p>{t('description.part1')}</p>\n      <p>{t('description.part2')}</p>\n    </div>\n  );\n}\n\nexport default Comp1;\n```\n\n![](react_trans_ts.jpg)\n\n🧑‍💻 A complete code example can be found [here](https://github.com/locize/i18next-typescript-examples/tree/main/4).\n\n\n## No app-bundled/provided translations <a name=\"locize\"></a>\n\nThere is also a way to keep the translations completely separate from your code repository while maintaining type safety.\n\nLet's take the React.js project used in [this awesome guide](../react-i18next/)...\n\nThe final i18next setup in this example looks like this:\n\n```ts\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-locize-backend';\nimport LastUsed from 'locize-lastused';\nimport { locizePlugin } from 'locize';\nimport { DateTime } from 'luxon';\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nconst locizeOptions = {\n  projectId: process.env.REACT_APP_LOCIZE_PROJECTID as string,\n  apiKey: process.env.REACT_APP_LOCIZE_APIKEY as string,\n  referenceLng: process.env.REACT_APP_LOCIZE_REFLNG as string,\n  version: process.env.REACT_APP_LOCIZE_VERSION as string\n};\n\nif (!isProduction) {\n  i18n.use(LastUsed);\n}\n\ni18n\n  .use(locizePlugin)\n  .use(Backend)\n  .use(LanguageDetector)\n  .use(initReactI18next)\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false\n    },\n    backend: locizeOptions,\n    locizeLastUsed: locizeOptions,\n    saveMissing: !isProduction\n  });\n\ni18n.services.formatter?.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng as string).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\nSo at runtime we load the translation directly from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\n\n>So how do we get type-safe translations during development?\n\nWe create some npm scripts to help us:\n\n1. Download the published translations (in reference language) to a temporary directory, i.e.:\n\n  `downloadEn`: `locize download --project-id=0bbc223a-9aba-4a90-ab93-ab9d7bf7f780 --language=en --ver=latest --clean=true --path=./src/@types/locales`\n\n2. Create the appropriate interface definition file, i.e.: `interface`:\n\n  `i18next-resources-for-ts interface -i ./src/@types/locales -o ./src/@types/resources.d.ts`\n\n3. Final script: download, create interface and delete the temporary files, i.e.:\n\n  `update-interface`: `npm run downloadEn && npm run interface && rm -rf ./src/@types/locales`\n\n\nLike in the previous example, we now can just import that interface in our `i18next.d.ts` file:\n\n```ts\nimport Resources from './resources';\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    resources: Resources;\n  }\n}\n```\n\nThat's it!\n\n![](not_existing_key.jpg)\n\nThe translations are separated from our code repository and at the same time we maintain type safety with the help of an interface.\n\n🧑‍💻 A complete code example can be found [here](https://github.com/locize/i18next-typescript-examples/tree/main/5).\n\nThere's also a [video](https://youtu.be/GLIas4DH3Ww) about this topic.\n{% youtube GLIas4DH3Ww %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nIn conclusion, mastering i18next for type-safe translations empowers TypeScript developers to unlock the full potential of their applications. By ensuring accurate localization, eliminating runtime errors, and leveraging the seamless integration between i18next and TypeScript, developers can create robust, localized applications that cater to diverse language preferences. With the knowledge and tools provided in this guide, you are equipped to supercharge your TypeScript app and deliver exceptional user experiences on a global scale.\n<br />\n**Happy coding!**\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"Can I use i18next for type-safe translations in JavaScript projects?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"While i18next itself is primarily designed for JavaScript projects, the concept of type-safe translations is most beneficial when using TypeScript. TypeScript provides static type checking, which helps catch errors and provides enhanced developer experience when working with i18next.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does type safety improve the localization process?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Type safety ensures that translation keys are validated during development, preventing potential runtime errors. It allows developers to catch missing or modified translation keys early, improving the overall quality and reliability of localized applications.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Can I still use i18next with type safety if my project has dynamic translations?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, you can still achieve type safety with dynamic translations. By using techniques like generating resource files or defining interfaces for your translations, you can maintain type safety even with dynamically loaded translation content.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Are there any performance implications when using type-safe translations with i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Type-safe translations themselves do not significantly impact runtime performance. The primary focus is on enhancing developer productivity, reducing errors, and improving code quality. The performance of the application largely depends on how i18next is implemented and the size of translation resources.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Are there any limitations or trade-offs when using type-safe translations with i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"While type-safe translations provide numerous benefits, there are a few limitations to consider. For example, automatic interpolation inference may not work with translations placed in JSON files. Additionally, if your translations are separated from your code repository, you need to ensure synchronization between translation updates and your codebase.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"typescript","slug":"typescript","permalink":"https://locize.com/blog/tags/typescript/"},{"name":"types","slug":"types","permalink":"https://locize.com/blog/tags/types/"}]},{"title":"Fixing Missing Translations in i18next - Learn how to handle missing translations in i18next effectively","slug":"missing-translations","date":"un22fin22","updated":"un22fin22","comments":true,"path":"missing-translations/","link":"","permalink":"https://locize.com/blog/missing-translations/","excerpt":"","text":"In today&#39;s globalized world, creating multilingual applications is crucial to reaching a wider audience. One of the key components of successful application localization is accurate translation. However, it&#39;s not uncommon to encounter missing translations when using i18next, a popular internationalization framework. These missing translations can lead to a confusing user experience and undermine the efforts put into localization. In this article, we will explore various strategies and techniques to gracefully handle missing translations in i18next, enabling you to provide a polished and seamless multilingual application. IntroductionBefore diving into the details, let&#39;s first understand the significance of i18next and the challenges posed by missing translations. i18next is a powerful JavaScript library that simplifies the process of internationalizing web applications. It allows developers to easily manage translations for different languages by usually organizing them in language files and using unique translation keys. This approach ensures that the application&#39;s content can be dynamically translated based on the user&#39;s preferred language. However, when translations are missing for specific keys or languages, it can disrupt the localization workflow. Users may encounter untranslated content, placeholders, or even errors, leading to a poor user experience. To avoid such situations, it is essential to have effective strategies in place to handle missing translations and maintain a high level of quality in your multilingual application. Understanding i18next TranslationTo effectively address missing translations, it&#39;s important to have a clear understanding of how i18next translation works. In i18next, translations are usually stored in language files, typically in JSON format. Each translation string is associated with a unique key that is used to retrieve the translated content. These language files are organized based on the supported languages, allowing the application to load the appropriate translations based on the user&#39;s language preference. Maintaining translated content requires regular updates to language files whenever new features are added or existing ones are modified. This ensures that translations remain accurate and up to date, providing a seamless experience for users across different languages. Identifying Missing TranslationsBefore addressing missing translations, it&#39;s crucial to identify them. There are several techniques you can employ to detect untranslated content in your application. One effective approach is to enable i18next&#39;s debug mode, which logs warnings for missing translations in the browser&#39;s console. By inspecting these warnings, you can quickly identify the translation keys that require attention. Additionally, thorough testing and quality assurance play a vital role in identifying missing translations. Test your application with different languages and carefully review the content for any untranslated strings. By following these practices, you can ensure that your application&#39;s translations are comprehensive and accurate. Strategies to Handle Missing TranslationsWhen it comes to handling missing translations, there are several strategies you can employ in your i18next workflow: 1. Using Fallback Languages: To provide a default content for missing translations, you can utilize fallback languages. When a translation is missing for a specific key, i18next can automatically fallback to a default language and display the corresponding translation. This ensures that users still receive meaningful content even if a specific translation is unavailable. 2. Implementing Placeholder Text (default value): Another approach is to implement placeholder text for untranslated content. This allows you to display temporary text or placeholders instead of leaving the content blank. Placeholder text can provide context to the user and give them an idea of what the translated content would be. 3. Customizing Error Handling: i18next provides customization options for handling missing translations. You can define custom error handlers to display informative messages or alternative content when a translation is missing. This way, you can tailor the error handling to match your application&#39;s requirements and maintain a consistent user experience. 4. Systematically Track Missing Translations: Leveraging Community and Machine Translation Services: When facing a large volume of translations or time constraints, leveraging community translation platforms or machine translation services can be beneficial. Platforms like locize enable collaboration with translators, making it easier to manage and update translations. Additionally, with the saveMissing feature in i18next, you can automatically save missing translations and leverage machine translation services to provide initial translations that can later be refined by human translators. This is how such a workflow may look like. By implementing these strategies, you can ensure that your application gracefully handles missing translations, providing a seamless experience for users across different languages. Best Practices for i18next Localization WorkflowTo maintain a smooth localization workflow with i18next, it&#39;s important to follow some best practices: 1. Establishing a Clear Translation Process: Define a clear process for managing translations, including how and when translations are updated. This ensures that translations remain accurate and up to date. 2. Collaborating with Translators and Maintaining a Glossary: Establish effective communication channels with translators and maintain a glossary of frequently used terms. This promotes consistency and accuracy across translations. 3. Consistent Formatting and Placeholders: Ensure that translations follow consistent formatting guidelines and utilize placeholders effectively. This helps maintain the layout and structure of your application across different languages. 4. Version Control and Tracking Changes: Use some sort of versioning and history capabilies to track changes in language files. This allows you to easily revert to previous translations if needed and track modifications over time. By incorporating these best practices into your i18next localization workflow, you can streamline the translation process and maintain a high level of quality in your multilingual application. Improving User ExperienceHandling missing translations not only involves providing alternative content but also focuses on enhancing the user experience. Here are some tips to improve user experience in the context of translations: 1. Communicating Missing Translations: When a translation is missing, it&#39;s important to communicate this to the user clearly. Displaying an informative message or a placeholder indicating that the content is being translated can help manage user expectations. 2. Providing Clear Instructions for Translators: If you collaborate with translators, it&#39;s essential to provide clear instructions and guidelines for translations. This includes context information, style guides, and any specific considerations that might be relevant. 3. Using Context and Variables: Take advantage of i18next&#39;s support for context and variables in translations. By providing additional context or dynamically substituting variables, you can ensure that translations remain accurate and contextually relevant. 4. Avoiding Truncated or Overlapping Text: Consider the length of translated strings and ensure they fit within the layout of your application. Truncated or overlapping text can lead to readability issues and a subpar user experience. By considering these aspects, you can provide a seamless and intuitive experience for users, even in multilingual applications with missing translations. Enhancing i18next PerformanceAs your application grows and incorporates more languages, optimizing the performance of i18next becomes important. Here are some strategies to enhance the performance of your i18next implementation: 1. Caching Translations: Implement caching mechanisms to reduce the number of requests made to load translations. Caching translations locally or utilizing a CDN can significantly improve the performance of your application. 2. Minifying and Bundling Language Files: Minify and bundle your language files to reduce their size. This helps reduce network latency and improves the loading speed of your application. 3. Implementing Lazy Loading: Load translations dynamically when they are needed rather than upfront. This approach, known as lazy loading, reduces the initial loading time of your application and improves perceived performance. 4. Considering Dynamic Content and Reactivity: If your application contains dynamic content that changes frequently, ensure that your i18next implementation can handle such reactivity. This allows translations to be updated dynamically without requiring a page reload. By implementing these performance optimization techniques, you can ensure that your multilingual application provides a fast and responsive user experience across different languages. Future Trends in i18next TranslationAs technology advances, so does the field of translation and localization. Here are some future trends to watch out for in i18next translation: 1. Advances in Machine Translation and AI-driven Localization: Machine translation technologies, such as neural machine translation, are constantly evolving. These advancements enable more accurate and natural-sounding translations, reducing the need for manual translation efforts. 2. Integration with Translation Management Systems: Integration between i18next and translation management systems (TMS) like locize can streamline the translation workflow. TMS tools provide features like automated translation synchronization, collaborative translation environments, and workflow management. 3. Automation and Continuous Localization: Automation plays a key role in achieving continuous localization. With automation tools, developers can synchronize translations automatically or automatically publish the translations via CDN, reducing manual effort and ensuring translations are always up to date. By staying informed about these trends, you can adapt your i18next translation workflow to leverage new technologies and enhance the efficiency and accuracy of your localization efforts. ConclusionHandling missing translations in i18next is crucial to providing a polished multilingual application. By employing strategies to identify and handle missing translations, you can ensure a seamless user experience across different languages. Additionally, following best practices for i18next localization workflow and focusing on improving user experience will further enhance the quality of your translations. Finally, by optimizing performance and staying updated with future trends in i18next translation, you can future-proof your localization efforts and provide a globally accessible application. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"How can I ensure the accuracy of translated content?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"To ensure accuracy, collaborate closely with translators, provide clear instructions and context, and maintain a glossary. Regularly review and update translations based on user feedback and application changes.\" } }, { \"@type\": \"Question\", \"name\": \"Is it necessary to translate every single string in my application?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"While translating all content is ideal, prioritize translating user-facing and essential strings. Focus on providing a seamless user experience and ensuring that critical information is available in the user's preferred language.\" } }, { \"@type\": \"Question\", \"name\": \"What are the potential challenges of working with multiple languages in i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Challenges include managing and coordinating translations, ensuring consistency across languages, handling variations in text length, and maintaining performance as the number of languages increases.\" } }, { \"@type\": \"Question\", \"name\": \"How can I optimize the performance of i18next in a large-scale application?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Optimize performance by caching translations, minifying and bundling language files, implementing lazy loading, and considering reactivity for dynamic content.\" } }, { \"@type\": \"Question\", \"name\": \"Are there any tools or plugins available to streamline the translation process?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, there are translation management systems (TMS) like locize, that integrate with i18next and provide features to streamline the translation process, automate synchronization, and facilitate collaboration among translators.\" } }] }","raw":"---\ntitle: Fixing Missing Translations in i18next - Learn how to handle missing translations in i18next effectively\ndescription: \"Fixing Missing Translations in i18next - Learn how to effectively handle missing translations in i18next, ensuring a seamless multilingual user experience and enhancing your localization workflow.\"\n\ndate: 2023-06-06\ntags:\n  - localization\n  - internationalization\n  - l10n\n  - i18n\n  - i18next\n  - locize\nthumbnail: missing-translations/title.jpg\n---\n\n![](title.jpg)\n\nIn today's globalized world, creating multilingual applications is crucial to reaching a wider audience. One of the key components of successful application localization is accurate translation. However, it's not uncommon to encounter missing translations when using [i18next](https://www.i18next.com), a popular internationalization framework. These missing translations can lead to a confusing user experience and undermine the efforts put into localization. In this article, we will explore various strategies and techniques to gracefully handle missing translations in [i18next](https://www.i18next.com), enabling you to provide a polished and seamless multilingual application.\n\n## Introduction\n\nBefore diving into the details, let's first understand the significance of i18next and the challenges posed by missing translations. i18next is a powerful JavaScript library that simplifies the process of internationalizing web applications. It allows developers to easily manage translations for different languages by usually organizing them in language files and using unique translation keys. This approach ensures that the application's content can be dynamically translated based on the user's preferred language.\n\nHowever, when translations are missing for specific keys or languages, it can disrupt the localization workflow. Users may encounter untranslated content, placeholders, or even errors, leading to a poor user experience. To avoid such situations, it is essential to have effective strategies in place to handle missing translations and maintain a high level of quality in your multilingual application.\n\n## Understanding i18next Translation\n\nTo effectively address missing translations, it's important to have a clear understanding of how i18next translation works. In i18next, translations are usually stored in language files, typically in JSON format. Each translation string is associated with a unique key that is used to retrieve the translated content. These language files are organized based on the supported languages, allowing the application to load the appropriate translations based on the user's language preference.\n\nMaintaining translated content requires regular updates to language files whenever new features are added or existing ones are modified. This ensures that translations remain accurate and up to date, providing a seamless experience for users across different languages.\n\n## Identifying Missing Translations\n\nBefore addressing missing translations, it's crucial to identify them. There are several techniques you can employ to detect untranslated content in your application. One effective approach is to enable i18next's debug mode, which logs warnings for missing translations in the browser's console. By inspecting these warnings, you can quickly identify the translation keys that require attention.\n\nAdditionally, thorough testing and quality assurance play a vital role in identifying missing translations. Test your application with different languages and carefully review the content for any untranslated strings. By following these practices, you can ensure that your application's translations are comprehensive and accurate.\n\n## Strategies to Handle Missing Translations\n\nWhen it comes to handling missing translations, there are several strategies you can employ in your i18next workflow:\n\n**1. Using Fallback Languages**: To provide a default content for missing translations, you can utilize [fallback languages](https://www.i18next.com/principles/fallback#language-fallback). When a translation is missing for a specific key, i18next can automatically fallback to a default language and display the corresponding translation. This ensures that users still receive meaningful content even if a specific translation is unavailable.\n\n**2. Implementing Placeholder Text (default value)**: Another approach is to implement [placeholder text](https://www.i18next.com/translation-function/essentials#passing-a-default-value) for untranslated content. This allows you to display temporary text or placeholders instead of leaving the content blank. Placeholder text can provide context to the user and give them an idea of what the translated content would be.\n\n**3. Customizing Error Handling**: i18next provides [customization options](https://www.i18next.com/overview/configuration-options#missing-keys) for handling missing translations. You can define custom error handlers to display informative messages or alternative content when a translation is missing. This way, you can tailor the error handling to match your application's requirements and maintain a consistent user experience.\n\n**4. Systematically Track Missing Translations: Leveraging Community and Machine Translation Services**: When facing a large volume of translations or time constraints, leveraging community translation platforms or machine translation services can be beneficial. Platforms like locize enable collaboration with translators, making it easier to manage and update translations. Additionally, with the [`saveMissing`](https://www.i18next.com/overview/configuration-options#missing-keys) feature in i18next, you can automatically save missing translations and leverage [machine translation services](https://docs.locize.com/whats-inside/auto-machine-translation) to provide initial translations that can later be refined by human translators. This is how such a workflow [may look like](https://youtu.be/ds-yEEYP1Ks?t=578).\n\n[![](auto-translate-missing.gif)](https://youtu.be/ds-yEEYP1Ks?t=578)\n\nBy implementing these strategies, you can ensure that your application gracefully handles missing translations, providing a seamless experience for users across different languages.\n\n## Best Practices for i18next Localization Workflow\n\nTo maintain a smooth localization workflow with i18next, it's important to follow some best practices:\n\n**1. Establishing a Clear Translation Process**: Define a clear process for managing translations, including [how and when translations are updated](https://docs.locize.com/guides-tips-and-tricks/keeping-track-of-new-translations). This ensures that translations remain accurate and up to date.\n\n**2. Collaborating with Translators and Maintaining a Glossary**: Establish effective communication channels with translators and maintain a [glossary of frequently used terms](https://docs.locize.com/whats-inside/glossary). This promotes consistency and accuracy across translations.\n\n**3. Consistent Formatting and Placeholders**: Ensure that translations follow consistent [formatting](../i18n-formats-javascript/#i18next) guidelines and utilize placeholders effectively. This helps maintain the layout and structure of your application across different languages.\n\n**4. Version Control and Tracking Changes**: Use some sort of [versioning](https://docs.locize.com/more/versioning) and [history](https://docs.locize.com/whats-inside/history) capabilies to track changes in language files. This allows you to easily revert to previous translations if needed and track modifications over time.\n\nBy incorporating these best practices into your i18next localization workflow, you can streamline the translation process and maintain a high level of quality in your multilingual application.\n\n## Improving User Experience\n\nHandling missing translations not only involves providing alternative content but also focuses on enhancing the user experience. Here are some tips to improve user experience in the context of translations:\n\n**1. Communicating Missing Translations**: When a translation is missing, it's important to communicate this to the user clearly. Displaying an informative message or a placeholder indicating that the content is being translated can help manage user expectations.\n\n**2. Providing Clear Instructions for Translators**: If you collaborate with translators, it's essential to provide clear instructions and guidelines for translations. This includes [context information](https://docs.locize.com/whats-inside/context), style guides, and any specific considerations that might be relevant.\n\n**3. Using Context and Variables**: Take advantage of i18next's support for [context](https://www.i18next.com/translation-function/context) and [variables](https://www.i18next.com/translation-function/interpolation) in translations. By providing additional context or dynamically substituting variables, you can ensure that translations remain accurate and contextually relevant.\n\n**4. Avoiding Truncated or Overlapping Text**: Consider the length of translated strings and ensure they fit within the layout of your application. Truncated or overlapping text can lead to readability issues and a subpar user experience.\n\nBy considering these aspects, you can provide a seamless and intuitive experience for users, even in multilingual applications with missing translations.\n\n## Enhancing i18next Performance\n\nAs your application grows and incorporates more languages, optimizing the performance of i18next becomes important. Here are some strategies to enhance the performance of your i18next implementation:\n\n**1. Caching Translations**: Implement caching mechanisms to reduce the number of requests made to load translations. [Caching](https://docs.locize.com/more/caching) translations [locally](https://docs.locize.com/more/caching/alternative-caching) or utilizing a [CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network) can significantly improve the performance of your application.\n\n**2. Minifying and Bundling Language Files**: Minify and [bundle](https://docs.locize.com/more/general-questions/do-i-have-to-use-the-locize-cdn-or-can-i-host-bundle-the-translations-directly) your language files to reduce their size. This helps reduce network latency and improves the loading speed of your application.\n\n**3. Implementing Lazy Loading**: [Load translations dynamically](https://www.i18next.com/how-to/add-or-load-translations#load-using-a-smart-backend-plugin-serving-directly-from-a-cdn) when they are needed rather than upfront. This approach, known as lazy loading, reduces the initial loading time of your application and improves perceived performance.\n\n**4. Considering Dynamic Content and Reactivity**: If your application contains dynamic content that changes frequently, ensure that your i18next implementation can handle such reactivity. This allows translations to be updated dynamically without requiring a page reload.\n\nBy implementing these performance optimization techniques, you can ensure that your multilingual application provides a fast and responsive user experience across different languages.\n\n## Future Trends in i18next Translation\n\nAs technology advances, so does the field of translation and localization. Here are some future trends to watch out for in i18next translation:\n\n**1. Advances in Machine Translation and AI-driven Localization**: Machine translation technologies, such as neural machine translation, are constantly evolving. These advancements enable more accurate and natural-sounding translations, reducing the need for manual translation efforts.\n\n**2. Integration with Translation Management Systems**: Integration between i18next and translation management systems ([TMS](../tms/)) like [locize](/) can streamline the translation workflow. TMS tools provide features like automated translation synchronization, collaborative translation environments, and workflow management.\n\n**3. Automation and Continuous Localization**: Automation plays a key role in achieving [continuous localization](../modern-continuous-localization/). With automation tools, developers can synchronize translations automatically or automatically publish the translations via [CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network), reducing manual effort and ensuring translations are always up to date.\n\nBy staying informed about these trends, you can adapt your i18next translation workflow to leverage new technologies and enhance the efficiency and accuracy of your localization efforts.\n\n## Conclusion\n\nHandling missing translations in i18next is crucial to providing a polished multilingual application. By employing strategies to identify and handle missing translations, you can ensure a seamless user experience across different languages. Additionally, following best practices for i18next localization workflow and focusing on improving user experience will further enhance the quality of your translations. Finally, by optimizing performance and staying updated with future trends in i18next translation, you can future-proof your localization efforts and provide a globally accessible application.\n\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"How can I ensure the accuracy of translated content?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"To ensure accuracy, collaborate closely with translators, provide clear instructions and context, and maintain a glossary. Regularly review and update translations based on user feedback and application changes.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Is it necessary to translate every single string in my application?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"While translating all content is ideal, prioritize translating user-facing and essential strings. Focus on providing a seamless user experience and ensuring that critical information is available in the user's preferred language.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What are the potential challenges of working with multiple languages in i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Challenges include managing and coordinating translations, ensuring consistency across languages, handling variations in text length, and maintaining performance as the number of languages increases.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How can I optimize the performance of i18next in a large-scale application?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Optimize performance by caching translations, minifying and bundling language files, implementing lazy loading, and considering reactivity for dynamic content.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Are there any tools or plugins available to streamline the translation process?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, there are translation management systems (TMS) like locize, that integrate with i18next and provide features to streamline the translation process, automate synchronization, and facilitate collaboration among translators.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"}]},{"title":"Don't let translation topics distract you!","slug":"translation-distraction","date":"un11fin11","updated":"un11fin11","comments":true,"path":"translation-distraction/","link":"","permalink":"https://locize.com/blog/translation-distraction/","excerpt":"","text":"You may find yourself in a situation where you need to create a multilingual website or application. When that happens, you&#39;ll inevitably encounter the issue of translation. While translation is essential, it can also be distracting, especially when you&#39;re working on a project with many moving parts. As a developer, you&#39;re no stranger to the challenges of creating software that is accessible to a global audience. Internationalization, or i18n, can be a daunting task that involves creating software that can easily adapt to different languages and cultures. But while it&#39;s important to prioritize i18n in your development process, it&#39;s also important not to let translation issues distract you from your primary goal. TOC Introduction Why translation topics can distract you as a developer The impact of distraction on your productivity How to manage translation-related distractions Simplify the translation process Delegate translation tasks to others Use machine translation The importance of staying focused on your core tasks Conclusion Introduction As a developer, your primary focus is on writing clean, functional code that delivers the desired features and functionality to your end users. However, when it comes to multilingual projects, you may find yourself distracted by translation issues. This is because translation requires a significant amount of attention, planning, and resources, which can pull you away from your core responsibilities. In this article, we&#39;ll explore why translation issues can be a distraction, how that distraction affects your productivity, and how to manage it effectively. Why translation topics can distract you as a developer Translation topics can be a distraction because they require a considerable amount of attention and planning. When you&#39;re working on a multilingual project, you have to consider things like language-specific formatting, text expansion, the possibility of mistranslation and a lot more. Additionally, the translation process involves collaborating with different stakeholders, such as translators, editors, and proofreaders, which can consume a lot of your time and energy. This can cause you to lose focus on your primary tasks, leading to delays in your project&#39;s delivery. One of the primary reasons that especially internationalization (i18n) can be frustrating for developers is its complexity. Internationalization is a multi-faceted process that involves everything from designing flexible user interfaces to handling different date and time formats. For large and complex software systems, this can be a time-consuming and challenging task. This can be summarized with the question: &quot;Is your software ready for localization?&quot; Incomplete or inaccurate translations can lead to a poor user experience for non-native speakers, and ongoing maintenance to keep translations up-to-date can be resource-intensive. In addition, a lack of testing for i18n can make it difficult to identify and fix bugs that occur when the software runs in different languages or cultures. Localization Tip Read about what software localization is. The impact of distraction on your productivity Distractions can have a serious impact on your productivity. When you&#39;re not focused, you tend to make more mistakes and your work takes longer to complete. This can lead to missed deadlines and frustrated stakeholders. In addition, distractions can affect your creativity, making it harder for you to come up with innovative solutions to problems. This can limit your ability to deliver a quality product that meets the needs of your users. How to manage translation-related distractions Managing translation-related distractions is essential to ensuring that you stay focused on your core tasks. Here are some strategies you can use: Simplify the translation process One way to deal with translation-related distractions is to simplify the translation process. You can do this by using translation tools that automate certain aspects of the process, such as translation memory and glossaries. Delegate translation tasks to others Another way to manage translation distractions is to delegate translation tasks to others. You can hire professional translators, editors, and proofreaders to handle the translation process while you focus on your core business. Or better yet, use a modern translation management system like locize that takes the pain out of the translation process. No more delays in shipping your software due to missing translations. Translators can keep up with changes from day one. The continuous localization process keeps pace with your demanding business. A tms like locize bridges the gap between localization and development. This makes you faster, more efficient and saves you money overall. Use machine translation Using machine translation is another way to manage translation-related distractions. While machine translation is not always accurate, it can be useful for translating simple text or getting a rough idea of the content. The on-demand machine translation or automatic machine translation options are a good example of how machine translation can be used. Machine translation would be the most cost-effective approach because it is virtually free. However, if no one checks the translated information, there will undoubtedly be a lack of quality. But modern TMS like locize can help you with this. Read more about it here. The importance of staying focused on your core tasks As a developer, your primary focus should be on writing clean, functional code that delivers the desired features and functionality to your end users. It&#39;s important to remember that internationalization is an essential aspect of software development. By making your software accessible to a global audience, you can reach new markets and make your product more widely used. But it&#39;s also important to stay focused on your main goals and not let translation issues distract you from delivering a quality product. To ensure that internationalization doesn&#39;t distract you from your primary goals, it&#39;s important to prioritize it in your development process. By making i18n a fundamental part of your software design, you can create a product that is easier to adapt to different languages and cultures. This can include everything from using a localization platform like locize to conducting thorough testing and working closely with translation teams. Conclusion Translation issues can be a significant distraction, but it&#39;s important to manage these distractions so you can focus on your core tasks. By simplifying the translation process, delegating tasks to others, and using smart tools, you can free up more time and energy to focus on writing clean, functional code that delivers the desired features and functionality to your end users. Remember to stay focused on your core responsibilities to ensure that you deliver a quality product that meets the needs of your users. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"Why are translation topics distracting for developers?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Translation requires a considerable amount of attention, planning, and resources, which can pull developers away from their core responsibilities.\" } }, { \"@type\": \"Question\", \"name\": \"How can I manage translation-related distractions?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"You can manage translation-related distractions by simplifying the translation process, delegating tasks to others, and using smart tools.\" } }, { \"@type\": \"Question\", \"name\": \"What's the impact of distraction on my productivity as a developer?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Distraction can have a severe impact on your productivity as a developer, leading to mistakes, missed deadlines, and a decrease in creativity.\" } }, { \"@type\": \"Question\", \"name\": \"Why is it essential to stay focused on your core tasks?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Staying focused on your core tasks is essential to ensure that you deliver a high-quality product that meets the needs of your users.\" } }, { \"@type\": \"Question\", \"name\": \"How can I ensure that I stay focused on my core tasks?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"You can ensure that you stay focused on your core tasks by managing translation-related distractions, prioritizing your work, and using smart tools like locize.\" } }] }","raw":"---\ntitle: \"Don't let translation topics distract you!\"\ndescription: \"In this article, we'll explore why translation topics can distract you as a developer and how you can manage this distraction.\"\n\ndate: 2023-05-08\ntags:\n  - localization\n  - internationalization\n  - tech lead\n  - engineering manager\n  - l10n\n  - i18n\nthumbnail: translation-distraction/title.jpg\n---\n\n![](title.jpg)\n\nYou may find yourself in a situation where you need to create a multilingual website or application. When that happens, you'll inevitably encounter the issue of translation. While translation is essential, it can also be distracting, especially when you're working on a project with many moving parts.\n\nAs a developer, you're no stranger to the challenges of creating software that is accessible to a global audience. Internationalization, or [i18n](../what-is-i18n/), can be a daunting task that involves creating software that can easily adapt to different languages and cultures. But while it's important to prioritize i18n in your [development process](../help-tech-leads/), it's also important not to let translation issues distract you from your primary goal.\n\n## TOC\n  * [Introduction](#intro)\n  * [Why translation topics can distract you as a developer](#why)\n  * [The impact of distraction on your productivity](#impact)\n  * [How to manage translation-related distractions](#manage)\n    - [Simplify the translation process](#simplify)\n    - [Delegate translation tasks to others](#delegate)\n    - [Use machine translation](#machinetranslation)\n  * [The importance of staying focused on your core tasks](#focus)\n  * [Conclusion](#conclusion)\n\n\n## Introduction <a name=\"intro\"></a>\n\nAs a developer, your primary focus is on writing clean, functional code that delivers the desired features and functionality to your end users. However, when it comes to multilingual projects, you may find yourself distracted by translation issues. This is because translation requires a significant amount of attention, planning, and resources, which can [pull you away from your core responsibilities](../help-tech-leads/).\n\nIn this article, we'll explore why translation issues can be a distraction, how that distraction affects your productivity, and how to manage it effectively.\n\n\n## Why translation topics can distract you as a developer <a name=\"why\"></a>\n\nTranslation topics can be a distraction because they require a considerable amount of attention and planning. When you're working on a multilingual project, you have to consider things like language-specific formatting, text expansion, the possibility of mistranslation and [a lot more](../hidden-localization-costs/).\n\nAdditionally, the translation process involves collaborating with different stakeholders, such as translators, editors, and proofreaders, which can consume a lot of your time and energy. This can cause you to lose focus on your primary tasks, leading to delays in your project's delivery.\n\nOne of the primary reasons that especially internationalization ([i18n](../what-is-i18n/)) can be frustrating for developers is its complexity. Internationalization is a multi-faceted process that involves everything from designing flexible user interfaces to handling different date and time formats. For large and complex software systems, this can be a time-consuming and challenging task.\n</br>\nThis can be summarized with the question: \"[Is your software ready for localization?](../is-your-software-ready-for-localization/)\"\n\nIncomplete or inaccurate translations can lead to a poor user experience for non-native speakers, and ongoing maintenance to [keep translations up-to-date](../continuous-development-integration-and-localization-cd/) can be resource-intensive. In addition, a lack of testing for i18n can make it difficult to identify and fix bugs that occur when the software runs in different languages or cultures.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\">Localization Tip</h3>\n<p style=\"color:grey;\">Read about what <a href=\"../what-is-software-localization/\" title=\"What is Software Localization?\">software localization</a> is.</p>\n</div>\n\n\n## The impact of distraction on your productivity <a name=\"impact\"></a>\n\nDistractions can have a serious impact on your productivity. When you're not focused, you tend to make more mistakes and your work takes longer to complete. This can lead to missed [deadlines and frustrated stakeholders](../help-tech-leads/#situations).\n\nIn addition, distractions can affect your creativity, making it harder for you to come up with innovative solutions to problems. This can limit your ability to deliver a quality product that meets the needs of your users.\n\n\n\n## How to manage translation-related distractions <a name=\"manage\"></a>\n\nManaging translation-related distractions is essential to ensuring that you stay focused on your core tasks. Here are some strategies you can use:\n\n### Simplify the translation process <a name=\"simplify\"></a>\n\nOne way to deal with translation-related distractions is to simplify the translation process. You can do this by using [translation tools](../tms/) that automate certain aspects of the process, such as [translation memory and glossaries](../localization-context/#context-features).\n![](../localization-context/glossary.png)\n\n### Delegate translation tasks to others <a name=\"delegate\"></a>\n\nAnother way to manage translation distractions is to delegate translation tasks to others. You can hire professional translators, editors, and proofreaders to handle the translation process while you focus on your core business. Or better yet, use a modern translation management system like [locize](/) that takes the pain out of the translation process. No more delays in shipping your software due to missing translations. Translators can keep up with changes from day one. The continuous localization process keeps pace with your demanding business.\nA [tms](../i18n-l10n-t9n-tms/) like [locize](https://locize.com) bridges the gap between localization and development. This makes you faster, more efficient and saves you money overall.\n\n### Use machine translation <a name=\"machinetranslation\"></a>\n\nUsing machine translation is another way to manage translation-related distractions. While machine translation is not always accurate, it can be useful for translating simple text or getting a rough idea of the content.\n\nThe [on-demand machine translation](https://docs.locize.com/different-views/global#bulk-actions) or [automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation) options are a good example of how machine translation can be used.\n\n![](../next-i18next/missing_key_auto_mt.jpg)\n\nMachine translation would be the most cost-effective approach because it is virtually free. However, if no one checks the translated information, there will undoubtedly be a lack of quality. But modern TMS like locize can help you with this. Read more about it [here](https://docs.locize.com/guides-tips-and-tricks/working-with-translators).\n\n\n## The importance of staying focused on your core tasks <a name=\"focus\"></a>\n\nAs a developer, your primary focus should be on writing clean, functional code that delivers the desired features and functionality to your end users.\n\nIt's important to remember that internationalization is an essential aspect of software development. By making your software accessible to a global audience, you can [reach new markets](../grow-online-business/) and [make your product more widely used](../scalable-localization-strategy/). But it's also important to stay focused on your main goals and not let translation issues distract you from delivering a quality product.\n\nTo ensure that internationalization doesn't distract you from your primary goals, it's important to prioritize it in your development process. By making i18n a fundamental part of your software design, you can create a product that is easier to adapt to different languages and cultures. This can include everything from using a localization platform like [locize](/) to conducting thorough testing and [working closely with translation teams](https://docs.locize.com/guides-tips-and-tricks/working-with-translators).\n\n\n## Conclusion <a name=\"conclusion\"></a>\n\nTranslation issues can be a significant distraction, but it's important to manage these distractions so you can focus on your core tasks. By simplifying the translation process, delegating tasks to others, and using [smart tools](../i18n-l10n-t9n-tms/), you can free up more time and energy to focus on writing clean, functional code that delivers the desired features and functionality to your end users. Remember to stay focused on your core responsibilities to ensure that you deliver a quality product that meets the needs of your users.\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"Why are translation topics distracting for developers?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Translation requires a considerable amount of attention, planning, and resources, which can pull developers away from their core responsibilities.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How can I manage translation-related distractions?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"You can manage translation-related distractions by simplifying the translation process, delegating tasks to others, and using smart tools.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What's the impact of distraction on my productivity as a developer?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Distraction can have a severe impact on your productivity as a developer, leading to mistakes, missed deadlines, and a decrease in creativity.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Why is it essential to stay focused on your core tasks?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Staying focused on your core tasks is essential to ensure that you deliver a high-quality product that meets the needs of your users.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How can I ensure that I stay focused on my core tasks?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"You can ensure that you stay focused on your core tasks by managing translation-related distractions, prioritizing your work, and using smart tools like locize.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"tech lead","slug":"tech-lead","permalink":"https://locize.com/blog/tags/tech-lead/"},{"name":"engineering manager","slug":"engineering-manager","permalink":"https://locize.com/blog/tags/engineering-manager/"}]},{"title":"The Importance of Context in Localization: Best Practices for Accurate Translations","slug":"localization-context","date":"un22fin22","updated":"un11fin11","comments":true,"path":"localization-context/","link":"","permalink":"https://locize.com/blog/localization-context/","excerpt":"","text":"As businesses expand their reach to global audiences, localization becomes crucial to ensure their message reaches the target market accurately. However, translating content accurately can be challenging, especially when context is not considered. In this article, we will explore the importance of context in localization and how some context features can help improve translation accuracy. Understanding Context in LocalizationContext plays a crucial role in accurately translating content. It refers to the circumstances, conditions, or background surrounding a word or phrase that contributes to its meaning. Without proper context, translators may misunderstand the intended message, leading to an inaccurate translation. Some situations where context is particularly important include idiomatic expressions, cultural references, and technical terms. Examples- Inaccurate translations: Without context, translators may misinterpret the meaning of a phrase, resulting in a less accurate translation. For example, if a software application has a button with the label &quot;ship&quot; a translator without context might translate it to German as &quot;Schiff&quot; (large boat for transporting people) instead of &quot;versenden&quot; (send / transport) leading to confusion for the user. - Cultural insensitivity: Without context, translations may be culturally insensitive or even offensive. For example, a literal translation of a phrase or idiom in one language may not make sense or be considered offensive in another language. - Inconsistent terminology: Without context, translators may use inconsistent terminology, resulting in confusion for users. For example, if a software application uses different terms to refer to the same feature in different parts of the application, users may have difficulty understanding how to use it. - Technical errors: Without context, translators may not have the technical knowledge necessary to accurately translate technical terms or phrases. For example, a translator may not understand the technical meaning of a term like &quot;cache&quot; and translate it as &quot;hidden storage&quot; leading to confusion for the user. Best Practices for Using locize&#39;s Context Features Locize offers several powerful features to help improve translation accuracy: specific context information per segment, InContext view, terminology glossary, and screenshot feature. Specific context information allows users to add notes, links, and descriptions to provide additional context for each individual key/segment. The InContext view enables users to connect content from their website directly with their content on their localization project on locize. The glossary is a lexica that contains terminology to be used or not be used in the translations. It&#39;s here to aid translators to use the terms preferred by your organisation. Using the screenshot feature, users can assign text parts of a screenshot to a specific translation key. To use the context features effectively, users should provide as much context as possible. This can include providing background information on the product or service, identifying the intended audience, and giving clear instructions to the translation team. Users should also include screenshots or links where necessary, which can provide additional context that is not immediately apparent from the text. It is also important to involve the translation team in the context-gathering process, as they may have valuable insights into the nuances of the language and culture. Real-World Examples of Improved Translation Accuracy with locize&#39;s Context FeaturesLocize&#39;s context features have helped many businesses and organizations improve translation accuracy. For example, a healthcare company used locize&#39;s context features to provide additional context for medical terms, resulting in more accurate translations. By providing definitions and explanations of medical terms, translators were able to better understand the intended meaning of the text. A globally leading technology firm used locize&#39;s screenshot feature to assign text parts of a screenshot to a specific translation key, resulting in more accurate translations for their website. This allowed translators to see the text in context, which helped them understand the intended meaning. A fintech company used locize&#39;s InContext view to connect content from their app with their localization project on locize, resulting in more accurate translations for their service. This helped translators understand how the text would appear in the final product, which allowed them to provide more accurate translations. Bonus Tip Check out our Customer Testimonials for more examples of our clients. ConclusionContext is critical for accurate translations, and locize&#39;s context features offer powerful tools to improve translation accuracy. By using specific context information, InContext view, terminology glossary, and screenshot feature, businesses and organizations can provide translators with the context they need to produce more accurate translations. To get the most out of locize&#39;s context features, it&#39;s essential to provide as much context as possible, involve the translation team in the context-gathering process, and try out different context-gathering methods to find what works best for your content. If you like to see how locize looks like, check out this video and try the free trial. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is localization?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Localization is the process of adapting a product or service to meet the language, cultural, and other requirements of a specific country or region.\" } }, { \"@type\": \"Question\", \"name\": \"Why is context important in translation?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Context provides additional information that can help translators understand the intended meaning of a word or phrase. Without context, translations can be inaccurate or unclear.\" } }, { \"@type\": \"Question\", \"name\": \"What is InContext view?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"InContext view is a feature of locize that enables users to connect content from their website/application directly with their content on their localization project on locize.\" } }, { \"@type\": \"Question\", \"name\": \"What is context in localization?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Context in localization refers to the circumstances, conditions, or background surrounding a word or phrase that contributes to its meaning. Without proper context, translators may misunderstand the intended message, leading to an inaccurate translation.\" } }, { \"@type\": \"Question\", \"name\": \"How does context affect translation accuracy?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Context plays a crucial role in accurately translating content. Without context, translators may misinterpret the meaning of a phrase, resulting in a less accurate translation. Some situations where context is particularly important include idiomatic expressions, cultural references, and technical terms.\" } }, { \"@type\": \"Question\", \"name\": \"What are the context features offered by locize to improve translation accuracy?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Locize offers several powerful features to help improve translation accuracy, including specific context information per segment, InContext view, terminology glossary, and screenshot feature.\" } }, { \"@type\": \"Question\", \"name\": \"How can users effectively use locize's context features?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"To use locize's context features effectively, users should provide as much context as possible. This can include providing background information on the product or service, identifying the intended audience, and giving clear instructions to the translation team. Users should also include screenshots or links where necessary, which can provide additional context that is not immediately apparent from the text.\" } }] }","raw":"---\ntitle: \"The Importance of Context in Localization: Best Practices for Accurate Translations\"\ndescription: In this article, we will explore the importance of context in localization and how some context features can help improve translation accuracy.\n\ndate: 2023-04-11\ntags:\n  - localization\n  - l10n\nthumbnail: localization-context/title.jpg\n\nlabel: localization-context\nlang: en\n---\n\n![](title.jpg)\n\nAs businesses expand their reach to global audiences, localization becomes crucial to ensure their message reaches the target market accurately. However, translating content accurately can be challenging, especially when context is not considered. In this article, we will explore the importance of context in localization and how some context features can help improve translation accuracy.\n\n\n## Understanding Context in Localization\n\nContext plays a crucial role in accurately translating content. It refers to the circumstances, conditions, or background surrounding a word or phrase that contributes to its meaning. Without proper context, translators may misunderstand the intended message, leading to an inaccurate translation. Some situations where context is particularly important include idiomatic expressions, cultural references, and technical terms.\n\n### Examples\n\n**- Inaccurate translations:** Without context, translators may misinterpret the meaning of a phrase, resulting in a less accurate translation. For example, if a software application has a button with the label \"ship\" a translator without context might translate it to German as \"Schiff\" *(large boat for transporting people)* instead of \"versenden\" *(send / transport)* leading to confusion for the user.\n\n**- Cultural insensitivity:** Without context, translations may be culturally insensitive or even offensive. For example, a literal translation of a phrase or idiom in one language may not make sense or be considered offensive in another language.\n\n**- Inconsistent terminology:** Without context, translators may use inconsistent terminology, resulting in confusion for users. For example, if a software application uses different terms to refer to the same feature in different parts of the application, users may have difficulty understanding how to use it.\n\n**- Technical errors:** Without context, translators may not have the technical knowledge necessary to accurately translate technical terms or phrases. For example, a translator may not understand the technical meaning of a term like \"cache\" and translate it as \"hidden storage\" leading to confusion for the user.\n\n\n## Best Practices for Using locize's Context Features <a name=\"context-features\"></a>\n\nLocize offers several powerful features to help improve translation accuracy: specific [context information per segment](https://docs.locize.com/whats-inside/context#context-information-per-key-segment), [InContext view](https://docs.locize.com/whats-inside/context#incontext-view), [terminology glossary](https://docs.locize.com/whats-inside/glossary), and [screenshot](https://docs.locize.com/whats-inside/context#screenshots) feature.\n\n\n[Specific context information](https://docs.locize.com/whats-inside/context#context-information-per-key-segment) allows users to add notes, links, and descriptions to provide additional context for each individual key/segment.\n![](key_context.png)\n\nThe [InContext view](https://docs.locize.com/whats-inside/context#incontext-view) enables users to connect content from their website directly with their content on their localization project on locize.\n![](incontext_editor.png)\n\nThe [glossary](https://docs.locize.com/whats-inside/glossary) is a lexica that contains terminology to be used or not be used in the translations. It's here to aid translators to use the terms preferred by your organisation.\n![](glossary.png)\n\nUsing the [screenshot](https://docs.locize.com/whats-inside/context#screenshots) feature, users can assign text parts of a screenshot to a specific translation key.\n![](screenshot.png)\n\n\nTo use the context features effectively, users should provide as much context as possible. This can include providing background information on the product or service, identifying the intended audience, and giving clear instructions to the translation team. Users should also include screenshots or links where necessary, which can provide additional context that is not immediately apparent from the text. It is also important to involve the translation team in the context-gathering process, as they may have valuable insights into the nuances of the language and culture.\n\n\n## Real-World Examples of Improved Translation Accuracy with locize's Context Features\n\nLocize's context features have helped many businesses and organizations improve translation accuracy. For example, a healthcare company used locize's context features to provide additional context for medical terms, resulting in more accurate translations. By providing definitions and explanations of medical terms, translators were able to better understand the intended meaning of the text.\nA globally leading technology firm used locize's screenshot feature to assign text parts of a screenshot to a specific translation key, resulting in more accurate translations for their website. This allowed translators to see the text in context, which helped them understand the intended meaning.\nA fintech company used locize's InContext view to connect content from their app with their localization project on locize, resulting in more accurate translations for their service. This helped translators understand how the text would appear in the final product, which allowed them to provide more accurate translations.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\">Bonus Tip</h3>\n<p style=\"color:grey;\">Check out our <a href=\"https://locize.com/customers.html#testimonials\" title=\"Customer Testimonials\">Customer Testimonials</a> for more examples of our clients.</p>\n</div>\n\n\n## Conclusion\n\nContext is critical for accurate translations, and locize's context features offer powerful tools to improve translation accuracy. By using specific context information, InContext view, terminology glossary, and screenshot feature, businesses and organizations can provide translators with the context they need to produce more accurate translations. To get the most out of locize's context features, it's essential to provide as much context as possible, involve the translation team in the context-gathering process, and try out different context-gathering methods to find what works best for your content.\n\n*If you like to see how locize looks like, check out [this video](https://youtu.be/ds-yEEYP1Ks) and try the [free trial](https://www.locize.app/register).*\n\n{% youtube ds-yEEYP1Ks %}\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is localization?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Localization is the process of adapting a product or service to meet the language, cultural, and other requirements of a specific country or region.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"Why is context important in translation?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Context provides additional information that can help translators understand the intended meaning of a word or phrase. Without context, translations can be inaccurate or unclear.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What is InContext view?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"InContext view is a feature of locize that enables users to connect content from their website/application directly with their content on their localization project on locize.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What is context in localization?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Context in localization refers to the circumstances, conditions, or background surrounding a word or phrase that contributes to its meaning. Without proper context, translators may misunderstand the intended message, leading to an inaccurate translation.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How does context affect translation accuracy?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Context plays a crucial role in accurately translating content. Without context, translators may misinterpret the meaning of a phrase, resulting in a less accurate translation. Some situations where context is particularly important include idiomatic expressions, cultural references, and technical terms.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What are the context features offered by locize to improve translation accuracy?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Locize offers several powerful features to help improve translation accuracy, including specific context information per segment, InContext view, terminology glossary, and screenshot feature.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How can users effectively use locize's context features?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"To use locize's context features effectively, users should provide as much context as possible. This can include providing background information on the product or service, identifying the intended audience, and giving clear instructions to the translation team. Users should also include screenshots or links where necessary, which can provide additional context that is not immediately apparent from the text.\"\n      }\n    }]\n  }\n</script>","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"}]},{"title":"Marketing localization in your business (2023 Guide)","slug":"localization-marketing","date":"un44fin44","updated":"un44fin44","comments":true,"path":"localization-marketing/","link":"","permalink":"https://locize.com/blog/localization-marketing/","excerpt":"","text":"Technology has accelerated globalization, allowing organizations to connect with customers across the world with ease. However, it can be tough to know where to start when it comes to implementing a localization marketing strategy. An older example, but still valid as it shows the importance of marketing localization, was that of Nokia. The company faced a major setback when introducing its Lumia phone in Spanish-speaking regions due to the product&#39;s name being colloquially associated with the term &quot;prostitute&quot; in Spanish. Today you are going to learn exactly how to avoid marketing-localization mistakes and how to implement a localization procedure in your business. Table of contents What is localization in marketing? Why is localization in global marketing important? How to implement marketing localization in your business Potential mistakes to avoid in global marketing localization Exploring successful global marketing campaigns: Examples from known brands How to measure global marketing efforts 7 steps for marketers and project managers to effectively localize their marketing content What is localization in marketing? Simply put, localization in marketing is the process of adapting your marketing material to ensure that it meets the interests and needs of your various target markets. Working across a global market means you will be interacting with different cultures and customer expectations. Being able to understand their needs will allow you to effectively translate your material and maximize your chances of converting leads into long-term customers. Why is localization in global marketing important? Did you know that 50% of online shoppers purchase something from a company that is outside their home country? While globalization is a wonderful way to increase your business, competition is also incredibly tough. Localization will help to give your brand the edge by ensuring you are reaching customers in their native language. Localization is much more than just translation, though. It is about using the cultural idioms, phrases, and symbolism, helping to increase trust and overall satisfaction. Process Purpose What is adapted Marketing Translation Create marketing messages that resonate in other markets Message (copy, text) Marketing Localization Create experiences that resonate in other markets Message, visuals, UX elements Localization Marketing Leverage localization for growth through a digital marketing strategy Systems and processes (to support the strategy) How to implement marketing localization in your business Now we have answered the question, “what is localization in marketing?” it is time to look at how you can begin to implement it into your business. This can seem a daunting process, but there are several steps to remember: 1. Hire the expertsWorking with professionals is one of the most important steps, as they will have a clear idea of your demographics, the language of your target audience, their culture, and the nuances that will make you sound like a local. 2. Localize your websiteAlongside your marketing materials, you should also localize your website. Over 75% of the world’s population does not speak English, so failing to optimize your website for non-English speakers will significantly restrict your reach and sales. 3. Humanize your brandAnother vital aspect of your localization marketing strategy should be humanizing your brand. When potential customers see your brand engaging in their language, using cultural elements, popular slang and words in their products and services, they are far more likely to complete their purchase. 4. Use local partnersInfluencers now play a major role in marketing campaigns for businesses across almost every industry. However, when it comes to localizing your marketing plan, you should look at the partners you are operating with and adapt accordingly to influencers in the local market. Potential mistakes to avoid in global marketing localization Despite its importance, there are many common mistakes that organizations make in their localization strategy, including: Focusing on a universal approach One of the most common mistakes is adopting a universal approach. Effective localization is not a one-size-fits-all and requires careful tailoring to ensure your brand is reaching the most effective touch points of your target market. Not localizing every aspect Another common mistake is only localizing certain aspects, such as print advertising. Neglecting certain areas, such as your socials or website, can lead to customers heading elsewhere. Poor translation Poor translation is another common mistake when it comes to marketing localization. Working with a professional localization partner will ensure that you are not using any embarrassing or incorrect phrasing. Exploring successful global marketing campaigns: Examples from known brands Transcreation is a term used in the advertising and marketing industry to refer to the process of adapting a message from one language and culture to another while maintaining the intended emotion, tone, and context of the original message. It goes beyond just translation as it involves the creative process of rewriting and adapting the message to fit the cultural and linguistic nuances of the target audience, while still conveying the same meaning and impact as the original message. Transcreation is especially important for global marketing campaigns, where the same message needs to be conveyed across different languages and cultures. It allows companies to effectively communicate their brand message and values to a global audience, while also respecting the unique cultural differences and nuances of each region. When done effectively, a global marketing campaign can transform a business and propel them onto success. Some great examples include: Red Bull One of the leading brands in the world, Red Bull can often feel like a local company. Their support of local sporting events, from F1 to Soapbox races, ensures they are continuously being placed in front of their relevant audience. Airbnb Since its launch in 2008, Airbnb has grown from its San Francisco base to become one of the most recognized businesses in the world. Its “Made Possible By Hosts” campaign brought the company into the homes of potential customers across the globe. McDonald’s The iconic golden arches of McDonald’s are recognized across the globe, and its marketing efforts are one of the best examples of localization. While the colors and themes remain similar, the fast food chain focuses on using region-specific menus; for instance, the use of flatbreads in the Middle East or Macaroons in France. How to measure global marketing efforts While there can be no denying the benefits that come from marketing localization, it is vital that you are effectively measuring your results. In order to determine your performance, you should first set yourself some clear goals of what you want to achieve and by when. This will act as your benchmark and will allow you to track whether you are on course to achieve them. Of course, one of the biggest factors to consider is your ROI. In this &quot;what is Marketing ROI-guide&quot; you will find more information about how to measure it. This is a very effective method of understanding the efficiency of your global marketing efforts as there is a clear correlation between your activities and sales. You should also regularly assess your results. Source: 20 Marketing KPIs You Need to Be Monitoring Progress and effectiveness in achieving key business objectives can be measured with the help of Key Performance Indicators (KPIs). Low-level KPIs focus on processes within departments such as marketing, sales, and HR. The following global marketing KPIs can be used to assess marketing effectiveness and plan strategies and budgets for upcoming periods: KPI Purpose Sales Growth Measures the effectiveness of marketing strategies by looking at how much of the total revenue was influenced by marketing efforts. Lifetime Value of a Customer Tracks the revenue a business can expect from one customer over a lifespan. Cost of Customer Acquisition (CAC) Measures the cost of acquiring a new customer. Customer Retention Measures how many customers continue to use the company&#39;s product or service. Net Promoter Score (NPS) Measures customer loyalty and satisfaction. Digital Marketing ROI Assesses monthly and annual performance to help plan strategies and budgets for upcoming periods. Leads Indicates the number of sales opportunities and a better chance of sales growth. Website Traffic to Website Lead Ratio Measures how many website visitors are converted into leads and indicates the quality of website traffic. Website Lead to Marketing Qualified Lead (MQL) Ratio Indicates the number of total leads generated by the website that are promoted to Marketing Qualified Lead. Click-Through Rate (CTR) Measures the number of clicks on a link compared to the number of impressions. Organic Search Traffic Measures the number of people finding the company&#39;s website through organic search results. 7 steps for marketers and project managers to effectively localize their marketing content 1. Select your target market: Before starting the process of marketing localization, you need to identify the specific market you want to target. This involves understanding the cultural, linguistic, and other unique factors of the new market. 2. Analyze and adapt your message: Once you have identified your target market, you need to analyze and adapt your message to fit the new market. This may involve changing the tone, language, and even the content of your message to be more relevant and engaging for your new audience. 3. Assemble a team of local translators: To ensure the accuracy and cultural sensitivity of your message, you need to assemble a team of local translators who can translate and localize your content into the native language of your target market. This team should be well-versed in the nuances of the language and culture of the market. 4. Hire a localization expert or project manager: To oversee the entire process of marketing localization, you should hire a localization expert or project manager. This person will be responsible for ensuring that the localization process is executed efficiently and effectively, and that the end result is of high quality. 5. Use a modern localization platform: To streamline your marketing localization efforts, you should use a modern and lightweight translation management system . This platform can help automate routine tasks and provide a single source of truth for all things localization, which allows for efficient collaboration, management, and review of translations. 6. Customize the workflow: By customizing the workflow, you can build a process that works for your team and use a dashboard to maintain it. This can help you achieve consistency in tone of voice and messaging through an updated glossary and translation memory. 7. Take advantage of platform features: To eliminate idle waiting time and streamline your marketing localization efforts, you should take advantage of platform features such as version control, chained tasks, and insights into bottlenecks. This can help you stay on top of your localization project and ensure that it is completed on time and to a high standard.","raw":"---\ntitle: Marketing localization in your business (2023 Guide)\ndescription: With this ultimate guide, you will transform your global marketing efforts and discover the significance of marketing localization.\n\ndate: 2023-03-23\ntags: \n  - marketing campaigns\n  - products\n  - brand\n  - competitors\n  - cultures\n  - markets\nthumbnail: localization-marketing/localization-marketing-thumbnail.webp\n\nlabel: marketing-localization\nlang: en\n---\n\n\n![localization marketing](marketing-localization-illustration.webp)\n\n\nTechnology has accelerated globalization, allowing organizations to connect with customers across the world with ease. However, it can be tough to know where to start when it comes to implementing a localization marketing strategy. \n\nAn older example, but still valid as it shows the importance of marketing localization, was that of Nokia. The company faced a major setback when introducing its [Lumia phone in Spanish-speaking regions](https://www.cnet.com/culture/nokias-lumia-means-um-prostitute-in-spanish/) due to the product's name being colloquially associated with the term \"prostitute\" in Spanish. \n\nToday you are going to learn exactly how to avoid marketing-localization mistakes and how to implement a localization procedure in your business.\n\n\n## Table of contents\n  * [What is localization in marketing?](#marketinglocalization)\n  * [Why is localization in global marketing important?](#importance)\n  * [How to implement marketing localization in your business](#yourbusiness)\n  * [Potential mistakes to avoid in global marketing localization](#mistakes)\n  * [Exploring successful global marketing campaigns: Examples from known brands](#globalexamples)\n  * [How to measure global marketing efforts](#measure)\n  * [7 steps for marketers and project managers to effectively localize their marketing content](#7steps)\n\n\n## What is localization in marketing? <a name=\"marketinglocalization\"></a>\nSimply put, localization in marketing is the process of adapting your marketing material to ensure that it meets the interests and needs of your various target markets. \n\nWorking across a global market means you will be interacting with different cultures and customer expectations. Being able to understand their needs will allow you to effectively translate your material and maximize your chances of converting leads into long-term customers. \n\n\n \n## Why is localization in global marketing important? <a name=\"importance\"></a>\n\nDid you know that 50% of <a href=\"https://www.shopify.com/enterprise/global-ecommerce-statistics\" title=\"online shoppers\">online shoppers</a> purchase something from a company that is outside their home country? While globalization is a wonderful way to increase your business, competition is also incredibly tough. \n\n<a href=\"../localization/\" title=\"Localization\">Localization</a> will help to give your brand the edge by ensuring you are reaching customers in their native language. Localization is much more than just translation, though. It is about using the cultural idioms, phrases, and symbolism, helping to increase trust and overall satisfaction.\n\n\n| Process | Purpose | What is adapted |\n| -------| ------- | ---------------|\n| Marketing Translation | Create marketing messages that resonate in other markets | Message (copy, text) |\n| Marketing Localization | Create experiences that resonate in other markets | Message, visuals, UX elements |\n| Localization Marketing | Leverage localization for growth through a digital marketing strategy | Systems and processes (to support the strategy) |\n\n\n\n## How to implement marketing localization in your business <a name=\"yourbusiness\"></a>\nNow we have answered the question, “what is localization in marketing?” it is time to look at how you can begin to implement it into your business. This can seem a daunting process, but there are several steps to remember:\n\n**1. Hire the experts**  \nWorking with professionals is one of the most important steps, as they will have a clear idea of your demographics, the language of your target audience, their culture, and the nuances that will make you sound like a local.\n\n**2. Localize your website**  \nAlongside your marketing materials, you should also localize your website. [Over 75%](https://www.english.com/blog/english-language-internet/) of the world’s population does not speak English, so failing to optimize your website for non-English speakers will significantly restrict your reach and sales. \n\n**3. Humanize your brand**  \nAnother vital aspect of your localization marketing strategy should be humanizing your brand. When potential customers see your brand engaging in their language, using cultural elements, popular slang and words in their products and services, they are far more likely to complete their purchase.\n\n**4. Use local partners**   \nInfluencers now play a major role in marketing campaigns for businesses across almost every industry. However, when it comes to localizing your marketing plan, you should look at the partners you are operating with and adapt accordingly to influencers in the local market. \n\n\n\n## Potential mistakes to avoid in global marketing localization <a name=\"mistakes\"></a>\n\nDespite its importance, there are many common mistakes that organizations make in their localization strategy, including:\n\n**Focusing on a universal approach**\nOne of the most common mistakes is adopting a universal approach. Effective localization is not a one-size-fits-all and requires careful tailoring to ensure your brand is reaching the most effective touch points of your target market.\n\n**Not localizing every aspect**\nAnother common mistake is only localizing certain aspects, such as print advertising. Neglecting certain areas, such as your socials or website, can lead to customers heading elsewhere. \n\n**Poor translation** \nPoor translation is another common mistake when it comes to marketing localization. Working with a professional localization partner will ensure that you are not using any embarrassing or incorrect phrasing. \n\n[![Easily Create Prototypes for Multilingual Interfaces](prototyping-for-global-audience.webp)](https://docs.locize.com/more/figma-plugin)\n\n## Exploring successful global marketing campaigns: Examples from known brands <a name=\"globalexamples\"></a>\n\nTranscreation is a term used in the advertising and marketing industry to refer to the process of adapting a message from one language and culture to another while maintaining the intended emotion, tone, and context of the original message. \n\nIt goes beyond just translation as it involves the creative process of rewriting and adapting the message to fit the cultural and linguistic nuances of the target audience, while still conveying the same meaning and impact as the original message.\n\nTranscreation is especially important for global marketing campaigns, where the same message needs to be conveyed across different languages and cultures. It allows companies to effectively communicate their brand message and values to a global audience, while also respecting the unique cultural differences and nuances of each region.\n\nWhen done effectively, a global marketing campaign can transform a business and propel them onto success. Some great examples include:\n\n**Red Bull**\nOne of the leading brands in the world, Red Bull can often feel like a local company. Their support of local sporting events, from F1 to Soapbox races, ensures they are continuously being placed in front of their relevant audience. \n\n**Airbnb** \nSince its launch in 2008, Airbnb has grown from its San Francisco base to become one of the most recognized businesses in the world. Its [“Made Possible By Hosts”](https://www.linkedin.com/pulse/made-possible-hosts-airbnb-linh-lai) campaign brought the company into the homes of potential customers across the globe. \n\n**McDonald’s**\nThe iconic golden arches of McDonald’s are recognized across the globe, and its marketing efforts are one of the best examples of localization. While the colors and themes remain similar, the fast food chain focuses on using region-specific menus; for instance, the use of flatbreads in the Middle East or Macaroons in France.  \n\n\n## How to measure global marketing efforts <a name=\"measure\"></a>\nWhile there can be no denying the benefits that come from marketing localization, it is vital that you are effectively measuring your results. \n\nIn order to determine your performance, you should first set yourself some clear goals of what you want to achieve and by when. This will act as your benchmark and will allow you to track whether you are on course to achieve them. \n\nOf course, one of the biggest factors to consider is your ROI.\n\nIn this <a href=\"https://hbr.org/2017/07/a-refresher-on-marketing-roi\" title=\"what is Marketing ROI-guide\">\"what is Marketing ROI-guide\"</a> you will find more information about how to measure it.\n\nThis is a very effective method of understanding the efficiency of your global marketing efforts as there is a clear correlation between your activities and sales. You should also regularly assess your results. \n\n\n![global marketing key performance indicators](kpi-global-marketing.webp)\n<span style=\"font-size:0.7rem\">Source: <a href=\"https://www.semrush.com/blog/kpi-marketing/\" title=\"s\">20 Marketing KPIs You Need to Be Monitoring</a></span>\n\nProgress and effectiveness in achieving key business objectives can be measured with the help of Key Performance Indicators (KPIs). Low-level KPIs focus on processes within departments such as marketing, sales, and HR. \n\nThe following global marketing KPIs can be used to assess marketing effectiveness and plan strategies and budgets for upcoming periods:\n\n| KPI | Purpose |\n| --- | ------- |\n| Sales Growth | Measures the effectiveness of marketing strategies by looking at how much of the total revenue was influenced by marketing efforts. |\n| Lifetime Value of a Customer | Tracks the revenue a business can expect from one customer over a lifespan. |\n| Cost of Customer Acquisition (CAC) | Measures the cost of acquiring a new customer. |\n| Customer Retention | Measures how many customers continue to use the company's product or service. |\n| Net Promoter Score (NPS) | Measures customer loyalty and satisfaction. |\n| Digital Marketing ROI | Assesses monthly and annual performance to help plan strategies and budgets for upcoming periods. |\n| Leads | Indicates the number of sales opportunities and a better chance of sales growth. |\n| Website Traffic to Website Lead Ratio | Measures how many website visitors are converted into leads and indicates the quality of website traffic. |\n| Website Lead to Marketing Qualified Lead (MQL) Ratio | Indicates the number of total leads generated by the website that are promoted to Marketing Qualified Lead. |\n| Click-Through Rate (CTR) | Measures the number of clicks on a link compared to the number of impressions. |\n| Organic Search Traffic | Measures the number of people finding the company's website through organic search results. |\n\n\n\n## 7 steps for marketers and project managers to effectively localize their marketing content <a name=\"7steps\"></a>\n \n\n**1. Select your target market:** Before starting the process of marketing localization, you need to identify the specific market you want to target. This involves understanding the cultural, linguistic, and other unique factors of the new market.\n\n**2. Analyze and adapt your message:** Once you have identified your target market, you need to analyze and adapt your message to fit the new market. This may involve changing the tone, language, and even the content of your message to be more relevant and engaging for your new audience.\n\n**3. Assemble a team of local translators:** To ensure the accuracy and cultural sensitivity of your message, you need to assemble a team of local translators who can translate and localize your content into the native language of your target market. This team should be well-versed in the nuances of the language and culture of the market.\n\n**4. Hire a localization expert or project manager:** To oversee the entire process of marketing localization, you should hire a localization expert or project manager. This person will be responsible for ensuring that the localization process is executed efficiently and effectively, and that the end result is of high quality.\n\n**5. Use a modern localization platform:** To streamline your marketing localization efforts, you should use a modern and lightweight <a href=\"../tms/\" title=\"translation management system\">translation management system</a> . This platform can help automate routine tasks and provide a single source of truth for all things localization, which allows for efficient collaboration, management, and review of translations.\n\n**6. Customize the workflow:** By customizing the workflow, you can build a process that works for your team and use a dashboard to maintain it. This can help you achieve consistency in tone of voice and messaging through an updated glossary and translation memory.\n\n**7. Take advantage of platform features:** To eliminate idle waiting time and streamline your marketing localization efforts, you should take advantage of platform features such as version control, chained tasks, and insights into bottlenecks. This can help you stay on top of your localization project and ensure that it is completed on time and to a high standard.\n","categories":[],"tags":[{"name":"marketing campaigns","slug":"marketing-campaigns","permalink":"https://locize.com/blog/tags/marketing-campaigns/"},{"name":"products","slug":"products","permalink":"https://locize.com/blog/tags/products/"},{"name":"brand","slug":"brand","permalink":"https://locize.com/blog/tags/brand/"},{"name":"competitors","slug":"competitors","permalink":"https://locize.com/blog/tags/competitors/"},{"name":"cultures","slug":"cultures","permalink":"https://locize.com/blog/tags/cultures/"},{"name":"markets","slug":"markets","permalink":"https://locize.com/blog/tags/markets/"}]},{"title":"The Role of i18next and Translation Management Systems in Serverless Architectures","slug":"i18n-serverless","date":"un22fin22","updated":"un22fin22","comments":true,"path":"i18n-serverless/","link":"","permalink":"https://locize.com/blog/i18n-serverless/","excerpt":"","text":"In today&#39;s globalized world, localization has become a vital factor in ensuring business success. Customers prefer to interact with products and services in their native language, and businesses need to adapt to this demand. With the emergence of Serverless Architectures, it has become easier for developers to build and deploy applications without worrying about infrastructure management. But how can businesses ensure that their serverless applications are multilingual? In this article, we&#39;ll explore the role of i18next and TMS in serverless architectures and how they can help businesses build and deploy multilingual serverless applications. What is Serverless Architecture?Serverless architecture is a cloud computing model where the cloud provider manages the infrastructure and automatically allocates resources as needed. It&#39;s a pay-per-use model, where businesses only pay for the actual usage of the application. Developers can focus on writing code and building applications without worrying about infrastructure management, scalability, and availability. What is i18next?i18next is an open-source internationalization framework for JavaScript that provides a complete solution for managing translations in web applications. It&#39;s lightweight and easy to integrate into serverless applications. i18next allows developers to organize translations into files, use interpolation, pluralization, and format translations based on the user&#39;s locale. i18next also has support for popular frontend frameworks such as React, Angular and Vue, etc. The Challenges of Multilingual Serverless ApplicationsOne of the biggest challenges of building multilingual serverless applications is managing translations. Applications that are built for a global audience require content to be translated into multiple languages. Manually managing translations can be a daunting task, as it involves managing multiple translation files, keeping track of translations, and ensuring consistency across languages. Additionally, deploying multiple versions of the application for each language can be a logistical nightmare, especially if you have to manage multiple tiny parts like AWS Lambda functions. For classic web applications, you usually have 2 parts where internationalization tasks occur: The client side (usually some modern single page app) and the server side. The translation resources are usually stored in the same place, so that the client and the server can read them. In case of i18next, the client can access them useing i18next-http-backend and the server can access them using i18next-fs-backend. Here is an example of what this might look like on the client side. Here for an example of how this could look on the server side. But for serverless environments, you may have multiple clients, and you may have multiple small serverless functions that respond to a request in the appropriate language, or send some emails in the user&#39;s preferred language, and so on. Serverless E-MailsLet&#39;s think about a serverless function that generates and sends some emails. For example we want to send an invitation to someone. We need the email address, the recipient&#39;s preferred language, an email template and some translations. To achieve this goal, you usually need to transform some raw data into html content (or text) to be displayed in the user&#39;s preferred language. In this example we will use pug (formerly known as &quot;Jade&quot;, and also originally created by TJ Holowaychuk) to define some templates that should be filled with the data needed in the email, and mjml to actually design the email content. Let&#39;s create a new mail.js file, which we can use, to accomplish this. 1234567891011121314import pug from &#x27;pug&#x27;import mjml2html from &#x27;mjml&#x27;export default (data) =&gt; &#123; // first let&#x27;s compile and render the mail template that will include the data needed to show in the mail content const mjml = pug.renderFile(&#x27;./mailTemplate.pug&#x27;, data) // then transform the mjml syntax to normal html const &#123; html, errors &#125; = mjml2html(mjml) if (errors &amp;&amp; errors.length &gt; 0) throw new Error(errors[0].message) // and return the html, if there where no errors return html&#125; The mailTemplate.pug could look like this: 123456789101112131415161718192021mjml mj-body(background-color=&#x27;#F4F4F4&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27;) mj-section(background-color=&#x27;#024b3f&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-image(align=&#x27;center&#x27; padding=&#x27;10px 25px&#x27; src=&#x27;https://raw.githubusercontent.com/i18next/i18next/master/assets/i18next-ecosystem.jpg&#x27;) mj-section(background-color=&#x27;#ffffff&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-section(background-color=&#x27;#ffffff&#x27; background-repeat=&#x27;repeat&#x27; background-size=&#x27;auto&#x27; padding=&#x27;20px 0px 20px 0px&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-text(align=&#x27;center&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;20px&#x27; line-height=&#x27;28px&#x27; padding=&#x27;0px 25px 0px 25px&#x27;) span=t(&#x27;greeting&#x27;, &#123; name: name || &#x27;there&#x27; &#125;) br br mj-text(align=&#x27;center&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;16px&#x27; line-height=&#x27;28px&#x27; padding=&#x27;0px 25px 0px 25px&#x27;) =t(&#x27;text&#x27;) mj-section(background-color=&#x27;#024b3f&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-text(align=&#x27;center&#x27; color=&#x27;#ffffff&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;13px&#x27; line-height=&#x27;22px&#x27; padding=&#x27;10px 25px&#x27;) =t(&#x27;ending&#x27;)&amp;nbsp; a(style=&#x27;color:#ffffff&#x27; href=&#x27;https://www.i18next.com&#x27;) b www.i18next.com Now let&#39;s define some translations... 12345678910111213// locales/en/translations.json&#123; &quot;greeting&quot;: &quot;Hi &#123;&#123;name&#125;&#125;!&quot;, &quot;text&quot;: &quot;You were invited to try i18next.&quot;, &quot;ending&quot;: &quot;Internationalized with&quot;&#125;// locales/de/translations.json&#123; &quot;greeting&quot;: &quot;Hallo &#123;&#123;name&#125;&#125;!&quot;, &quot;text&quot;: &quot;Du bist eingeladen worden i18next auszuprobieren.&quot;, &quot;ending&quot;: &quot;Internationalisiert mit&quot;&#125; ...and use them in an i18n.js file: 1234567891011121314151617181920212223242526import &#123; dirname, join &#125; from &#x27;path&#x27;import &#123; readdirSync, lstatSync &#125; from &#x27;fs&#x27;import &#123; fileURLToPath &#125; from &#x27;url&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-fs-backend&#x27;const __dirname = dirname(fileURLToPath(import.meta.url))const localesFolder = join(__dirname, &#x27;./locales&#x27;)i18next .use(Backend) .init(&#123; // debug: true, initImmediate: false, // setting initImediate to false, will load the resources synchronously fallbackLng: &#x27;en&#x27;, preload: readdirSync(localesFolder).filter((fileName) =&gt; &#123; const joinedPath = join(localesFolder, fileName) return lstatSync(joinedPath).isDirectory() &#125;), ns: &#x27;news-mailer&#x27;, backend: &#123; loadPath: join(localesFolder, &#x27;&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125; &#125;)export default (lng) =&gt; i18next.getFixedT(lng) So finally, all the above can be used like that: 1234567891011import mail from &#x27;./mail.js&#x27;import getT from &#x27;./i18n.js&#x27;const t = getT(&#x27;en&#x27;)const html = mail(&#123; t, name: &#x27;John&#x27;&#125;)// that html now can be sent via some mail provider...// await send(&#x27;john@example.com&#x27;, t(&#x27;subject&#x27;), html) This is how the resulting html could look like: 🧑‍💻 A code example can be found here. Translation Management Systems in Serverless ArchitectureOk, i18next seems to be able to handle these i18n tasks. But what about managing of all those translation files in these different serverless functions and also in the different clients? There&#39;s no central location anymore - it&#39;s all distributed. We need a solution for that! We need a Translation Management System. A Translation Management System (TMS) is a software platform that enables businesses to manage their translation workflow. It provides a central repository for storing translations and enables collaboration between translators. When integrated with i18next, TMS such as locize can streamline the localization process in a serverless architecture. Here are some of the benefits of using a TMS integrated with i18next in a serverless architecture: Automatic updates of translationsWhen using a TMS, translations can be automatically updated whenever a new language is added or an existing translation is changed. This eliminates the need to manually update the translations in the codebase, which can be a time-consuming task. Improved scalabilityA TMS can handle translation requests from multiple applications and languages, making it easy to scale the localization process. By integrating a TMS with i18next, businesses can easily manage translations for multiple applications without worrying about the scalability of the translation process. Reduced costsBy using a TMS, businesses can reduce the cost of managing translations. A TMS provides a central repository for storing translations, eliminating the need to manage translations in multiple codebases. This reduces the time and effort required to manage translations, resulting in lower costs. Improved securityA TMS provides a secure environment for storing translations, making it easy to manage translations without worrying about security concerns. By using a TMS integrated with i18next, businesses can ensure that their translations are stored securely and are only accessible by authorized personnel. Implementing Possible Approaches for TMS with i18nextClient sideFor the client side it&#39;s that we can go full steam ahead. We can live download the translations on demand directly from the locize CDN. This way we can change translations or add new languages directly in locize without having to modify or redeploy the client app. In addition, we can unleash a lot of extra features to speed up the localization process. For example: We can use the saveMissing feature to add new keys and automatically translate them with machine translation. We can find and filter in locize which keys are used or not used anymore, thanks to the last-used plugin. We can find and edit translations directly in the In-Context editor. Have a look at this tutorial or this video to just see just a few of these cool things. Server(less) sideFor the serverless side we could trigger a new serverless deployment every time a new translation version is published. Using webhook events or triggering a Github Action via GitHub Repository Dispatch Event. Or download the latest translations each time a serverless function is built and deployed using the locize-cli or with the Github Action. 12# i.e. for our email example, that we implementedlocize download --project-id=3183fd58-99d0-4d4b-896d-5768ca438c24 --ver=latest --namespace=news-mailer --clean=true --path=./locales ConclusionIn summary, i18next and a translation management system like locize are powerful tools for managing translations in a serverless architecture. By integrating i18next with a TMS, businesses can streamline the localization process and reduce the cost of managing translations. The integration also provides improved scalability and security. Enterprises and developers can easily implement a TMS integrated with i18next in their serverless architecture by following the steps outlined above. If you&#39;re already using i18next and want to unleash its full potential, have a look at this. If you&#39;re new to i18next, have a look at this guide and check out the free crash course. If you want to see a nice overview of the different i18n formats, have a look at this. If you like to see how locize looks like, check out this video and try the free trial. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\" } }, { \"@type\": \"Question\", \"name\": \"What is serverless architecture?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Serverless architecture is a cloud computing model where the cloud provider manages the infrastructure and automatically allocates resources as needed. Developers can focus on writing code and building applications without worrying about infrastructure management, scalability, and availability. It's a pay-per-use model, where businesses only pay for the actual usage of the application.\" } }, { \"@type\": \"Question\", \"name\": \"What are the challenges of building multilingual serverless applications?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"One of the biggest challenges of building multilingual serverless applications is managing translations. Applications that are built for a global audience require content to be translated into multiple languages. Manually managing translations can be a daunting task, as it involves managing multiple translation files, keeping track of translations, and ensuring consistency across languages. Additionally, deploying multiple versions of the application for each language can be a logistical nightmare, especially if you have to manage multiple tiny parts like AWS Lambda functions.\" } }, { \"@type\": \"Question\", \"name\": \"What are the Translation Management Systems (TMS) in Serverless Architecture?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"A Translation Management System (TMS) is a software platform that enables businesses to manage their translation workflow. It provides a central repository for storing translations and enables collaboration among translators. When integrated with i18next, TMS like locize can streamline the localization process in a serverless architecture. Some of the benefits of using a TMS integrated with i18next in serverless architecture include automatic updates of translations, centralized translation management, and easier collaboration among translators.\" } }, { \"@type\": \"Question\", \"name\": \"How can businesses ensure that their serverless applications are multilingual?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Businesses can ensure that their serverless applications are multilingual by using i18next and TMS in serverless architecture. i18next is an internationalization framework that allows developers to manage translations in web applications. TMS provides a central repository for storing translations and enables collaboration among translators. By integrating i18next and TMS, businesses can streamline the localization process in a serverless architecture, automate the updates of translations, and ensure consistency across languages.\" } }] }","raw":"---\ntitle: The Role of i18next and Translation Management Systems in Serverless Architectures\ndescription: The article discusses the role of i18next and Translation Management Systems in serverless architecture for efficient and cost-effective localization.\n\ndate: 2023-03-07\ntags:\n  - i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\n  - serverless\n  - aws\nthumbnail: i18n-serverless/title.jpg\n\nlabel: i18n-serverless\nlang: en\n---\n\n![](title.jpg)\n\nIn today's globalized world, localization has become a vital factor in ensuring business success. Customers prefer to interact with products and services in their native language, and businesses need to adapt to this demand.\nWith the emergence of Serverless Architectures, it has become easier for developers to build and deploy applications without worrying about infrastructure management. But how can businesses ensure that their serverless applications are multilingual? In this article, we'll explore the role of [i18next](https://www.i18next.com) and [TMS](../tms/) in serverless architectures and how they can help businesses build and deploy multilingual serverless applications.\n\n\n## What is Serverless Architecture?\n\nServerless architecture is a cloud computing model where the cloud provider manages the infrastructure and automatically allocates resources as needed. It's a pay-per-use model, where businesses only pay for the actual usage of the application. Developers can focus on writing code and building applications without worrying about infrastructure management, scalability, and availability.\n\n## What is i18next?\n\ni18next is an open-source internationalization framework for JavaScript that provides a complete solution for managing translations in web applications. It's lightweight and easy to integrate into serverless applications. i18next allows developers to organize translations into files, use interpolation, pluralization, and format translations based on the user's locale. i18next also has support for popular frontend frameworks such as [React](../react-i18next/), [Angular](../angular-i18next/) and [Vue](../i18next-vue/), etc.\n\n\n## The Challenges of Multilingual Serverless Applications\n\nOne of the biggest challenges of building multilingual serverless applications is managing translations. Applications that are built for a global audience require content to be translated into multiple languages. Manually managing translations can be a daunting task, as it involves managing multiple translation files, keeping track of translations, and ensuring consistency across languages. Additionally, deploying multiple versions of the application for each language can be a logistical nightmare, especially if you have to manage multiple tiny parts like [AWS Lambda](https://aws.amazon.com/lambda/) functions.\n\nFor classic web applications, you usually have 2 parts where internationalization tasks occur: The client side (usually some modern single page app) and the server side.\nThe translation resources are usually stored in the same place, so that the client and the server can read them. In case of i18next, the client can access them useing [i18next-http-backend](https://github.com/i18next/i18next-http-backend) and the server can access them using [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend).\n\n- [Here](../react-i18next/#separate) is an example of what this might look like on the client side.\n- [Here](../how-does-server-side-internationalization-look-like/#pug) for an example of how this could look on the server side.\n\nBut for serverless environments, you may have multiple clients, and you may have multiple small serverless functions that respond to a request in the appropriate language, or send some emails in the user's preferred language, and so on.\n\n\n## Serverless E-Mails\n\nLet's think about a serverless function that generates and sends some emails.\nFor example we want to send an invitation to someone.\nWe need the email address, the recipient's preferred language, an email template and some translations.\n\nTo achieve this goal, you usually need to transform some raw data into html content (or text) to be displayed in the user's preferred language.\n\nIn this example we will use [pug](https://pugjs.org) (formerly known as \"Jade\", and also originally created by [TJ Holowaychuk](https://twitter.com/tjholowaychuk)) to define some templates that should be filled with the data needed in the email, and [mjml](https://mjml.io) to actually design the email content.\n\nLet's create a new `mail.js` file, which we can use, to accomplish this.\n\n```javascript\nimport pug from 'pug'\nimport mjml2html from 'mjml'\n\nexport default (data) => {\n  // first let's compile and render the mail template that will include the data needed to show in the mail content\n  const mjml = pug.renderFile('./mailTemplate.pug', data)\n  \n  // then transform the mjml syntax to normal html\n  const { html, errors } = mjml2html(mjml)\n  if (errors && errors.length > 0) throw new Error(errors[0].message)\n\n  // and return the html, if there where no errors\n  return html\n}\n```\n\nThe `mailTemplate.pug` could look like this:\n\n```jade\nmjml\n  mj-body(background-color='#F4F4F4' color='#55575d' font-family='Arial, sans-serif')\n    mj-section(background-color='#024b3f' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n        mj-image(align='center' padding='10px 25px' src='https://raw.githubusercontent.com/i18next/i18next/master/assets/i18next-ecosystem.jpg')\n    mj-section(background-color='#ffffff' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n    mj-section(background-color='#ffffff' background-repeat='repeat' background-size='auto' padding='20px 0px 20px 0px' text-align='center' vertical-align='top')\n      mj-column\n        mj-text(align='center' color='#55575d' font-family='Arial, sans-serif' font-size='20px' line-height='28px' padding='0px 25px 0px 25px')\n          span=t('greeting', { name: name || 'there' })\n          br\n          br\n        mj-text(align='center' color='#55575d' font-family='Arial, sans-serif' font-size='16px' line-height='28px' padding='0px 25px 0px 25px')\n          =t('text')\n    mj-section(background-color='#024b3f' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n        mj-text(align='center' color='#ffffff' font-family='Arial, sans-serif' font-size='13px' line-height='22px' padding='10px 25px')\n          =t('ending')&nbsp;\n          a(style='color:#ffffff' href='https://www.i18next.com')\n            b www.i18next.com\n```\n\nNow let's define some translations...\n\n```javascript\n// locales/en/translations.json\n{\n  \"greeting\": \"Hi {{name}}!\",\n  \"text\": \"You were invited to try i18next.\",\n  \"ending\": \"Internationalized with\"\n}\n\n// locales/de/translations.json\n{\n  \"greeting\": \"Hallo {{name}}!\",\n  \"text\": \"Du bist eingeladen worden i18next auszuprobieren.\",\n  \"ending\": \"Internationalisiert mit\"\n}\n```\n\n...and use them in an `i18n.js` file:\n\n```javascript\nimport { dirname, join } from 'path'\nimport { readdirSync, lstatSync } from 'fs'\nimport { fileURLToPath } from 'url'\nimport i18next from 'i18next'\nimport Backend from 'i18next-fs-backend'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst localesFolder = join(__dirname, './locales')\n\ni18next\n  .use(Backend)\n  .init({\n    // debug: true,\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    fallbackLng: 'en',\n    preload: readdirSync(localesFolder).filter((fileName) => {\n      const joinedPath = join(localesFolder, fileName)\n      return lstatSync(joinedPath).isDirectory()\n    }),\n    ns: 'news-mailer',\n    backend: {\n      loadPath: join(localesFolder, '{{lng}}/{{ns}}.json')\n    }\n  })\n\nexport default (lng) => i18next.getFixedT(lng)\n```\n\nSo finally, all the above can be used like that:\n\n```javascript\nimport mail from './mail.js'\nimport getT from './i18n.js'\n\nconst t = getT('en')\n\nconst html = mail({\n  t,\n  name: 'John'\n})\n// that html now can be sent via some mail provider...\n// await send('john@example.com', t('subject'), html)\n```\n\nThis is how the resulting html could look like:\n\n![mail preview](mail_preview.jpg)\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-fs-backend/blob/master/example/fastify/app.js#L14-L19).*\n\n\n## Translation Management Systems in Serverless Architecture\n\nOk, i18next seems to be able to handle these i18n tasks. But what about managing of all those translation files in these different serverless functions and also in the different clients?\nThere's no central location anymore - it's all distributed.\n<br />\nWe need a solution for that! We need a [Translation Management System](../i18n-l10n-t9n-tms/).\n\nA Translation Management System ([TMS](../tms/)) is a software platform that enables businesses to manage their translation workflow. It provides a central repository for storing translations and enables collaboration between translators. When integrated with i18next, TMS such as [locize](/) can streamline the localization process in a serverless architecture. Here are some of the benefits of using a TMS integrated with i18next in a serverless architecture:\n\n### Automatic updates of translations\nWhen using a TMS, translations can be automatically updated whenever a new language is added or an existing translation is changed. This eliminates the need to manually update the translations in the codebase, which can be a time-consuming task.\n\n### Improved scalability\nA TMS can handle translation requests from multiple applications and languages, making it easy to scale the localization process. By integrating a TMS with i18next, businesses can easily manage translations for multiple applications without worrying about the scalability of the translation process.\n\n### Reduced costs\nBy using a TMS, businesses can reduce the cost of managing translations. A TMS provides a central repository for storing translations, eliminating the need to manage translations in multiple codebases. This reduces the time and effort required to manage translations, resulting in lower costs.\n\n### Improved security\nA TMS provides a secure environment for storing translations, making it easy to manage translations without worrying about security concerns. By using a TMS integrated with i18next, businesses can ensure that their translations are stored securely and are only accessible by authorized personnel.\n\n\n## Implementing Possible Approaches for TMS with i18next\n\n### Client side\n\nFor the client side it's that we can go full steam ahead. We can live download the translations on demand directly from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network). This way we can change translations or add new languages directly in locize without having to modify or redeploy the client app.\n\nIn addition, we can unleash a lot of extra features to speed up the localization process. For example:\n- We can use the [saveMissing](../i18next-migrate/#save-missing) feature to add new keys and automatically translate them with machine translation.\n- We can [find and filter](https://docs.locize.com/guides-tips-and-tricks/unused-translations) in locize which keys are used or not used anymore, thanks to the [last-used](https://github.com/locize/locize-lastused) plugin.\n- We can find and edit translations directly in the [In-Context editor](https://docs.locize.com/more/incontext-editor).\n\nHave a look at [this tutorial](../react-i18next/) or [this video](https://youtu.be/jeRxew3OV64) to just see just a few of these cool things.\n\n{% youtube jeRxew3OV64 %}\n\n\n### Server(less) side\n\nFor the serverless side we could trigger a new serverless deployment every time a new [translation version](https://docs.locize.com/more/versioning) is published. Using [webhook events](https://docs.locize.com/integration/webhook#versionpublished) or triggering a Github Action via [GitHub Repository Dispatch Event](https://docs.locize.com/integration/github-repository-dispatch-event).\n\nOr download the latest translations each time a serverless function is built and deployed using the [locize-cli](https://github.com/locize/locize-cli#download-current-published-files) or with the [Github Action](https://github.com/marketplace/actions/locize-download).\n\n```sh\n# i.e. for our email example, that we implemented\nlocize download --project-id=3183fd58-99d0-4d4b-896d-5768ca438c24 --ver=latest --namespace=news-mailer --clean=true --path=./locales\n```\n\n\n## Conclusion\n\nIn summary, i18next and a translation management system like locize are powerful tools for managing translations in a serverless architecture. By integrating i18next with a TMS, businesses can streamline the localization process and reduce the cost of managing translations. The integration also provides improved scalability and security. Enterprises and developers can easily implement a TMS integrated with i18next in their serverless architecture by following the steps outlined above.\n\n\n- *If you're already using i18next and want to unleash its full potential, have a look at [this](../i18next-migrate/).*\n- *If you're new to i18next, have a look at [this guide](../react-i18next/) and check out the free [crash course](https://youtu.be/SA_9i4TtxLQ).*\n- *If you want to see a nice overview of the different i18n formats, have a look at [this](../i18n-formats-javascript/).*\n- *If you like to see how locize looks like, check out [this video](https://youtu.be/ds-yEEYP1Ks) and try the [free trial](https://www.locize.app/register).*\n\n{% youtube ds-yEEYP1Ks %}\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What is serverless architecture?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Serverless architecture is a cloud computing model where the cloud provider manages the infrastructure and automatically allocates resources as needed. Developers can focus on writing code and building applications without worrying about infrastructure management, scalability, and availability. It's a pay-per-use model, where businesses only pay for the actual usage of the application.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What are the challenges of building multilingual serverless applications?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"One of the biggest challenges of building multilingual serverless applications is managing translations. Applications that are built for a global audience require content to be translated into multiple languages. Manually managing translations can be a daunting task, as it involves managing multiple translation files, keeping track of translations, and ensuring consistency across languages. Additionally, deploying multiple versions of the application for each language can be a logistical nightmare, especially if you have to manage multiple tiny parts like AWS Lambda functions.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What are the Translation Management Systems (TMS) in Serverless Architecture?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"A Translation Management System (TMS) is a software platform that enables businesses to manage their translation workflow. It provides a central repository for storing translations and enables collaboration among translators. When integrated with i18next, TMS like locize can streamline the localization process in a serverless architecture. Some of the benefits of using a TMS integrated with i18next in serverless architecture include automatic updates of translations, centralized translation management, and easier collaboration among translators.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How can businesses ensure that their serverless applications are multilingual?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Businesses can ensure that their serverless applications are multilingual by using i18next and TMS in serverless architecture. i18next is an internationalization framework that allows developers to manage translations in web applications. TMS provides a central repository for storing translations and enables collaboration among translators. By integrating i18next and TMS, businesses can streamline the localization process in a serverless architecture, automate the updates of translations, and ensure consistency across languages.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"serverless","slug":"serverless","permalink":"https://locize.com/blog/tags/serverless/"},{"name":"aws","slug":"aws","permalink":"https://locize.com/blog/tags/aws/"}]},{"title":"Fastest way to unleash the full power of i18next (in 3 steps)","slug":"i18next-migrate","date":"un22fin22","updated":"un11fin11","comments":true,"path":"i18next-migrate/","link":"","permalink":"https://locize.com/blog/i18next-migrate/","excerpt":"","text":"Internationalization (i18n) and localization (l10n) are crucial for businesses that want to expand globally and reach a wider audience. To do this, you need a robust solution that can handle different languages and cultural nuances, and this is where i18next and locize come in. These two elements have been designed to help you get the most out of your i18n efforts, and when used together, they are a powerhouse combination that can help you achieve your goals faster and more efficiently. In this article, we&#39;ll explore the fastest way to unleash the full power of i18next in 3 steps. PreconditionWe assume you know i18next and already use it. If you don&#39;t know i18next, we suggest you read this. In this article, we also assume you&#39;re loading your translation resources via i18next-http-backend plugin, but that&#39;s not really mandatory. Step 1 - Create a locize projectSign up and create a new locize project for free, like described here. Define your source language and if needed change the i18n format. Then, add all your target languages, as described here Step 2 - Migrate your translationsExecute the locize cli migrate command. Copy-Paste the project-id and the api-key from your locize project settings page, and use it as arguments for your command. Also, make sure to pass the path of your current translation files. npx locize migrate --project-id d950a914-a349-4b04-94ac-000fdf28beed --api-key 4cde8595-062b-44a7-b645-6a3fe739e792 --path public/locales Step 3 - i18next-locize-backendInstall the i18next-locize-backend plugin and replace your current backend plugin. Copy the project-id and pass it via i18next backend options. Done!Yes, the important part is already done. Now the translations are directly coming from locize. This means you can also delete your old locales directory. If you change a translation text in locize, you can see the updated texts in your UI. This is already awesome, but we can do more. Extra Step 4 - InContext editorBy installing the locize module and passing it to i18next, we can work directly within the InContext view of locize. Extra Step 5 - Save missing keys Enabling the saveMissing option of i18next and passing the api-key via backend options, will automatically add newly defined keys to locize. Additionally, if you enable the automatic machine translation option in locize, the passed default value of your new keys is automatically translated into your target languages. That&#39;s just a first sneak peek on how you can power up i18next. locize offers a lot more. Try it for free and send us your feedback. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\" } }, { \"@type\": \"Question\", \"name\": \"What is locize?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"locize is a powerful l10n solution that works in conjunction with i18next to help businesses achieve their goals faster and more efficiently.\" } }, { \"@type\": \"Question\", \"name\": \"How do I use i18next and locize together?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"To use i18next and locize together, you can follow the three steps outlined in the article: create a locize project, migrate your translations, and replace your current backend plugin with the i18next-locize-backend plugin.\" } }, { \"@type\": \"Question\", \"name\": \"What is the InContext editor in locize?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The InContext editor in locize is a feature that allows you to work directly within the locize platform to edit your translations. By installing the locize module, you can use the InContext view to make changes to your translations directly from within your UI.\" } }, { \"@type\": \"Question\", \"name\": \"How do I add new keys to locize automatically?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"You can add new keys to locize automatically by enabling the saveMissing option of i18next and passing the api-key via the backend options. Additionally, if you enable the automatic machine translation option in locize, the default values of your new keys will be automatically translated into your target languages.\" } }] }","raw":"---\ntitle: Fastest way to unleash the full power of i18next (in 3 steps)\ndescription: Learn the fastest way to unleash the full power of i18next with locize and get the most out of your internationalization efforts.\n\ndate: 2023-02-14\ntags:\n  - i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: i18next-migrate/title.jpg\n\nlabel: i18next-migrate\nlang: en\n---\n\n![](title.jpg)\n\nInternationalization ([i18n](../what-is-i18n/)) and localization ([l10n](../localization/)) are crucial for businesses that want to expand globally and reach a wider audience. To do this, you need a robust solution that can handle different languages and cultural nuances, and this is where [i18next](https://www.i18next.com) and [locize](/) come in. These two elements have been designed to help you get the most out of your i18n efforts, and when used together, they are a powerhouse combination that can help you achieve your goals faster and more efficiently.\n<br />\nIn this article, we'll explore the fastest way to unleash the full power of i18next in 3 steps.\n\n## Precondition\nWe assume you know i18next and already use it. If you don't know i18next, we suggest you read [this](../react-i18next/).\n<br />\nIn this article, we also assume you're loading your translation resources via [i18next-http-backend](https://github.com/i18next/i18next-http-backend) plugin, but that's not really mandatory.\n\n\n## Step 1 - Create a locize project\nSign up and create a new locize project for free, like described [here](https://docs.locize.com/integration/getting-started#step-1-signup-and-create-a-project).\n\n![](add_project.jpg)\n\nDefine your source language and if needed change the [i18n format](https://docs.locize.com/integration/supported-i18n-formats).\n\nThen, add all your target languages, as described [here](https://docs.locize.com/integration/getting-started/add-content#add-languages)\n\n![](add_lng.jpg)\n\n\n## Step 2 - Migrate your translations\n\nExecute the [locize cli](https://github.com/locize/locize-cli) [migrate](https://github.com/locize/locize-cli#migration-of-existing-i18next-files) command.\n\nCopy-Paste the project-id and the api-key from your locize project settings page, and use it as arguments for your command. Also, make sure to pass the path of your current translation files.\n\n`npx locize migrate --project-id d950a914-a349-4b04-94ac-000fdf28beed --api-key 4cde8595-062b-44a7-b645-6a3fe739e792 --path public/locales`\n\n![](cli.jpg)\n\n\n## Step 3 - i18next-locize-backend\n\nInstall the [i18next-locize-backend](https://github.com/locize/i18next-locize-backend) plugin and replace your current backend plugin.\n\nCopy the project-id and pass it via i18next backend options.\n\n![](backend.jpg)\n\n\n## Done!\n\nYes, the important part is already done.\n<br />\nNow the translations are directly coming from locize. This means you can also delete your old locales directory.\n\nIf you change a translation text in locize, you can see the updated texts in your UI.\n\nThis is already awesome, but we can do more.\n\n\n\n## Extra Step 4 - InContext editor\n\nBy installing the [locize](https://github.com/locize/locize) module and passing it to i18next, we can work directly within the [InContext view](https://docs.locize.com/different-views/incontext) of locize.\n\n![](incontext.jpg)\n\n\n## Extra Step 5 - Save missing keys <a name=\"save-missing\"></a>\n\nEnabling the saveMissing option of i18next and passing the api-key via backend options, will automatically add newly defined keys to locize.\n<br />\nAdditionally, if you enable the [automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation) option in locize, the passed default value of your new keys is automatically translated into your target languages.\n\n![](save_missing.jpg)\n\n\nThat's just a first sneak peek on how you can power up i18next.\n<br />\nlocize offers a lot more.\n\n[Try it for free](https://www.locize.app/register) and [send us](mailto:support@locize.com) your feedback.\n\n{% youtube jeRxew3OV64 %}\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What is locize?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"locize is a powerful l10n solution that works in conjunction with i18next to help businesses achieve their goals faster and more efficiently.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How do I use i18next and locize together?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"To use i18next and locize together, you can follow the three steps outlined in the article: create a locize project, migrate your translations, and replace your current backend plugin with the i18next-locize-backend plugin.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"What is the InContext editor in locize?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The InContext editor in locize is a feature that allows you to work directly within the locize platform to edit your translations. By installing the locize module, you can use the InContext view to make changes to your translations directly from within your UI.\"\n      }\n    }, {\n      \"@type\": \"Question\",\n      \"name\": \"How do I add new keys to locize automatically?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"You can add new keys to locize automatically by enabling the saveMissing option of i18next and passing the api-key via the backend options. Additionally, if you enable the automatic machine translation option in locize, the default values of your new keys will be automatically translated into your target languages.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"}]},{"title":"Why does app localization matter for growth?","slug":"what-is-mobile-app-localization","date":"un44fin44","updated":"un00fin00","comments":true,"path":"what-is-mobile-app-localization/","link":"","permalink":"https://locize.com/blog/what-is-mobile-app-localization/","excerpt":"","text":"Today you&#39;re going to learn what app localization is and how to use it to greatly simplify your app&#39;s content management. Table of contents What is mobile app localization? Make your app scalable with localization What is the difference between localization and internationalization? What is the process of localization? App-store optimization for localization How to find translators? App-localization-tips: How to localize your app How it worked for others Conclusion In fact, this tips have helped three clients of us to manage multiple languages and significantly growth their potential user base. Effective localization will ensure that your product is not only meeting the requirements of your chosen demographics, but also helping you to reach new audiences. Therefore, you&#39;ll appreciate this article if you wish to increase the number of registrations for your mobile application. Let&#39;s begin by having an understanding of the purpose of app localization. What is mobile app localization? In this highly connected digital world, globalization is an essential part of any business. Being able to effectively reach and engage with customers around the world is crucial, especially for mobile app developers. With the rise of smartphones, apps have become a core part of our daily lives. From ordering food to watching films, research has shown that over 230 billion mobile apps were downloaded in 2021 alone. This extensive use means localization of an app is crucial in ensuring your products can reach consumers anywhere in the world. What is this localization, though, and how can it help? Make your app scalable with localization Mobile-app-localization is a highly beneficial aspect of any business. This is a unique process that requires you to adapt your app so that it can be used by consumers in a wide range of localities. This could require adapting the wording so that it is in the right language, or even changing the layout to suit the target market. With nearly five billion smartphone users in the world, the localization of apps ensures that your product can be enjoyed by customers no matter where they might be located. What is the difference between localization and internationalization? Localization and internationalization are two vital strategies for any business, but many people often confuse the two. While they are two similar methods and both rely on each other, they do have two very different approaches. Internationalization is the process of adapting your mobile app code so that it can be easily modified and adapted into the required language. On the other hand, localization is the process of actually customizing the content so that it meets the expectations of the chosen destination. This means that internationalization needs to happen first, ensuring that mobile app coding is ready to meet the adaptations of localization. Find out more about internationalization in our guide on what is i18n. You can&#39;t wait to see how others did it. Please read through some success stories . What is the process of localization? While there can be no denying the many benefits that come from localization, it is a comprehensive and time-consuming task. To help you, we have taken a closer look at the process: 1) PlanningThe first stage of any localization strategy is to ensure that you focus on your planning.This process should cover: deciding which countries and regions to target with your app localization efforts. the research into the languages you are looking to focus on, how you will do this, and what requirements are needed to successfully meet the demands of your target audience. 2) ExecutionOnce you have comprehensively planned your localization strategy for the app, the next step is to execute the changes. This should be taken with the utmost care and attention, carefully working through every aspect and feature of the app to ensure that they are meeting the requirements. Here are some examples: Translate your app's title, description, and keywords into the target language to improve visibility and search ranking in local app stores. Adapt your app's screenshots and videos to better fit the cultural preferences and expectations of local users. The coming chapter gives you the full list of potential optimizations for a mobile app. 3) TestingWith the translations made, you need to ensure that you are conducting a comprehensive testing strategy to ensure that it meets the exact requirements of your target audience. A beta test is the most effective way of doing this. Beta testing is the process of having the app reviewed by native speakers of your target demographics, having them review the copy and design. This should not be rushed, and you should be methodical with your beta testing to guarantee the very best result. Test your app with real users in your area, and ask them to give you feedback on the localization as they use it. Verify text and character encoding to ensure that everything is accurately encoded and shown on all devices. Verify linguistic and cultural consistency: Make sure that all app components, including text, graphics, and sounds, are suitable from a culture standpoint and adhere to regional norms. Test the language switching capability of the app to ensure that users can quickly and simply switch between languages. Including an in-app feedback feature can be very beneficial, with research showing that it can increase feedback by up to 750%. 4) Publish your updatesOnce your beta tests have been completed, it is time to publish your updates. This is the final step to getting your mobile app out there and being used by consumers. 5) Bonus tip – read customer reviews and check analytics dataOf course, there is no better way to ensure that your app is the very best it can be than by reading customer reviews. This is your chance to see exactly what customers are thinking, allowing you to adapt the app accordingly. Your app analytics are an excellent location to look for potential growth directions. Determine where the majority of your consumers or loyal users originate from. App-store optimization in terms of localization Translate app metadata: To improve visibility and search ranking in local app stores, translate your app's title, description, and keywords into the target language. Target local keywords: Conduct keyword research to identify relevant local keywords and include them in the metadata of your app. Localize app visual assets: Tailor your app's screenshots and videos to the cultural preferences and expectations of your target audience. Provide local payment options: To increase conversion rates among local users, provide local payment options such as local currency and popular payment methods. Engage with local communities, such as online forums and social media groups, to raise awareness and promote your app to potential users. Provide local customer support: To provide a better experience for local users, provide local customer support, such as a local language helpline or chat service. Customize in-app content: Tailor in-app content like promotions and notifications to the local culture and language. Localize in-app purchases: To improve conversion rates and user experience, localize in-app purchases such as pricing and product descriptions. Monitor your app's ranking in local app stores and make any necessary adjustments to your ASO strategy based on the results. ## How to find translators? Comprehensive translation is essential to any localization process, but finding the right translator can be tough. There are several tips to remember when finding a translator, including: 1) BackgroundThe first thing to do is to review their background. You want to ensure that your chosen translator has a proven history in your target language, either being a native speaker or has spent considerable time in that country. 2) Be clearWhen engaging with a translator, you should make sure that you are as clear and straightforward as possible. The more thorough you are with your instructions, the better your translator will be able to understand your requirements. 3) Ask for examplesAnother top tip when it comes to finding the very best translator possible is to ask for examples. Any professional translator will be happy to showcase their past work, allowing you to review their results. In our ecosystem, there is a way we make this much easier for you. Learn here how to find a translator. find a translator How to choose the right localization technologyTechnology has transformed the world around us, helping to make things more efficient and easier. This is true when it comes to mobile-app localization, and there are some fantastic options out there to help you make the process as quick and as easy as possible. However, it is essential that you are utilizing the right technology. Not having the right localization-tools can lead to poor results, so when it comes to finding the right localization technology, there are certain things you should look for: A collaborative process that allows copywriters, designers, managers, and more, to work together. A solution that lets you reuse app strings and content, helping to save you time and money. A built-in glossary of mobile app terms to ensure consistency. Automation tools for tasks such as string extractions, performance monitoring, workflow management, and screenshot generation. Integration with other essential apps such as Slack and Jira. Ability to support multiple file types and file-format. You can improve the user experience of your global app and attract more customers by implementing a proper translating-app process for your content. This is why every app-business should use localization services. Learn more App-localization-tips: How to localize your app When it comes to app localization, there are several top tips to remember. The first is to ensure that you are being as comprehensive as possible in your beta testing. This will give you the knowledge and insight on what is working and what areas still need to be improved. You should also ensure that you are being as flexible as possible when it comes to adapting your mobile app into different languages. You also want to ensure that your app is able to support languages that read right-to-left and left-to-right, guaranteeing that it flows for readers no matter where in the world that they might be based. The support of numerous languages will also have a favorable impact on the app store listing . Another helpful tip is to transfer strings from code to resource files. Because storing strings in resource files before deploying code allows the team to access those files for translation later without having to change the code. The team may access those files for translation without having to update the code itself. Check out our localization software; it&#39;s exactly what we can help you with, and it only takes a few steps to get started. How it works for others We offer a simple and scalable translation management system that has assisted many of our customers in attaining their development with mobile applications. 1) nakiNaki was able to manage and keep up their products in more than six languages. Locize is for them, they claimed: As a product company which releases mobile applications throughout Europe, we were looking for a tool that allows us to easily involve who translate and keep the maintenance of the copywriting seamless. 2) retraced.comRetraced, a blockchain-based platform for supply chain transparency that focuses on the end user, uses locize for its app localization We utilise locize throughout our infrastructure in two mobile applications. Locize is a very reliable service and scales beautifully with the business. 3) barntools.comBarnTools, a digital biosecurity platform created by producers for producers, used locize to quickly and easily localize its mobile application. It enables our global team perform the translation work anywhere and anytime. We also get to maintain the translations in realtime. Conclusion It is now up to you to make a decision. The process of adjusting a mobile app&#39;s functionality and user experience for users in various target markets is known as localization. Start to plan your target regions and langauges. A highly scaleable solution will ensure that your iOS, Android, or other app meets your customers&#39; needs and that you can execute the project efficiently. Because how you handle the app translation process will determine your mobile application&#39;s success and ability to reach a worldwide audience. You may discover how to use locize in your development and how your team can work with it by clicking the link below. In the end, localizing your apps will increase your revenue and enhance user experience. For your team Now we&#39;d like to invite you to share this with any developer, project manager, or business that could benefit from it.","raw":"---\ntitle: Why does app localization matter for growth?\ndescription: Learn how localization can help you growth your app. This guide will explain what ✅ app localization is and how to use it.\n\ndate: 2023-02-09\ntags:\n  - mobile app\n  - android\n  - app store\n  - localization tools\n  - software\n  - language\nthumbnail: what-is-mobile-app-localization/app-localization.webp\n---\n\n\n![app localization](app-localization.webp)\n\n\nToday you're going to learn what app localization is and how to use it to greatly simplify your app's content management.\n\n## Table of contents\n  * [What is mobile app localization?](#what)\n  * [Make your app scalable with localization](#scale)\n  * [What is the difference between localization and internationalization?](#term)\n  * [What is the process of localization?](#process)\n  * [App-store optimization for localization](#appstore)\n  * [How to find translators?](#translators)\n  * [App-localization-tips: How to localize your app](#tips)\n  * [How it worked for others](#how)\n  * [Conclusion](#conclusion)\n\nIn fact, this tips have helped three clients of us to manage multiple languages and significantly growth their potential user base. Effective [localization](../localization/) will ensure that your product is not only meeting the requirements of your chosen demographics, but also helping you to reach new audiences. \n\nTherefore, you'll appreciate this article <strong>if you wish to increase the number of registrations</strong> for your mobile application.\n\nLet's begin by having an understanding of the purpose of app localization.\n\n\n## What is mobile app localization? <a name=\"what\"></a>\nIn this highly connected digital world, globalization is an essential part of any business. Being able to effectively reach and engage with customers around the world is crucial, especially for mobile app developers. \n\nWith the rise of smartphones, apps have become a core part of our daily lives. From ordering food to watching films, research has shown that over <a href=\"https://www.statista.com/statistics/271644/worldwide-free-and-paid-mobile-app-store-downloads/\" title=\"230 billion mobile apps\">230 billion mobile apps</a>  were downloaded in 2021 alone. \n\nThis extensive use means localization of an app is crucial in ensuring your products can reach consumers anywhere in the world. What is this localization, though, and how can it help?\n\n \n## Make your app scalable with localization <a name=\"scale\"></a>\nMobile-app-localization is a highly beneficial aspect of any business. This is a unique process that requires you to adapt your app so that it can be used by consumers in a wide range of localities. \n\nThis could require adapting the wording so that it is in the right language, or even changing the layout to suit the target market. With nearly [five billion smartphone users](https://www.statista.com/statistics/274774/forecast-of-mobile-phone-users-worldwide/) in the world, the localization of apps ensures that your product can be enjoyed by customers no matter where they might be located. \n\n![five billion smartphone users](smartphone-users.webp \"five billion smartphone users\")\n\n\n## What is the difference between localization and internationalization? <a name=\"term\"></a>\nLocalization and internationalization are two vital strategies for any business, but many people often confuse the two. While they are two similar methods and both rely on each other, they do have two very different approaches. \n\nInternationalization is the process of adapting your mobile app code so that it can be easily modified and adapted into the required language. On the other hand, localization is the process of actually customizing the content so that it meets the expectations of the chosen destination. \n\nThis means that internationalization needs to happen first, ensuring that mobile app coding is ready to meet the adaptations of localization. \n\nFind out more about internationalization in our guide on <a href=\"../what-is-i18n/\" title=\"what is i18n\">what is i18n</a>.\n\nYou can't wait to see how others did it. Please read through some [success stories](#how) \n.\n<a href=\"https://nakipower.com/\" title=\"mobile app\">![mobile app](mobile-app.webp \"mobile app\")</a>\n\n## What is the process of localization? <a name=\"process\"></a>\n\nWhile there can be no denying the many benefits that come from localization, it is a comprehensive and time-consuming task. To help you, we have taken a closer look at the process:\n\n\n### 1)  \tPlanning \nThe first stage of any localization strategy is to ensure that you focus on your planning.This process should cover:\n\n<ul>\n  <li>deciding which countries and regions to target with your app localization efforts.</li> \n\n  <li> the research into the languages you are looking to focus on, how you will do this, and what requirements are needed to successfully meet the demands of your target audience.</li> \n</ul>\n\n\n\n \n### 2)  \tExecution \nOnce you have comprehensively planned your <a href=\"/blog/localization-strategy\" title=\"localization strategy\">localization strategy</a> for the app, the next step is to execute the changes. This should be taken with the utmost care and attention, carefully working through every aspect and feature of the app to ensure that they are meeting the requirements. \n\nHere are some examples: \n\n<ul>\n  <li>Translate your app's title, description, and keywords into the target language to improve visibility and search ranking in local app stores.</li> \n\n  <li>Adapt your app's screenshots and videos to better fit the cultural preferences and expectations of local users.</li> \n</ul>\n\n[The coming chapter](#appstore) gives you the full list of potential optimizations for a mobile app.\n\n\n### 3)  \tTesting \nWith the translations made, you need to ensure that you are conducting a comprehensive testing strategy to ensure that it meets the exact requirements of your target audience.  A beta test is the most effective way of doing this. \n\nBeta testing is the process of having the app reviewed by native speakers of your target demographics, having them review the copy and design. This should not be rushed, and you should be methodical with your beta testing to guarantee the very best result. \n\n<ul>\n  <li style=\"padding: 1rem 0\">Test your app with real users in your area, and ask them to give you feedback on the localization as they use it.</li> \n\n  <li style=\"padding: 1rem 0\">Verify text and character encoding to ensure that everything is accurately encoded and shown on all devices.</li> \n\n  <li style=\"padding: 1rem 0\">Verify linguistic and cultural consistency: Make sure that all app components, including text, graphics, and sounds, are suitable from a culture standpoint and adhere to regional norms.</li> \n\n  <li style=\"padding: 1rem 0\">Test the language switching capability of the app to ensure that users can quickly and simply switch between languages.</li> \n</ul>\n\nIncluding an in-app feedback feature can be very beneficial, with research showing that it can increase feedback by <a href=\"https://instabug.com/blog/benefits-of-in-app-feedback-during-beta-testing/?src=InstabugBlog&mdm=internal&ref=mobile_app_localization\" title=\"up to 750%\">up to 750%</a>.\n\n### 4)  \tPublish your updates\nOnce your beta tests have been completed, it is time to publish your updates. This is the final step to getting your mobile app out there and being used by consumers. \n\n### 5)  \tBonus tip – read customer reviews and check analytics data\nOf course, there is no better way to ensure that your app is the very best it can be than by reading customer reviews. This is your chance to see exactly what customers are thinking, allowing you to adapt the app accordingly. \n\nYour app analytics are an excellent location to look for potential growth directions. Determine where the majority of your consumers or loyal users originate from.\n\n![process of localization](process-of-localization.webp \"process of localization\")\n\n## App-store optimization in terms of localization  <a name=\"appstore\"></a>\n\n\n<ol>\n  <li style=\"padding: 1rem 0\">\n    Translate app metadata: To improve visibility and search ranking in local app stores, translate your app's title, description, and keywords into the target language.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Target local keywords: Conduct keyword research to identify relevant local keywords and include them in the metadata of your app.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Localize app visual assets: Tailor your app's screenshots and videos to the cultural preferences and expectations of your target audience.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Provide local payment options: To increase conversion rates among local users, provide local payment options such as local currency and popular payment methods.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Engage with local communities, such as online forums and social media groups, to raise awareness and promote your app to potential users.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Provide local customer support: To provide a better experience for local users, provide local customer support, such as a local language helpline or chat service.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Customize in-app content: Tailor in-app content like promotions and notifications to the local culture and language.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Localize in-app purchases: To improve conversion rates and user experience, localize in-app purchases such as pricing and product descriptions.\n  </li>\n  <li style=\"padding: 1rem 0\">\n    Monitor your app's ranking in local app stores and make any necessary adjustments to your ASO strategy based on the results.\n  </li>\n\n</ol>\n \n## How to find translators? <a name=\"translators\"></a>\nComprehensive translation is essential to any localization process, but finding the right translator can be tough. There are several tips to remember when finding a translator, including:\n\n\n#### 1)  \tBackground \nThe first thing to do is to review their background. You want to ensure that your chosen translator has a proven history in your target language, either being a native speaker or has spent considerable time in that country. \n \n#### 2)  \tBe clear  \nWhen engaging with a translator, you should make sure that you are as clear and straightforward as possible. The more thorough you are with your instructions, the better your translator will be able to understand your requirements. \n\n#### 3)  \tAsk for examples  \nAnother top tip when it comes to finding the very best translator possible is to ask for examples. Any professional translator will be happy to showcase their past work, allowing you to review their results. \n\nIn our ecosystem, there is a way we make this much easier for you. Learn here how to <a href=\"/services.html#translationservices\" title=\"find a translator\">find a translator</a>.\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"/services.html#translationservices\" title=\"find a translator\">find a translator</a>\n\n![find a translator](find-a-translator.jpg \"find a translator\")\n\n### How to choose the right localization technology \nTechnology has transformed the world around us, helping to make things more efficient and easier. This is true when it comes to mobile-app localization, and there are some fantastic options out there to help you make the process as quick and as easy as possible. \n\nHowever, it is essential that you are utilizing the right technology. Not having the right localization-tools can lead to poor results, so when it comes to finding the right localization technology, there are certain things you should look for:\n\n-\tA collaborative process that allows copywriters, designers, managers, and more, to work together. \n-\tA solution that lets you reuse app strings and content, helping to save you time and money. \n-\tA built-in glossary of mobile app terms to ensure consistency. \n-\tAutomation tools for tasks such as string extractions, performance monitoring, workflow management, and screenshot generation. \n-\tIntegration with other essential apps such as Slack and Jira. \n-\tAbility to support multiple file types and file-format.\n\nYou can improve the user experience of your global app and attract more customers by implementing a proper translating-app process for your content. This is why every app-business should use localization services.\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://docs.locize.com/\" title=\"introduction\">Learn more</a>\n\n{% youtube YQryHo1iHb8 %}\n\n\n \n## App-localization-tips: How to localize your app  <a name=\"tips\"></a>\nWhen it comes to app localization, there are several top tips to remember. The first is to ensure that you are being as comprehensive as possible in your beta testing. This will give you the knowledge and insight on what is working and what areas still need to be improved. \n\nYou should also ensure that you are being as flexible as possible when it comes to adapting your mobile app into different languages. You also want to ensure that your app is able to support languages that read right-to-left and left-to-right, guaranteeing that it flows for readers no matter where in the world that they might be based. \n\nThe support of numerous languages will also have a <b>favorable impact on the app store listing </b>.\n\nAnother helpful tip is to transfer strings from code to resource files. Because storing strings in resource files before deploying code allows the team to access those files for translation later without having to change the code. The team may access those files for translation without having to update the code itself.\n\nCheck out our <a href=\"/\" title=\"localization software\">localization software</a>; it's exactly what we can help you with, and it only takes a few steps to get started.\n\n\n### How it works for others <a name=\"how\"></a>\n\nWe offer a simple and scalable <a href=\"/blog/tms/\" title=\"translation management system\">translation management system</a>  that has assisted many of our customers in attaining their development with mobile applications.\n\n\n#### 1) [naki](https://nakipower.com/de/)\nNaki was able to manage and keep up their products in more than six languages. Locize is for them, they claimed:\n\n>As a product company which releases mobile applications throughout Europe, we were looking for a tool that allows us to easily involve who translate and keep the maintenance of the copywriting seamless.\n\n<a href=\"https://nakipower.com/de/\" title=\"nakipower\">![nakipower](nakipower.png \"nakipower\")</a>\n\n#### 2) [retraced.com](https://www.retraced.com/)\n\nRetraced, a blockchain-based platform for supply chain transparency that focuses on the end user, uses locize for its app localization\n\n\n>We utilise locize throughout our infrastructure in two mobile applications. Locize is a very reliable service and scales beautifully with the business.\n\n<a href=\"https://www.retraced.com/\" title=\"retraced\">![retraced](retraced.png \"retraced\")</a>\n\n\n#### 3) [barntools.com](https://barntools.com/)\n\nBarnTools, a digital biosecurity platform created by producers for producers, used locize to quickly and easily localize its mobile application.\n\n>It enables our global team perform the translation work anywhere and anytime. We also get to maintain the translations in realtime.\n\n<a href=\"https://barntools.com/\" title=\"barntools\">![barntools](barntools.png \"barntools\")</a>\n\n \n## Conclusion <a name=\"conclusion\"></a>\nIt is now up to you to make a decision. \n\nThe process of adjusting a mobile app's functionality and user experience for users in various target markets is known as localization.\n\nStart to plan your target regions and langauges.\n\nA highly scaleable solution will ensure that your iOS, Android, or other app meets your customers' needs and that you can execute the project efficiently. \n\n<strong>Because how you handle the app translation process will determine your mobile application's success and ability to reach a worldwide audience.</strong>\n\nYou may discover how to use locize in your development and how your team can work with it by clicking the link below.\n\n<strong>In the end, localizing your apps will increase your revenue and enhance user experience.</strong>\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"/for-your-team.html\" title=\"for your team\">For your team</a>\n\n\n\n\n\n\n\n\n\n\n\nNow we'd like to invite you to share this with any developer, project manager, or business that could benefit from it.\n\n","categories":[],"tags":[{"name":"mobile app","slug":"mobile-app","permalink":"https://locize.com/blog/tags/mobile-app/"},{"name":"android","slug":"android","permalink":"https://locize.com/blog/tags/android/"},{"name":"app store","slug":"app-store","permalink":"https://locize.com/blog/tags/app-store/"},{"name":"localization tools","slug":"localization-tools","permalink":"https://locize.com/blog/tags/localization-tools/"},{"name":"software","slug":"software","permalink":"https://locize.com/blog/tags/software/"},{"name":"language","slug":"language","permalink":"https://locize.com/blog/tags/language/"}]},{"title":"Google Translate: Accuracy & Alternatives","slug":"google-translate-accuracy","date":"un22fin22","updated":"un33fin33","comments":true,"path":"google-translate-accuracy/","link":"","permalink":"https://locize.com/blog/google-translate-accuracy/","excerpt":"","text":"Google Translate is one of the most widely used machine translation services in the world, with over 100 million active users relying on it for their translation needs. Despite its popularity, the accuracy of Google Translate continues to be a topic of discussion among both language experts and casual users. In this article, we will examine the technology behind Google Translate, its limitations, real-life examples, effective and efficient use, and ethical and privacy concerns related to the use of machine translation services. The Technology Behind Google TranslateGoogle Translate is a combination of machine learning algorithms and statistical models that translate text from one language to another. It uses statistical machine translation, which involves training the system on large amounts of parallel text data. This data is then used to identify patterns and relationships between words in different languages, allowing Google Translate to accurately translate text. Google Translate is continually updated and improved, adding new language pairs and refining existing ones. The service also solicits user feedback and suggestions for improvement, which further improves its accuracy over time. The Limitations of Google TranslateGoogle Translate is a highly advanced machine translation system, but it is still limited by its technology and data. Some of the key limitations of Google Translate include: Lack of Context: Google Translate heavily relies on the input text, which can lead to incorrect translations if it doesn't understand the context of a sentence. For example, the phrase \"I'm falling for you\" can be translated as \"Estoy cayendo por ti\" in Spanish, which can mean both \"I am falling for you\" and \"I am falling physically\". Ambiguity: Words can often have ambiguous meanings, especially when translating between languages with different grammatical structures. This can result in translations that are inaccurate or convey a different meaning than intended. For example, the English word \"bass\" can mean a type of fish or a low-frequency sound, but both meanings have different translations in other languages. Cultural Differences: Language is closely tied to culture, and cultural differences can impact the accuracy of Google Translate. For example, idioms and cultural references can be challenging to translate accurately. For instance, the English phrase \"beating around the bush\" cannot be translated accurately to some cultures who do not have similar idioms. Syntax Awareness: Text used in software localization (internationalization) often contains interpolation specific syntax - tags that are specific to the i18n format used. Google Translate often does not respect these syntax rules. More specific machine translation tools such as translate.i18next.com or the more complete cat version of locize are better suited to handle these types of use cases. Factors That Affect Google Translate&#39;s AccuracySeveral factors can impact the accuracy of Google Translate, including: Quality of Input Text: The quality of the input text is critical in determining the accuracy of Google Translate. Poorly written text, with grammatical errors and typos, can result in incorrect translations. Domain-Specific Terminology: Google Translate is trained on a broad range of text data, but it may struggle to accurately translate domain-specific terminology. For example, technical terms in medicine or law can be challenging to translate. User Feedback: Google Translate invites user feedback and suggestions for improvement, which can impact its accuracy over time. The more feedback it receives, the better it can become at translating text in a specific language or domain. Effective and Efficient Usage of Google TranslateGoogle Translate can be a highly effective and efficient tool for translating text, but it&#39;s important to use it properly to get the best results. Here are some tips for using Google Translate effectively and efficiently: Use proper input text: As mentioned earlier, the quality of the input text is critical in determining the accuracy of Google Translate. Ensure that the text is well-written and free of grammatical errors and typos to get the most accurate translation possible. Use specific language pairs: Google Translate supports many language pairs, but it is always better to use the language pair with the highest accuracy rate. For instance, if you are translating from English to Spanish, it's better to use English to Spanish rather than English to French to Spanish. Consider the context: Google Translate heavily relies on the input text and may not always understand the context of a sentence. If possible, provide additional context to ensure that the translation is accurate. Check for cultural references: Language is closely tied to culture, and cultural references can impact the accuracy of Google Translate. Always check for cultural references and idioms before relying on the translation. Utilize user feedback: Google Translate invites user feedback and suggestions for improvement, which can impact its accuracy over time. If you come across a translation that is not accurate, you can provide feedback to help improve the service for everyone. Use it for general understanding: Google Translate is not suitable for professional or critical translations but can be very helpful for understanding the general meaning of a text in a foreign language. By following these tips, you can get the most out of your experience with Google Translate and ensure that your translations are as accurate and reliable as possible. Ethical and Privacy Concerns of Machine Translation ServicesThe use of machine translation services raises several ethical and privacy concerns that should be considered when using such tools. Here are some of the key issues to be aware of: Data Privacy: Machine translation services collect and store large amounts of user data, including the text being translated. This data can be sensitive in nature and can be misused by the service provider or others. Bias and Discrimination: Machine learning algorithms are only as unbiased as the data they are trained on. If the training data contains biases, the algorithm can perpetuate these biases and discriminate against certain groups. Translation Accuracy: Machine translation services can be used to translate intellectual property, including patents, trademarks, and copyrights. This can raise issues of copyright infringement and potential legal disputes. Intellectual Property: Machine translation can raise questions about intellectual property rights and the unauthorized use of copyrighted content. National Security: The use of machine translation services can pose a threat to national security, as the text being translated may contain sensitive information that can be accessed by unauthorized individuals or organizations. These are important issues to consider when using machine translation services, and it&#39;s important to be aware of the risks involved and take appropriate steps to mitigate these risks. Competitors of Google Translate Google Translate may be the most popular machine translation tool, but it is not the only one. There are several other translation tools available, some of which offer features that Google Translate does not. Some of Google Translate&#39;s competitors include: Microsoft Translator Amazon Translate Deepl Systran Translate iTranslate Reverso ChatGPT Each of these tools has its own unique features and strengths, and many of them have their own dedicated user bases. Some, like Amazon Translate and Microsoft Translator, are part of larger tech companies and offer advanced features like automatic language detection and real-time speech translation. Others, like Deepl and Reverso, specialize in more specific language pairs and offer high-quality translations in multiple languages. One of the newer players in the field of machine translation is ChatGPT, a large language model developed by OpenAI. ChatGPT offers a conversational interface for translating text, and has the ability to learn from user interactions and improve its translations over time. While it may not be as advanced as some of the other tools on this list, it offers a unique user experience that sets it apart from the rest. When choosing a machine translation tool, it is important to consider your specific needs and requirements. Whether you are looking for speed, accuracy, or versatility, there is likely a tool out there that will meet your needs. By considering the features and strengths of each tool, you can choose the one that is right for you and get the most out of your translation efforts. ConclusionGoogle Translate is a widely used machine translation service that combines machine learning algorithms and statistical models to translate text from one language to another. Despite its popularity, the accuracy of Google Translate is still a topic of discussion due to its limitations such as lack of context, ambiguity, and cultural differences. Factors such as the quality of the input text, domain-specific terminology, and user feedback can also affect accuracy. However, Google Translate is continually updated and improved, and user feedback plays an important role in improving its performance. There are several other machine translation tools available, each with its own unique features and strengths. When choosing a machine translation tool, it is important to consider your specific needs and requirements. On the other hand, for a higher degree of accuracy, a human translation service like Supertext may be a better option. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is Google Translate?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Google Translate is a machine translation service that translates text from one language to another. It uses statistical machine learning algorithms and statistical models to identify patterns and relationships between words in different languages.\" } },{ \"@type\": \"Question\", \"name\": \"How does Google Translate work?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Google Translate works by training the system on large amounts of parallel text data. This data is used to identify patterns and relationships between words in different languages, allowing the system to accurately translate text.\" } },{ \"@type\": \"Question\", \"name\": \"What are the limitations of Google Translate?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The limitations of Google Translate include lack of context, ambiguity, cultural differences, and domain-specific terminology. It heavily relies on the input text and may not always understand the context of a sentence, which can result in incorrect translations.\" } },{ \"@type\": \"Question\", \"name\": \"How does the quality of input text affect Google Translate's accuracy?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The quality of the input text is critical in determining the accuracy of Google Translate. Poorly written text, with grammatical errors and typos, can result in incorrect translations.\" } },{ \"@type\": \"Question\", \"name\": \"What are the ethical and privacy concerns related to the use of machine translation services?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The use of machine translation services raises ethical and privacy concerns such as the potential misuse of personal information, the impact on employment in the translation industry, and the limitations of machine translation in accurately translating culturally specific references and idioms.\" } }] }","raw":"---\ntitle: \"Google Translate: Accuracy & Alternatives\"\ndescription: Google Translate is a machine translation service combining machine learning algorithms and statistical models with 100 million active users, but its accuracy is limited by lack of context, ambiguity, cultural differences, and the quality of input text; it can be effectively used by following tips such as using proper input text and considering context, but it is not suitable for professional or critical translations.\n\ndate: 2023-02-07\ntags:\n  - localization\n  - globalization\n  - l10n\n  - g11n\n  - translation\n  - global localization\n  - machine translation\nthumbnail: google-translate-accuracy/title.jpg\n---\n\n![](title.jpg)\n\n[Google Translate](https://translate.google.com/) is one of the most widely used machine translation services in the world, with over 100 million active users relying on it for their translation needs. Despite its popularity, the accuracy of Google Translate continues to be a topic of discussion among both language experts and casual users. In this article, we will examine the technology behind Google Translate, its limitations, real-life examples, effective and efficient use, and ethical and privacy concerns related to the use of machine translation services.\n\n## The Technology Behind Google Translate\nGoogle Translate is a combination of machine learning algorithms and statistical models that translate text from one language to another. It uses statistical machine translation, which involves training the system on large amounts of parallel text data. This data is then used to identify patterns and relationships between words in different languages, allowing Google Translate to accurately translate text.\n\nGoogle Translate is continually updated and improved, adding new language pairs and refining existing ones. The service also solicits user feedback and suggestions for improvement, which further improves its accuracy over time.\n\n## The Limitations of Google Translate\nGoogle Translate is a highly advanced machine translation system, but it is still limited by its technology and data. Some of the key limitations of Google Translate include:\n\n<ul>\n  <li>\n    <b>Lack of Context</b>: Google Translate heavily relies on the input text, which can lead to incorrect translations if it doesn't understand the context of a sentence. For example, the phrase \"I'm falling for you\" can be translated as \"Estoy cayendo por ti\" in Spanish, which can mean both \"I am falling for you\" and \"I am falling physically\".\n  </li>\n  <li>\n    <b>Ambiguity</b>: Words can often have ambiguous meanings, especially when translating between languages with different grammatical structures. This can result in translations that are inaccurate or convey a different meaning than intended. For example, the English word \"bass\" can mean a type of fish or a low-frequency sound, but both meanings have different translations in other languages.\n  </li>\n  <li>\n    <b>Cultural Differences</b>: Language is closely tied to culture, and cultural differences can impact the accuracy of Google Translate. For example, idioms and cultural references can be challenging to translate accurately. For instance, the English phrase \"beating around the bush\" cannot be translated accurately to some cultures who do not have similar idioms.\n  </li>\n  <li>\n    <b>Syntax Awareness</b>: Text used in <a href=\"../what-is-software-localization/\">software localization</a> (<a href=\"../what-is-i18n/\">internationalization</a>) often contains interpolation specific syntax - tags that are specific to the <a href=\"../i18n-formats-javascript/\">i18n format</a> used. Google Translate often does not respect these syntax rules. More specific machine translation tools such as <a href=\"https://translate.i18next.com/\" target=\"_blank\">translate.i18next.com</a> or the more complete cat version of <a href=\"/\" target=\"_blank\">locize</a> are better suited to handle these types of use cases.\n  </li>\n</ul>\n\n## Factors That Affect Google Translate's Accuracy\nSeveral factors can impact the accuracy of Google Translate, including:\n\n<ul>\n  <li>\n    <b>Quality of Input Text</b>: The quality of the input text is critical in determining the accuracy of Google Translate. Poorly written text, with grammatical errors and typos, can result in incorrect translations.\n  </li>\n  <li>\n    <b>Domain-Specific Terminology</b>: Google Translate is trained on a broad range of text data, but it may struggle to accurately translate domain-specific terminology. For example, technical terms in medicine or law can be challenging to translate.\n  </li>\n  <li>\n    <b>User Feedback</b>: Google Translate invites user feedback and suggestions for improvement, which can impact its accuracy over time. The more feedback it receives, the better it can become at translating text in a specific language or domain.\n  </li>\n</ul>\n\n## Effective and Efficient Usage of Google Translate\n\nGoogle Translate can be a highly effective and efficient tool for translating text, but it's important to use it properly to get the best results. Here are some tips for using Google Translate effectively and efficiently:\n\n<ol>\n  <li>\n    <b>Use proper input text</b>: As mentioned earlier, the quality of the input text is critical in determining the accuracy of Google Translate. Ensure that the text is well-written and free of grammatical errors and typos to get the most accurate translation possible.\n  </li>\n  <li>\n    <b>Use specific language pairs</b>: Google Translate supports many language pairs, but it is always better to use the language pair with the highest accuracy rate. For instance, if you are translating from English to Spanish, it's better to use English to Spanish rather than English to French to Spanish.\n  </li>\n  <li>\n    <b>Consider the context</b>: Google Translate heavily relies on the input text and may not always understand the context of a sentence. If possible, provide additional context to ensure that the translation is accurate.\n  </li>\n  <li>\n    <b>Check for cultural references</b>: Language is closely tied to culture, and cultural references can impact the accuracy of Google Translate. Always check for cultural references and idioms before relying on the translation.\n  </li>\n  <li>\n    <b>Utilize user feedback</b>: Google Translate invites user feedback and suggestions for improvement, which can impact its accuracy over time. If you come across a translation that is not accurate, you can provide feedback to help improve the service for everyone.\n  </li>\n  <li>\n    <b>Use it for general understanding</b>: Google Translate is not suitable for professional or critical translations but can be very helpful for understanding the general meaning of a text in a foreign language.\n  </li>\n</ol>\n\nBy following these tips, you can get the most out of your experience with Google Translate and ensure that your translations are as accurate and reliable as possible.\n\n## Ethical and Privacy Concerns of Machine Translation Services\nThe use of machine translation services raises several ethical and privacy concerns that should be considered when using such tools. Here are some of the key issues to be aware of:\n\n<ol>\n  <li>\n    <b>Data Privacy</b>: Machine translation services collect and store large amounts of user data, including the text being translated. This data can be sensitive in nature and can be misused by the service provider or others.\n  </li>\n  <li>\n    <b>Bias and Discrimination</b>: Machine learning algorithms are only as unbiased as the data they are trained on. If the training data contains biases, the algorithm can perpetuate these biases and discriminate against certain groups.\n  </li>\n  <li>\n    <b>Translation Accuracy</b>: Machine translation services can be used to translate intellectual property, including patents, trademarks, and copyrights. This can raise issues of copyright infringement and potential legal disputes.\n  </li>\n  <li>\n    <b>Intellectual Property</b>: Machine translation can raise questions about intellectual property rights and the unauthorized use of copyrighted content.\n  </li>\n  <li>\n    <b>National Security</b>: The use of machine translation services can pose a threat to national security, as the text being translated may contain sensitive information that can be accessed by unauthorized individuals or organizations.\n  </li>\n</ol>\n\nThese are important issues to consider when using machine translation services, and it's important to be aware of the risks involved and take appropriate steps to mitigate these risks.\n\n## Competitors of Google Translate <a name=\"google-translate-competitors\"></a>\nGoogle Translate may be the most popular machine translation tool, but it is not the only one. There are several other translation tools available, some of which offer features that Google Translate does not. Some of Google Translate's competitors include:\n\n- [Microsoft Translator](https://translator.microsoft.com)\n- [Amazon Translate](https://aws.amazon.com/translate/)\n- [Deepl](https://www.deepl.com/)\n- [Systran Translate](https://www.systran.net/translate/)\n- [iTranslate](https://itranslate.com/)\n- [Reverso](https://www.reverso.net/)\n- [ChatGPT](https://chat.openai.com/)\n\nEach of these tools has its own unique features and strengths, and many of them have their own dedicated user bases. Some, like Amazon Translate and Microsoft Translator, are part of larger tech companies and offer advanced features like automatic language detection and real-time speech translation. Others, like Deepl and Reverso, specialize in more specific language pairs and offer high-quality translations in multiple languages.\n\nOne of the newer players in the field of machine translation is ChatGPT, a large language model developed by [OpenAI](https://openai.com/). ChatGPT offers a conversational interface for translating text, and has the ability to learn from user interactions and improve its translations over time. While it may not be as advanced as some of the other tools on this list, it offers a unique user experience that sets it apart from the rest.\n\nWhen choosing a machine translation tool, it is important to consider your specific needs and requirements. Whether you are looking for speed, accuracy, or versatility, there is likely a tool out there that will meet your needs. By considering the features and strengths of each tool, you can choose the one that is right for you and get the most out of your translation efforts.\n\n## Conclusion\nGoogle Translate is a widely used machine translation service that combines machine learning algorithms and statistical models to translate text from one language to another. Despite its popularity, the accuracy of Google Translate is still a topic of discussion due to its limitations such as lack of context, ambiguity, and cultural differences. Factors such as the quality of the input text, domain-specific terminology, and user feedback can also affect accuracy. However, Google Translate is continually updated and improved, and user feedback plays an important role in improving its performance. There are several other machine translation tools available, each with its own unique features and strengths. When choosing a machine translation tool, it is important to consider your specific needs and requirements.\nOn the other hand, for a higher degree of accuracy, a [human translation](https://docs.locize.com/guides-tips-and-tricks/working-with-translators) service like [Supertext](../supertext-partnership/) may be a better option.\n\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is Google Translate?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Google Translate is a machine translation service that translates text from one language to another. It uses statistical machine learning algorithms and statistical models to identify patterns and relationships between words in different languages.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does Google Translate work?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Google Translate works by training the system on large amounts of parallel text data. This data is used to identify patterns and relationships between words in different languages, allowing the system to accurately translate text.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What are the limitations of Google Translate?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The limitations of Google Translate include lack of context, ambiguity, cultural differences, and domain-specific terminology. It heavily relies on the input text and may not always understand the context of a sentence, which can result in incorrect translations.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does the quality of input text affect Google Translate's accuracy?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The quality of the input text is critical in determining the accuracy of Google Translate. Poorly written text, with grammatical errors and typos, can result in incorrect translations.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What are the ethical and privacy concerns related to the use of machine translation services?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The use of machine translation services raises ethical and privacy concerns such as the potential misuse of personal information, the impact on employment in the translation industry, and the limitations of machine translation in accurately translating culturally specific references and idioms.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"machine translation","slug":"machine-translation","permalink":"https://locize.com/blog/tags/machine-translation/"},{"name":"globalization","slug":"globalization","permalink":"https://locize.com/blog/tags/globalization/"},{"name":"g11n","slug":"g11n","permalink":"https://locize.com/blog/tags/g11n/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"}]},{"title":"The joy, the pride and the burden of maintaining open source","slug":"maintaining-open-source","date":"un33fin33","updated":"un33fin33","comments":true,"path":"maintaining-open-source/","link":"","permalink":"https://locize.com/blog/maintaining-open-source/","excerpt":"","text":"As a maintainer of i18next, an open-source localization library, I can attest that there is nothing quite like the feeling of joy and pride that comes from contributing to the open-source community. Seeing others use and appreciate your work is a feeling like no other. But with great power comes great responsibility, and maintaining an open-source project can sometimes be a heavy burden at times. Let me paint you a picture: It&#39;s a sunny Sunday afternoon, and you&#39;re ready to relax and enjoy the weekend. But then, your phone starts buzzing. It&#39;s a notification from GitHub, alerting you to a new issue or pull request. You try to ignore it, but the nagging sense of responsibility sets in. You can&#39;t help but wonder, &quot;What if this is a critical bug that needs to be fixed ASAP?&quot; And so, you reluctantly open your laptop, ready to tackle the problem at hand. That, my friends, is the joy and the burden of maintaining open source. But it&#39;s not just the constant influx of issues and pull requests that can be overwhelming. It&#39;s also the pressure to constantly improve and update the project to keep up with the ever-changing technology landscape. With i18next, for example, we need to stay on top of new localization trends and technologies, as well as ensure compatibility with the latest versions of popular frameworks and libraries. It can be a lot to keep up with, especially when you&#39;re also trying to balance a full-time job, family, and other commitments. Despite the challenges, maintaining an open-source project is a rewarding experience that I wouldn&#39;t trade for anything. The sense of community and collaboration is truly special, and it&#39;s an honor to be a part of something that helps so many people. Plus, there&#39;s nothing quite like the feeling of satisfaction when you finally fix that tricky bug or implement a new feature that makes the project even better. Another aspect of maintaining an open source project that can be challenging is dealing with demanding users. While most users understand and appreciate the hard work that goes into maintaining a project, some can be quite demanding, even threatening to stop using the library if their special request isn&#39;t implemented. It can be difficult to navigate these situations, as you want to keep your users happy, but you also need to consider the overall direction and goals of the project. It&#39;s important to remember that, as the maintainer, you have the final say over what gets added to the project, and what doesn&#39;t. It&#39;s also important to communicate with your users, and explain your reasoning behind certain decisions. When maintaining an open source project, remember that no one is forcing anyone to use it. While it&#39;s important to listen to feedback and try to meet your users&#39; needs, it&#39;s also important to remember that the project is open source and free to use. This means that users have the freedom to use the project or not, and they also have the ability to contribute to it, or even fork it if they want to make significant changes. As maintainers, we should always be open to feedback and suggestions, but we must also be confident in our decisions and the direction of the project. We should also remember that most of us are volunteering, and that for most of us, this is a hobby, passion, or side project, not a paid job. We should not burn ourselves out trying to please every user. When users start insisting on free and ongoing support, that&#39;s not good. A common challenge in maintaining an open source project is dealing with users who report GitHub issues without enough information to reproduce and investigate the problem. Unfortunately, it&#39;s not uncommon for users to simply say &quot;there&#39;s a bug&quot; or &quot;it doesn&#39;t work&quot; without providing any additional details or context. This can make it extremely difficult for maintainers to understand and fix the problem. This is where the concept of a minimal reproducible example comes in. A minimal reproducible example is a small, self-contained snippet of code that demonstrates the problem. It should include all the information necessary for the maintainer to reproduce the problem, including the version of the library, the environment, and any relevant configuration. Providing a minimal reproducible example can greatly reduce the time and effort required to investigate and fix a problem. Without it, the maintainer may have to spend hours trying to understand and reproduce the problem, which can be frustrating for both the maintainer and the user. It&#39;s important to educate users about the importance of providing a minimal reproducible example, and to communicate this clearly in your project&#39;s documentation. Some maintainers even have a template for issues and/or pull requests that requires the user to provide such an example. It&#39;s also important to be patient and understanding when dealing with users who may not be familiar with the concept of a minimal reproducible example. Maintaining an open source project is a community effort, and it&#39;s important to work together to make the project better. Also, a pull request that includes a negative test case is very valuable. Sometimes it is useful to write a larger guide or blog post that users can go through to avoid basic problems. For example, for using i18next in a React application, we wrote this blog post that covers all the initial issues and hurdles. Remember that as a user of an open source library, you have the power to contribute to its development and make it even better. Don&#39;t be afraid to jump in and make a contribution, no matter how small. Every little bit helps, and it&#39;s a great way to give back to the community. Even if you are not a developer, you can contribute in other ways, such as writing documentation, or helping answer other users&#39; questions. In fact, the best way to get a bug in an open source library fixed is to fix it yourself and submit a pull request. It&#39;s not only a great way to give back to the community, but it also helps you learn new skills and understand the codebase better and learn new skills. So don&#39;t hesitate to roll up your sleeves and get involved. In conclusion, maintaining an open source project is a challenging but rewarding experience. It takes dedication, hard work, and a lot of patience to keep an open source project running smoothly. But the sense of community and collaboration that comes with open source makes it all worthwhile. As a maintainer, it&#39;s important to remember that you&#39;re not alone in this journey, and that there are always other maintainers and contributors willing to help. As a user, remember that you have the power to contribute and make a difference. Open source is a community effort, and everyone plays a role in its success. Maintainers, contributors, and users all have a responsibility to work together to improve the project. Maintainers should be open to feedback and suggestions, and users should provide clear, detailed information about their problems and, if possible, suggest solutions or provide minimal reproducible examples. In short, maintaining an open source project is a challenging but rewarding experience that brings people together to work toward a common goal. It&#39;s important for everyone to work together. So let&#39;s continue to support and contribute to open source projects and make the world a better place, one line of code at a time. Finally, I would like to thank locize for giving us the opportunity to support our i18next community and allowing us to invest in open source activities. Without this support, i18next would not be where it is today. { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\" } },{ \"@type\": \"Question\", \"name\": \"What are the challenges of maintaining an open-source project?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Constantly having to address new issues and pull requests, staying up-to-date with the latest trends and technologies, balancing other commitments and dealing with demanding users are some of the challenges of maintaining an open-source project.\" } },{ \"@type\": \"Question\", \"name\": \"How does one handle demanding users?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The maintainer has the final say on what gets added to the project. It's important to communicate with users, explain reasoning behind decisions and remember that the project is open source and free to use.\" } },{ \"@type\": \"Question\", \"name\": \"What is the feeling of joy and pride in contributing to an open-source project?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Contributing to an open-source project brings a sense of joy and pride from seeing others use and appreciate one's work.\" } },{ \"@type\": \"Question\", \"name\": \"Is maintaining an open-source project always easy?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"No, maintaining an open-source project can be a heavy burden at times due to the constant influx of issues and pull requests and the pressure to constantly improve and update the project.\" } }] }","raw":"---\ntitle: The joy, the pride and the burden of maintaining open source\ndescription: The joy and burden of maintaining an open-source project involves the influx of issues and pull requests, constant improvement, dealing with demanding users, and the importance of providing a minimal reproducible example to reduce time and effort for both maintainers and users, but despite the challenges, it is a rewarding experience that fosters a sense of community and collaboration.\n\ndate: 2023-02-01\ntags:\n  - i18next\n  - l10n\n  - i18n\n  - open-source\n  - github\n  - localization\n  - internationalization\n  - translation\nthumbnail: maintaining-open-source/opensource-title.jpg\n\nlabel: maintaining-open-source\nlang: en\n---\n\n![](opensource-title.jpg)\n\nAs a [maintainer](https://github.com/i18next/i18next/graphs/contributors) of [i18next](https://www.i18next.com), an open-source localization library, I can attest that there is nothing quite like the feeling of joy and pride that comes from contributing to the open-source community. Seeing others use and appreciate your work is a feeling like no other. But with great power comes great responsibility, and maintaining an open-source project can sometimes be a heavy burden at times.\n\nLet me paint you a picture: It's a sunny Sunday afternoon, and you're ready to relax and enjoy the weekend. But then, your phone starts buzzing. It's a notification from [GitHub](https://github.com), alerting you to a new issue or pull request. You try to ignore it, but the nagging **sense of responsibility** sets in. You can't help but wonder, \"What if this is a critical bug that needs to be fixed ASAP?\" And so, you reluctantly open your laptop, ready to tackle the problem at hand. That, my friends, is the joy and the burden of maintaining open source.\n\n![](sunday-interruption.jpg)\n\nBut it's not just the constant **influx of issues and pull requests** that can be overwhelming. It's also the pressure to **constantly improve** and update the project to keep up with the ever-changing technology landscape. With i18next, for example, we need to stay on top of new localization trends and technologies, as well as ensure **compatibility with the latest versions of popular frameworks and libraries**. It can be a lot to keep up with, especially when you're also **trying to balance** a full-time job, family, and other commitments.\n\n![](i18next_ecosystem.webp)\n\nDespite the challenges, maintaining an open-source project is a **rewarding experience** that I wouldn't trade for anything. The sense of community and collaboration is truly special, and it's an **honor to be a part** of something that helps so many people. Plus, there's nothing quite like the **feeling of satisfaction** when you finally fix that tricky bug or implement a new feature that makes the project even better.\n\n![](satisfaction.jpg)\n\nAnother aspect of maintaining an open source project that can be challenging is **dealing with demanding users**. While most users understand and appreciate the hard work that goes into maintaining a project, some can be quite demanding, even threatening to stop using the library if their special request isn't implemented. It can be difficult to navigate these situations, as you want to keep your users happy, but you also need to consider the overall direction and goals of the project. It's important to remember that, as the maintainer, you have the final say over what gets added to the project, and what doesn't. It's also important to communicate with your users, and explain your reasoning behind certain decisions.\n\nWhen maintaining an open source project, remember that **no one is forcing anyone to use it**. While it's important to listen to feedback and try to meet your users' needs, it's also important to remember that the project is open source and free to use. This means that users have the freedom to use the project or not, and they also have the ability to contribute to it, or even fork it if they want to make significant changes. As maintainers, we should always be open to feedback and suggestions, but we must also be confident in our decisions and the direction of the project. We should also remember that most of us are volunteering, and that for most of us, this is a hobby, passion, or side project, not a paid job. We should not burn ourselves out trying to please every user. When users start insisting on **free and ongoing support**, that's not good.\n\nA common challenge in maintaining an open source project is dealing with users who report GitHub **issues without enough information** to reproduce and investigate the problem. Unfortunately, it's not uncommon for users to simply say \"there's a bug\" or \"it doesn't work\" without providing any additional details or context. This can make it extremely difficult for maintainers to understand and fix the problem.\n\nThis is where the concept of a [**minimal reproducible example**](https://minimum-reproduction.wtf/) comes in. A minimal reproducible example is a small, self-contained snippet of code that demonstrates the problem. It should include all the information necessary for the maintainer to reproduce the problem, including the version of the library, the environment, and any relevant configuration.\n\nProviding a minimal reproducible example can greatly reduce the time and effort required to investigate and fix a problem. Without it, the maintainer may have to spend hours trying to understand and reproduce the problem, which can be frustrating for both the maintainer and the user.\n\nIt's important to educate users about the importance of providing a minimal reproducible example, and to communicate this clearly in your project's documentation. Some maintainers even have a **template for issues** and/or pull requests that requires the user to provide such an example.\n\n![](mre.jpg)\n\nIt's also important to be patient and understanding when dealing with users who may not be familiar with the concept of a minimal reproducible example. Maintaining an open source project is a community effort, and it's important to work together to make the project better. Also, a pull request that includes a **negative test case** is very valuable.\n\nSometimes it is useful to write a larger guide or blog post that users can go through to avoid basic problems.\nFor example, for using i18next in a React application, we wrote [this blog post](../react-i18next/) that covers all the initial issues and hurdles.\n\nRemember that as a user of an open source library, you have the power to contribute to its development and make it even better. Don't be afraid to jump in and make a contribution, no matter how small. Every little bit helps, and it's a great way to **give back to the community**. Even if you are not a developer, you can contribute in other ways, such as writing documentation, or helping answer other users' questions.\n\nIn fact, the best way to get a bug in an open source library fixed is to **fix it yourself and submit a pull request**. It's not only a great way to give back to the community, but it also helps you learn new skills and understand the codebase better and learn new skills. So don't hesitate to roll up your sleeves and get involved.\n\nIn conclusion, maintaining an open source project is a challenging but rewarding experience. It takes dedication, hard work, and a lot of patience to keep an open source project running smoothly. But the **sense of community and collaboration** that comes with open source makes it all worthwhile. As a maintainer, it's important to remember that **you're not alone** in this journey, and that there are always other maintainers and contributors willing to help. As a user, remember that you have the **power to contribute** and make a difference.\n\n![](contribute.jpg)\n\nOpen source is a community effort, and **everyone plays a role** in its success. Maintainers, contributors, and users all have a responsibility to work together to improve the project. Maintainers should be open to feedback and suggestions, and users should provide clear, detailed information about their problems and, if possible, suggest solutions or provide minimal reproducible examples.\n\nIn short, maintaining an open source project is a challenging but rewarding experience that brings people together to work toward a common goal. It's important for everyone to work together. So let's continue to support and **contribute to open source projects** and make the world a better place, one line of code at a time.\n\n![](team-work.jpg)\n\nFinally, I would like to thank [locize](https://locize.com/i18next.html#official-sponsor) for giving us the opportunity to support our i18next community and allowing us to invest in open source activities.\nWithout this support, i18next would not be where it is today.\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What are the challenges of maintaining an open-source project?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Constantly having to address new issues and pull requests, staying up-to-date with the latest trends and technologies, balancing other commitments and dealing with demanding users are some of the challenges of maintaining an open-source project.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does one handle demanding users?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The maintainer has the final say on what gets added to the project. It's important to communicate with users, explain reasoning behind decisions and remember that the project is open source and free to use.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is the feeling of joy and pride in contributing to an open-source project?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Contributing to an open-source project brings a sense of joy and pride from seeing others use and appreciate one's work.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Is maintaining an open-source project always easy?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"No, maintaining an open-source project can be a heavy burden at times due to the constant influx of issues and pull requests and the pressure to constantly improve and update the project.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"open-source","slug":"open-source","permalink":"https://locize.com/blog/tags/open-source/"},{"name":"github","slug":"github","permalink":"https://locize.com/blog/tags/github/"}]},{"title":"What is website localization with examples (update)","slug":"website-localization","date":"un22fin22","updated":"un22fin22","comments":true,"path":"website-localization/","link":"","permalink":"https://locize.com/blog/website-localization/","excerpt":"","text":"This is the most comprehensive guide about website localization, the process of adapting an existing website to the language and culture of a target market. This article is specific for websites, if you need more general information, check out our blogpost about software localization. The question is: How can you get the most efficient way to localize your website for your users? This is where the following guide comes into play. Table of contents What is website localization? Why should you be interested in a positive outcome? When is it appropriate to localize your website? Prepare the localization of your website A step-by-step process for web localization Examples: Popular and from our clients How to measure the quality Choose the right platform Conclusion What is website localization? It is part of internationalization and localization and entails much more than just simple text translation; it must take into account all language and cultural variables. If you are selling a decent product in your home market, it is possible that you are also doing so in other countries. If you wish to sell in Spain, for example, your information must be translated into an adapted message in their original language. You understand what website localization is? Now, let&#39;s find out why it&#39;s important: Why should you be interested in a positive outcome? A good website localization may help multinational businesses establish significant brand awareness outside of their home country. People on the internet clearly desire to buy from websites in their own language, as evidenced by several studies. Many firms utilize landingpages for a specific area to provide basic corporate information. This is not the strategy to take since the target audience may perceive a lack of enthusiasm for their location and requirements. Local customers anticipate a website that is identical to the one in your primary market. The localization of a website can increase the revenue of your company. It appears to be an administrative concern in most circumstances, but it is an investment in yourself and your organization. When is it appropriate to localize your website? You&#39;re wondering when to start localizing a site. This varies from firm to company, and a variety of factors can influence when the ideal time is reached. However, there are a few scenarios to bring you to start thinking about it: Your business is launching a new product. You must adhere to market standards. Your company is expanding internationally. Your company establishes a new branch in another country. Your business follows the franchising model. Your business figures are lower in some areas than in others. Your company acts as a global platform. Your company&#39;s global branding strategy is shifting. Prepare the localization of your website Look for a good preparation of your localization strategy, because it will end up in more than just translate some sentence. This process should be part of your overall business strategy, because there are many non-technical-aspects to consider when going into new markets: A step-by-step checklist for the business questions ➡️ Examine the market - is there a possible audience? ➡️ Determine the local compliance needs ➡️ Determine the best technology for localization ➡️ Determine how we will market in the new place ➡️ Decide who is part of the team (lead project manager, marketing expert, developer, etc.) ➡️ Construct a list of quality assurance criteria If you come up with a strong plan and take into account all of the above checkpoints. Then it&#39;s time to go more into the webpage&#39;s details. A step-by-step process for web localization Define the strategy of your website localisation Design the content of all pages with internationalization in mind Execute i18n on your website Arrange your team the right way Translate your webpages Measure the quality and strategy Keep up localization with the right software Keep the following techniques in mind for a successful implementation: Place the language selector correctly Change the formatting design - a sentence in some languages can be substantially longer The curreny should be according to customer need Think about the update of graphic and videos Ensure a proper information architecture Make it easy to update content Think about SEO-Localization - SEO should be done parallel to development (industry standard) Allow website integrations Verify the translations and results Elements to consider on websiteThis list gives you an overview about what you need to keep an eye on when internationalize your website: the text the date and time formats the unit of measurement the holiday seasons the local currency the methods consumer can pay the way an address is written the local letters, symbols, grammar, etc. the plurals the phone numbers the privacy policy the images the videos All information must be given in a genuine manner to other locals so that they feel it is tailored to them. Also, the website&#39;s navigation may vary as visitors from different regions engage differently with your website. Gender-specific words can also be another possibility, which we do not discuss in detail here, but take that in mind. Understanding the language is frequently insufficient, because people will not buy from a webpage in English if it is not their first language. The material must reflect all of their familiar conditions, not just the language. Best practices➡️ More about the topic? Check the website-internationalization-best practices The article highlights effective practices for companies entering foreign markets and requiring website translation. There is a significant distinction between translation and localization. With these ideas, you may save a lot of money and time when your website becomes internationally. Furthermore, the best practices article provides a system for translating content and managing these translations. Examples There are well-known examples all across the world of companies that have effectively implemented multilingual websites as part of their overall business strategy. www.tesla.com was one of the most well-known examples we checked out. They offer a large number of regions from which to choose. They also adjust things like privacy policies and graphics to meet the needs of different locations. They do an excellent job of localizing their website, but it isn&#39;t perfect, and there are certain areas where they could improve. The following improvements are some general areas that, in the author&#39;s view, may be improved by not deeply analyzing their situation. First findingIn the author&#39;s opinion, the language selector is difficult to discover and therefore not well situated for a good website-experience. It&#39;s great that the website displays it based on IP address in advance. Second findingIn the author&#39;s opinion, although switching languages is possible, the user does not receive sufficient tailored info for his intended location. The available Tesla Store Locations are hidden in a bottom menu and are difficult to find. It may help to direct the user&#39;s attention to these Locations, allowing the consumer to feel more home. Third findingIn the author&#39;s opinion, some product description information is tailored to a larger geographic area, such as Europe. It isn&#39;t particular to different areas of Europe; they used the same data across many countries. However, this may be wanted from them, because the efforts would be excessive in comparison to the results they would get. &quot;The product speaks for itself&quot;. The author is unable to conduct a thorough analysis of the technical localization aspects as part of this article. Locize examplesWe, at locize localization management platform, have assisted many customers in achieving their goals with website-localization. The following examples can assist you: 1) globalfinreg.comGlobalfinreg has been able to efficiently localize their two websites thanks to locize. They said locize is for them: An easy-to-use interface for managing translations. It is possible to regulate exactly what each translator sees, and they enjoy doing so. The UI also allows you to easily check which translations are needed and divide your application into separate namespaces. 2) www.redcross.ch Thanks to the generous support and the features of locize, the headless websites of the Swiss Red Cross can be translated into different languages within a short time! Quality ensurance The quality check is essential for the team to get a measurement of where the project is standing in order to provide the correct website-experience. As a result of this, improving any project milestones or refining website content will be beneficial. This should also contain a check to see if the translators did a good job. In some circumstances, contemporary technology such as machine translation will automate the procedure. As a result, human monitoring can assure not only the quality of the language on the website, but also its functionality and site experience. We have the following two areas of testing for localization in the web: Language TestingIs the language properly tested, and are all words correct and understood? Ensure consistency since success and failure can be determined by trust. This list might be useful for testing local language: Wrong use of language Spelling mistakes Restricted words in a culture Non readable sentence Language Errors Localization TestingTesting the localization ensures that your various language site versions work properly. Distribute your testers by newly targeted markets. Check the operation of all web forms and checkout functionality. Also if there is any broken design to fix. A short list you can find below: Check for non-translated strings Long website loading times Wrong date and time format discovered Check for broken strings Check hardware compatibility Ensure Hyperlinks operate Form and Checkout features must be tested Choose the right platform A multilingual website is typically a large undertaking, and using a well-established localization management solution will assist you in completing it more quickly. When choosing a platform, make sure it was created specifically for your needs. You will be able to provide greater user-experience and add appropriate tools as a result of this. ➡️ Watch our introduction video ➡️ Create a new user account for free ➡️ Check out how to add a new project With locize, a modern and economical localization management platform, you can bridge the gap between translation and development. It makes your site, app, game, or whatever project you&#39;re working on more global, dynamic, and engaging, particularly when you use the continuous localization features. While we hope you enjoy our services, we will not lock you into a contract. We believe in the added value of our services, so you can export your translations and utilize them with i18next. If you are a developer, this could be a possibility for you, or you can look at our step-by-step guide for JavaScript localization Conclusion Consumers have a clear requirement for a website that is tailored to customized and localized content. As a result, the localization of a site is the tech-part for any company looking to expand into new areas or market segment. As we have built it up for you, it must comprise a good business strategy, which is the starting point for a solid technological implementation. Global brands do itAs you can see from our real-world examples, the most well-known organizations in any industry have used website localization. As a result, you should address it as soon as possible in your company&#39;s internationalization process. It is significant due to the commitment your organization would make to potential clients in the newly targeted area. Users will appreciate itYour target audience will thank you by buying your product or service. In this market, your company&#39;s brand awareness will grow as well, which is essential for internet business success. Use this guideThe &quot;How to locize your website?&quot; is easy to answer, select the right platform for your needs and plan all steps needed for the language localization in advance. Keep it organizedThe localization management platform can assist you in remaining organized and adaptable during your continuous-localization. Why locize should be your choiceOur team has considerable experience to assist you with your project or development needs, thanks to many customers that we assisted with the localization of their website. We&#39;ve also supplied the most valuable pricing of our website localization services because of our many years of expertise with these consumers, and we don&#39;t require you to sign long-term contracts.","raw":"---\ntitle: What is website localization with examples (update)\ndescription: What is website localization and how can you achieve it step by step? Using this checklist, you might learn from successful cases.\n\ndate: 2023-01-31\ntags: \n  - guide\n  - localization techniques\n  - refining website content\n  - best practices\n  - native language\n  - localization project\nthumbnail: website-localization/website-localization.webp\n\nlabel: website-localization\nlang: en\n---\n\n\n![website localization](website-localization.webp)\n\n\nThis is the most comprehensive guide about **website localization**,  the process of **adapting an existing website to the language and culture of a target market**. \n\nThis article is specific for websites, if you need more general information, check out our blogpost about [software localization](../what-is-software-localization/).\n\n<b>The question is: How can you get the most efficient way to localize your website for your users? This is where the following guide comes into play.</b> \n\n## Table of contents\n  * [What is website localization?](#weblocalization)\n  * [Why should you be interested in a positive outcome?](#good-outcome)\n  * [When is it appropriate to localize your website?](#right-time)\n  * [Prepare the localization of your website](#half-done)\n  * [A step-by-step process for web localization](#step-by-step)\n  * [Examples: Popular and from our clients](#examples)\n  * [How to measure the quality](#quality)\n  * [Choose the right platform](#platform)\n  * [Conclusion](#conclusion)\n\n\n\n## What is website localization? <a name=\"weblocalization\"></a>\nIt is part of internationalization and localization and entails much more than just simple text translation; it must take into account all language and cultural variables. If you are selling a decent product in your home market, it is possible that you are also doing so in other countries. If you wish to sell in Spain, for example, your information must be translated into an adapted message in their original language. \n\nYou understand what website localization is? Now, let's find out why it's important:\n\n\n \n## Why should you be interested in a positive outcome? <a name=\"good-outcome\"></a>\n\nA good website localization may help [multinational businesses](https://www.investopedia.com/terms/m/multinationalcorporation.asp)  establish significant brand awareness outside of their home country.\n\n<b>People on the internet clearly desire to buy from websites in their own language</b>, as evidenced by several [studies](https://insights.csa-research.com/reportaction/305013126/Marketing). Many firms utilize landingpages for a specific area to provide basic corporate information. \n\nThis is not the strategy to take since the target audience may perceive a lack of enthusiasm for their location and requirements. Local customers anticipate a website that is identical to the one in your primary market.\n\n![fifty-two-percent](fifty-two-percent.webp)\n\nThe localization of a <b>website can increase the revenue</b> of your company. It appears to be an administrative concern in most circumstances, but it is an investment in yourself and your organization.\n\n\n## When is it appropriate to localize your website? <a name=\"right-time\"></a>\n\nYou're wondering when to start localizing a site. This varies from firm to company, and a variety of factors can influence when the ideal time is reached.\n\nHowever, there are a few scenarios to bring you to start thinking about it:\n\n- Your business is launching a new product.\n- You must adhere to market standards.\n- Your company is expanding internationally.\n- Your company establishes a new branch in another country.\n- Your business follows the franchising model.\n- Your business figures are lower in some areas than in others.\n- Your company acts as a global platform.\n- Your company's global branding strategy is shifting.\n\n \n## Prepare the localization of your website <a name=\"half-done\"></a>\n\nLook for a good preparation of your <a href=\"../localization-strategy/\" title=\"localization strategy\">localization strategy</a>, because it will end up in more than just translate some sentence. This process should be part of your overall business strategy, because there are many non-technical-aspects to consider when going into new markets:\n\n\n### A step-by-step checklist for the business questions\n\n  ➡️ Examine the market - is there a possible audience?\n\n  ➡️ Determine the local compliance needs\n\n  ➡️ Determine the best technology for localization\n\n  ➡️ Determine how we will market in the new place\n\n  ➡️ Decide who is part of the team (lead project manager, marketing expert, developer, etc.)\n\n  ➡️ Construct a list of quality assurance criteria\n\n\nIf you come up with a strong plan and take into account all of the above checkpoints. Then it's time to go more into the webpage's details.\n\n\n## A step-by-step process for web localization <a name=\"step-by-step\"></a>\n\n1. [Define the strategy](#half-done)  of your website localisation \n2. Design the content of all pages with internationalization in mind\n3. Execute <a href=\"../what-is-i18n/\" title=\"i18n\">i18n</a> on your website\n4. Arrange your team the right way\n5. Translate your webpages\n6. [Measure the quality](#quality) and strategy\n7. Keep up localization with the [right software](#platform)\n\n\n\nKeep the following techniques in mind for a successful implementation:\n\n* Place the language selector correctly\n* Change the formatting design - a sentence in some languages can be substantially longer\n* The curreny should be according to customer need\n* Think about the update of graphic and videos\n* Ensure a proper [information architecture](https://www.usability.gov/what-and-why/information-architecture.html)\n* Make it easy to update content\n* Think about SEO-Localization - SEO should be done parallel to development (industry standard)\n* Allow website integrations\n* Verify the translations and results\n\n\n### Elements to consider on website \n\nThis list gives you an overview about what you need to keep an eye on when internationalize your website:\n\n* the text\n* the date and time formats\n* the unit of measurement\n* the holiday seasons\n* the local currency\n* the methods consumer can pay \n* the way an address is written\n* the local letters, symbols, grammar, etc.\n* the plurals\n* the phone numbers\n* the privacy policy\n* the images\n* the videos\n\n\nAll information must be given in a genuine manner to other locals so that they feel it is tailored to them. Also, the website's navigation may vary as visitors from different regions engage differently with your website. Gender-specific words can also be another possibility, which we do not discuss in detail here, but take that in mind. \n\nUnderstanding the language is frequently insufficient, because people will not buy from a webpage in English if it is not their first language. The material must reflect all of their familiar conditions, not just the language. \n\n### Best practices\n\n➡️ More about the topic? Check the [website-internationalization-best practices](../website-internationalization-best-practices/)\n\nThe article highlights effective practices for companies entering foreign markets and requiring website translation. There is a significant distinction between translation and localization. With these ideas, you may save a lot of money and time when your website becomes internationally. Furthermore, the best practices article provides a system for translating content and managing these translations.\n\n![Create considerable brand awareness](establish.webp)\n\n## Examples <a name=\"examples\"></a>\n\n\nThere are well-known examples all across the world of <b>companies that have effectively implemented multilingual websites</b> as part of their overall business strategy. [www.tesla.com](https://www.tesla.com/) was one of the most well-known examples we checked out. \n\nThey offer a large number of regions from which to choose. They also adjust things like privacy policies and graphics to meet the needs of different locations. They do an excellent job of localizing their website, but it isn't perfect, and there are certain areas where they could improve. \n\nThe following improvements are some general areas that, in the author's view, may be improved by not deeply analyzing their situation. \n\n##### First finding \nIn the author's opinion, the language selector is difficult to discover and therefore not well situated for a good [website-experience](https://blog.hubspot.com/marketing/improve-your-websites-user-experience/). It's great that the website displays it based on IP address in advance.\n\n##### Second finding \nIn the author's opinion, although switching languages is possible, the user does not receive sufficient tailored info for his intended location. The available Tesla Store Locations are hidden in a bottom menu and are difficult to find. It may help to direct the user's attention to these Locations, allowing the consumer to feel more home.\n\n##### Third finding \nIn the author's opinion, some product description information is tailored to a larger geographic area, such as Europe. It isn't particular to different areas of Europe; they used the same data across many countries. However, this may be wanted from them, because the efforts would be excessive in comparison to the results they would get. \"The product speaks for itself\".\n\nThe author is unable to conduct a thorough analysis of the technical localization aspects as part of this article.\n\n\n### Locize examples\n\nWe, at locize [localization management platform](/), <b>have assisted many customers in achieving their goals with website-localization</b>. The following examples can assist you:\n\n#### 1) [globalfinreg.com](https://globalfinreg.com/)\nGlobalfinreg has been able to efficiently localize their two websites thanks to [locize](/). They said locize is for them:\n\n>An easy-to-use interface for managing translations. It is possible to regulate exactly what each translator sees, and they enjoy doing so. The UI also allows you to easily check which translations are needed and divide your application into separate namespaces.\n\n<a href=\"https://globalfinreg.com/\" title=\"globalfinreg\">![globalfinreg](finreg.png \"globalfinreg\")</a>\n\n#### 2) [www.redcross.ch](https://support.redcross.ch)\n\n>Thanks to the generous support and the features of locize, the headless websites of the Swiss Red Cross can be translated into different languages within a short time!\n\n<a href=\"https://support.redcross.ch\" title=\"swiss red cross\">![swiss red cross](redcross.svg \"redcross\")</a>\n\n## Quality ensurance <a name=\"quality\"></a>\n\nThe quality check is essential for the team to get a measurement of where the project is standing in order to provide the correct website-experience. As a result of this, improving any project milestones or refining website content will be beneficial. This should also contain a check to see if the translators did a good job. \n\nIn some circumstances, contemporary technology such as machine translation will automate the procedure. As a result, human monitoring can assure not only the quality of the language on the website, but also its functionality and site experience.\n\nWe have the following two areas of testing for localization in the web:\n\n### Language Testing\nIs the language properly tested, and are all words correct and understood? Ensure consistency since success and failure can be determined by trust. This list might be useful for testing local language:\n\n* Wrong use of language\n* Spelling mistakes\n* Restricted words in a culture\n* Non readable sentence\n* Language Errors\n\n\n### Localization Testing\nTesting the localization ensures that your various language site versions work properly. Distribute your testers by newly targeted markets. \n\nCheck the operation of all web forms and checkout functionality. Also if there is any broken design to fix. A short list you can find below:\n\n* Check for non-translated strings \n* Long website loading times \n* Wrong date and time format discovered \n* Check for broken strings \n* Check hardware compatibility \n* Ensure Hyperlinks operate \n* Form and Checkout features must be tested\n\n\n\n## Choose the right platform <a name=\"platform\"></a>\n\nA multilingual website is typically a large undertaking, and using a well-established localization management solution will assist you in completing it more quickly. When choosing a platform, make sure it was created specifically for your needs. You will be able to provide greater user-experience and add appropriate tools as a result of this.\n\n➡️ [Watch our introduction video](https://docs.locize.com/)\n\n➡️ [Create a new user account for free](https://www.locize.app/register)\n\n➡️ [Check out how to add a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n\n\nWith locize, a modern and economical [localization management platform](https://locize.com), you can bridge the gap between translation and development. It makes your site, app, game, or whatever project you're working on more global, dynamic, and engaging, particularly when you use the continuous localization features.\n\nWhile we hope you enjoy our services, we will not lock you into a contract. We believe in the added value of our services, so you can export your translations and utilize them with [i18next](https://www.i18next.com/). If you are a developer, this could be a possibility for you, or you can look at our step-by-step guide for [JavaScript localization](/javascript-localization.html)\n\n\n![locize](locize-project.png \"locize\")\n\n\n## Conclusion <a name=\"conclusion\"></a>\n\nConsumers have a clear requirement for a website that is tailored to customized and localized content. As a result, the localization of a site is the tech-part for any company looking to expand into new areas or market segment. As we have built it up for you, it must comprise a good business strategy, which is the starting point for a solid technological implementation.\n\n\n### Global brands do it\n\nAs you can see from our real-world examples, the most well-known organizations in any industry have used website localization. As a result, <b>you should address it as soon as possible</b> in <b>your company's internationalization process</b>. It is significant due to the commitment your organization would make to potential clients in the newly targeted area. \n\n### Users will appreciate it\nYour target audience will thank you by buying your product or service. In this market, your company's brand awareness will grow as well, which is essential for internet business success.\n\n### Use this guide\n\nThe \"How to locize your website?\" is <b>easy to answer, select the right platform for your needs</b> and plan all steps needed for the <a href=\"../language-localization/\" title=\"language localization\">language localization</a> in advance. \n\n\n### Keep it organized\nThe [localization management platform](/) can assist you in remaining organized and adaptable during your continuous-localization.\n\n\n## Why locize should be your choice \nOur team has considerable experience to assist you with your project or development needs, thanks to many [customers](/customers.html) that we assisted with the localization of their website. \n\nWe've also supplied the <b>most valuable pricing</b> of our [website localization services](/website-localization-services.html) because of our many years of expertise with these consumers, and we don't require you to sign long-term contracts.\n\n\n\n\n","categories":[],"tags":[{"name":"best practices","slug":"best-practices","permalink":"https://locize.com/blog/tags/best-practices/"},{"name":"guide","slug":"guide","permalink":"https://locize.com/blog/tags/guide/"},{"name":"localization techniques","slug":"localization-techniques","permalink":"https://locize.com/blog/tags/localization-techniques/"},{"name":"refining website content","slug":"refining-website-content","permalink":"https://locize.com/blog/tags/refining-website-content/"},{"name":"native language","slug":"native-language","permalink":"https://locize.com/blog/tags/native-language/"},{"name":"localization project","slug":"localization-project","permalink":"https://locize.com/blog/tags/localization-project/"}]},{"title":"7 steps to master translation project management (2023)","slug":"translation-project-management","date":"un55fin55","updated":"un00fin00","comments":true,"path":"translation-project-management/","link":"","permalink":"https://locize.com/blog/translation-project-management/","excerpt":"","text":"Are you looking to improve the efficiency and success of your translation projects? Look no further! In this guide, we will walk you through 7 proven steps to master translation project management. So, let&#39;s get started and unlock the secrets to a successful language translation management. Table of contents How to plan project management for translation Streamline your translation project with a tool This guide will provide you with the project management tools and information you need to take your translation projects to the next level. This includes defining the project&#39;s scope and needs, as well as selecting the best team and tools to deliver high-quality translations on time and on budget. Whether you&#39;re a seasoned pro or just starting out in the world of translation project management, these steps will help you streamline your workflow, increase collaboration, and ultimately deliver better results for your clients. How to plan project management for translation The first step in any translation project is to assess the client&#39;s needs. This includes determining the target languages, the type of content that needs to be translated, and any specific requirements or constraints that need to be taken into account. Once these details have been established, the project manager can create a project plan outlining the steps that need to be taken to complete the project on time and within budget. Budget allocation for the project Define the scope and requirements Team and responsibilities Find the translators Define the project plan Review the work Translation delivery 1. Budget allocation for translation projectsThe translation project&#39;s budget should be established early in the planning phase. This will help to ensure that adequate resources are given for the project and that possible cost overruns are detected and handled before they occur. Generally, the costs of a translation process can be as follows: Cost of required tools and software (licenses) project managers&#39; and translators&#39; fees Continuing costs for tasks such as translation, editing, proofreading, and formatting, as well as quality assurance, testing, and localization. The cost of any required equipment, technology, additional services, and travel charges. Costs for any required software integration, third-party vendor services, training, and legal and regulatory needs. 2. What is required in the projectDefining the scope and requirements of a translation project is crucial for ensuring that all stakeholders have a clear understanding of the project&#39;s expectations. This includes determining: The types of content that will be translated, whether it is text from a website, a document or any other file. The target languages for the project and taking into consideration the unique characteristics of each language. The expertise of the translators needed for the project, such as subject-matter experts, depending on the content&#39;s industry. 3. Define who is responsible for which tasks in the projectA project team should be assembled, with clear roles and responsibilities assigned to each team member. This includes identifying a project manager or coordinator who will oversee the project, as well as translators, editors, and any other team members who will be involved in the project. 4. Find the translatorsOne of the most important aspects of translation management is selecting the right translators for the job. The project manager will need to assess the translators&#39; qualifications, experience, and expertise to ensure that they have the right skills to handle the content that needs to be translated. These professionals will also need to coordinate with the translators to ensure that they are aware of the project&#39;s timelines and deliverables. 5. Define the project planAnother key aspect of translation project management is managing the timeline and budget of the project. This includes setting deadlines for each stage of the project, such as translation, editing, and proofreading, and ensuring that these deadlines are met. The project manager will also need to monitor the progress of the project and take any necessary steps to keep it on track. 6. Review the workQuality assurance is also a critical part of project management in translation. The professionals will need to ensure that the final translated content meets the client&#39;s expectations and is of high quality. This may involve conducting a review of the translated content, or working with a team of editors and proofreaders to ensure that the content is error-free and accurate. 7. Translation deliveryThe final translated content should be delivered to the client in the appropriate format and in a timely manner. Any necessary final adjustments should be made at this time, and the project should be closed out according to the project plan. Streamline your translation project with a toolFor a translation project, the management can be essentially improved with following features: Translation managementAllows customers to post and manage their content under a single dashboard, as well as collaborate with and assess translators&#39; work. In-context editingThis feature enables users to modify translations directly within the context of their website or application, which can assist verify that translations are accurate and suitable. Machine translationThis technology uses machine learning algorithms to automatically translate text, saving time and effort. Translation memoryRemembers previous translations and offers them when comparable information is encountered, so ensuring consistency and reducing the need for retranslation. VersioningAllows users to keep track of changes to translations over time and, if necessary, roll back to previous versions. AnalyticsProvides information on how translations are used and how people interact with them, which can aid in the localization process. Locize, the management system for translations and localization, is designed to interact with a wide number of platforms and tools, including website builders, content management systems, and software development kits. Locize: What is it Locize is a cloud-based translation management system that enables teams to cooperate on website and app localization. To help with the localization process, it includes capabilities like machine translation, translation memory, and terminology management. It also has an API and integration possibilities for a variety of development frameworks and platforms. Locize is also a localization software that provides a variety of features for managing and translating website and application content. Now we&#39;d like to hand it on to you: Do you have a plan for your translation workflow or project? We can handle the project more efficiently if we work together. If you are already experienced with integrating our solution into your technology stack, we are now offering a 14-day free trial period. Simply join our platform below to get started! register Learn more ConclusionTo summarize, translation project management is a difficult process that necessitates precise organization and attention to detail. Coordination with translators, management of timetables and budgets, and ensuring that the final result fulfills the client&#39;s expectations are all part of the job. Translation project managers may help guarantee that localization projects are finished on time and under budget, while also ensuring that the end result is of high quality by following the best practices and utilizing the appropriate tools. To increase the accuracy and efficiency of the translation process, the translation industry is facing rule-based automation and artificial intelligence.","raw":"---\ntitle: 7 steps to master translation project management (2023)\ndescription: A step-by-step tutorial providing advice on how to master translation project management. Further tips on being more efficient.\n\ndate: 2023-01-20\ntags:\n  - language translation\n  - project management\n  - translation tools\n  - translation management\nthumbnail: translation-project-management/translation-project-management.webp\n---\n\n![](translation-project-management.webp \"translation project management\")\n\nAre you looking to improve the efficiency and success of your translation projects? \nLook no further! In this guide, we will walk you through 7 proven steps to master translation project management. \n\n\n\nSo, let's get started and unlock the secrets to a successful language translation management.\n\n\n## Table of contents\n  * [How to plan project management for translation](#plan)\n  * [Streamline your translation project with a tool](#streamline)\n\nThis guide will provide you with the project management tools and information you need to take your translation projects to the next level. \n\nThis includes defining the project's scope and needs, as well as selecting the best team and tools to deliver high-quality translations on time and on budget.\n\nWhether you're a seasoned pro or just starting out in the world of translation project management, these steps will help you streamline your workflow, increase collaboration, and ultimately deliver better results for your clients.\n\n## How to plan project management for translation <a name=\"plan\"></a>\nThe first step in any translation project is to assess the client's needs. This includes determining the target languages, the type of content that needs to be translated, and any specific requirements or constraints that need to be taken into account. \n\nOnce these details have been established, the project manager can create a project plan outlining the steps that need to be taken to complete the project on time and within budget.\n\n1. Budget allocation for the project\n2. Define the scope and requirements\n3. Team and responsibilities\n4. Find the translators\n5. Define the project plan\n6. Review the work\n7. Translation delivery\n\n\n![](project-management-tools.webp \"project management tools\")\n\n\n### 1. Budget allocation for translation projects\nThe translation project's budget should be established early in the planning phase. This will help to ensure that adequate resources are given for the project and that possible cost overruns are detected and handled before they occur.\n\nGenerally, the costs of a translation process can be as follows:\n\n\n* Cost of required tools and software (licenses) project managers' and translators' fees\n* Continuing costs for tasks such as <a target=\"__blank\" href=\"https://en.wikipedia.org/wiki/Translation\" title=\"translation\">translation</a>, editing, <a target=\"__blank\" href=\"https://dictionary.cambridge.org/de/worterbuch/englisch/proofreading\" title=\"proofreading\">proofreading</a>, and formatting, as well as quality assurance, testing, and <a href=\"../localization\" title=\"localization\">localization</a>.\n* The cost of any required equipment, technology, additional services, and travel charges.\n* Costs for any required software integration, third-party vendor services, training, and legal and regulatory needs.\n\n\n### 2. What is required in the project\nDefining the scope and requirements of a translation project is crucial for ensuring that all stakeholders have a clear understanding of the project's expectations. This includes determining:\nThe types of content that will be translated, whether it is text from a website, a document or any other file.\n\nThe target languages for the project and taking into consideration the unique characteristics of each language. \nThe expertise of the translators needed for the project, such as subject-matter experts, depending on the content's industry.\n\n\n### 3. Define who is responsible for which tasks in the project\nA project team should be assembled, with clear roles and responsibilities assigned to each team member. This includes identifying a <a target=\"__blank\" href=\"https://www.forbes.com/advisor/business/software/what-is-a-project-manager/\" title=\"project manager\">project manager</a> or coordinator who will oversee the project, as well as translators, editors, and any other team members who will be involved in the project.\n\n### 4. Find the translators\nOne of the most important aspects of translation management is selecting the right translators for the job. \n\nThe project manager will need to assess the translators' qualifications, experience, and expertise to ensure that they have the right skills to handle the content that needs to be translated. \n\nThese professionals will also need to coordinate with the translators to ensure that they are aware of the project's timelines and deliverables.\n\n### 5. Define the project plan\nAnother key aspect of translation project management is managing the timeline and budget of the project. This includes setting deadlines for each stage of the project, such as translation, editing, and proofreading, and ensuring that these deadlines are met. \n\nThe project manager will also need to monitor the progress of the project and take any necessary steps to keep it on track.\n\n### 6. Review the work\nQuality assurance is also a critical part of project management in translation. The professionals will need to ensure that the final translated content meets the client's expectations and is of high quality. \n\nThis may involve conducting a review of the translated content, or working with a team of editors and proofreaders to ensure that the content is error-free and accurate.\n\n### 7. Translation delivery\nThe final translated content should be delivered to the client in the appropriate format and in a timely manner. Any necessary final adjustments should be made at this time, and the project should be closed out according to the project plan.\n\n\n## Streamline your translation project with a tool<a name=\"streamline\"></a>\n\nFor a translation project, the management can be essentially improved with following features:\n\n#### Translation management\nAllows customers to post and manage their content under a single dashboard, as well as collaborate with and assess translators' work.\n\n#### In-context editing\nThis feature enables users to modify translations directly within the context of their website or application, which can assist verify that translations are accurate and suitable.\n\n#### Machine translation\nThis technology uses machine learning algorithms to automatically translate text, saving time and effort.\n\n#### Translation memory\nRemembers previous translations and offers them when comparable information is encountered, so ensuring consistency and reducing the need for retranslation.\n\n#### Versioning\nAllows users to keep track of changes to translations over time and, if necessary, roll back to previous versions.\n\n#### Analytics\nProvides information on how translations are used and how people interact with them, which can aid in the localization process.\n\n{% youtube ds-yEEYP1Ks %}\n\nLocize, the management system for translations and localization, is designed to interact with a wide number of platforms and tools, including website builders, content management systems, and software development kits.\n\n## Locize: What is it <a name=\"nextlevel\"></a>\nLocize is a cloud-based <a href=\"../tms/\" title=\"translation management system\">translation management system</a> that enables teams to cooperate on website and app localization. \n\nTo help with the localization process, it includes capabilities like machine translation, translation memory, and terminology management. It also has an API and integration possibilities for a variety of development frameworks and platforms.\n\nLocize is also a <a href=\"/\" title=\"localization software\">localization software</a> that provides a variety of features for managing and translating website and application content.\n\nNow we'd like to hand it on to you:\n\nDo you have a plan for your translation workflow or project?\n\nWe can handle the project more efficiently if we work together.\n\nIf you are already experienced with integrating our solution into your technology stack, we are now offering a 14-day free trial period. Simply join our platform below to get started!\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://www.locize.app/register\" title=\"register to locize\">register</a> <a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://docs.locize.com/\" title=\"learn more\">Learn more</a>\n\n## Conclusion\n\nTo summarize, translation project management is a difficult process that necessitates precise organization and attention to detail. \n\nCoordination with translators, management of timetables and budgets, and ensuring that the final result fulfills the client's expectations are all part of the job. \n\nTranslation project managers may help guarantee that localization projects are finished on time and under budget, while also ensuring that the end result is of high quality by following the best practices and utilizing the appropriate tools.\n\nTo increase the accuracy and efficiency of the translation process, the <a href=\"/services.html#translationservices\" title=\"translation industry\">translation industry</a> is facing rule-based automation and artificial intelligence.\n\n","categories":[],"tags":[{"name":"translation management","slug":"translation-management","permalink":"https://locize.com/blog/tags/translation-management/"},{"name":"language translation","slug":"language-translation","permalink":"https://locize.com/blog/tags/language-translation/"},{"name":"project management","slug":"project-management","permalink":"https://locize.com/blog/tags/project-management/"},{"name":"translation tools","slug":"translation-tools","permalink":"https://locize.com/blog/tags/translation-tools/"}]},{"title":"Unleashing the Full Potential of i18next: Tips and Tricks","slug":"i18next-tips-and-tricks","date":"un22fin22","updated":"un44fin44","comments":true,"path":"i18next-tips-and-tricks/","link":"","permalink":"https://locize.com/blog/i18next-tips-and-tricks/","excerpt":"","text":"Internationalization (i18n) and localization (l10n) are important aspects of any web or mobile application. i18next is a powerful JavaScript library that makes it easy to handle i18n and l10n in your application. In this post, we&#39;ll explore some tips and tricks for using i18next to its full potential. Unlock the secrets of successful translations with i18next. Explore advanced tips and techniques to handle complex translation scenarios. From pluralization to context-based translations, this guide will empower you to deliver accurate and culturally appropriate content. 1. Use the namespace feature:One of the most powerful features of i18next is the ability to use namespaces. Namespaces allow you to separate your translations into different groups, making it easier to organize and manage your translations. For example, you can create a namespace for each feature or module in your application, making it easier to update and maintain translations for that specific feature. Check out this section in the video crash course! 2. Utilize pluralization:i18next also has built-in support for pluralization, making it easy to handle different plural forms of a word in different languages. To use this feature, simply specify the different plural forms of a word in your translation file and i18next will automatically use the correct form based on the current language and count. Check out this section in the video crash course! 3. Take advantage of interpolation:i18next supports interpolation, that allows you to insert dynamic values into your translations. This can be useful for displaying user-specific information, such as a username or a date. To use interpolation, simply include placeholders in your translation string, and pass an object containing the values to i18next. Check out this section in the video crash course! 4. Handle fallbacks:i18next provides several fallback options to handle missing translations. Language fallback: you can specify a fallback language in case the current language is not available. Namespace fallback: you can specify a fallback namespace in case the current namespace is not available. Key fallback: you can specify a fallback key in case the current key is not available. 5. Use a language detector:i18next-browser-languagedetector is a plugin that detects the user&#39;s preferred language based on their browser settings. This can be very useful for providing a better user experience by automatically displaying the website in the user&#39;s preferred language. 6. Leverage i18next backend plugins:i18next offers several backend plugins that allow you to load translations from various sources, such as a JSON file, a remote server, or a database. This can be useful for loading translations on demand or for providing an offline mode for your application. Some examples of i18next backend plugins include i18next-http-backend and i18next-fs-backend. With the help of i18next-chained-backend you could also combine different backends to create fallbacks or caching concepts. 7. Use the context feature:i18next provides a context feature which allows you to provide additional context information for a translation in order to disambiguate between different translations of the same key. This can be useful when a word or phrase can have multiple meanings and the context helps to disambiguate the intended meaning. For example, providing gender-specific translations, like &quot;he&quot; and &quot;she&quot; for a specific phrase. 8. Use different i18n formats:i18next supports different i18n formats such as ICU message format which is widely used in Java and C++. This allows you to use the same translations across different platforms and technologies. To use different i18n formats, you can use i18next plugins such as i18next-icu. 9. Integrate with locize:locize is a cloud-based translation management system (TMS) that integrates seamlessly with i18next. By using locize, you can easily manage your translations and collaborate with translators and editors. locize also provides a powerful editor and a translation memory, making it easy to reuse translations and ensure consistency across your application. To integrate locize with i18next, you can for example use the i18next-locize-backend plugin. This plugin allows you to load translations from the locize CDN and automatically syncs them with your application. Here you can see what this could look like. Check out this section in the video crash course! Conclusion:In this post, we&#39;ve explored some tips and tricks for using i18next to its full potential. By using namespaces, pluralization, interpolation, fallbacks, i18next-browser-languagedetector, leveraging i18next backend plugins and context feature, you can provide a better user experience for your users. Integrating it with locize allows you to easily manage your translations and collaborate with translators and editors. With i18next, you have all the tools you need to make your application truly international. If you&#39;re new to i18next, you might check out the complete free i18next crash course video:","raw":"---\ntitle: \"Unleashing the Full Potential of i18next: Tips and Tricks\"\ndescription: In this article, we explore tips and tricks on how to use i18next, a powerful JavaScript library, to handle internationalization and localization effectively by utilizing features such as namespaces, pluralization, interpolation, fallbacks, context feature and integration with locize to deliver a better user experience.\n\ndate: 2023-01-17\ntags:\n  - i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: i18next-tips-and-tricks/title.jpg\n---\n\n![](title.jpg)\n\nInternationalization ([i18n](../what-is-i18n/)) and localization ([l10n](../localization/)) are important aspects of any web or mobile application. i18next is a powerful JavaScript library that makes it easy to handle i18n and l10n in your application. In this post, we'll explore some tips and tricks for using [i18next](https://www.i18next.com) to its full potential.\n\n>Unlock the secrets of successful translations with i18next. Explore advanced tips and techniques to handle complex translation scenarios. From pluralization to context-based translations, this guide will empower you to deliver accurate and culturally appropriate content.\n\n## 1. Use the namespace feature:\n\nOne of the most powerful features of i18next is the ability to use namespaces. [Namespaces](https://www.i18next.com/principles/namespaces) allow you to separate your translations into different groups, making it easier to organize and manage your translations. For example, you can create a namespace for each feature or module in your application, making it easier to update and maintain translations for that specific feature.\n<br />\n*Check out [this section in the video](https://youtu.be/SA_9i4TtxLQ?t=314) crash course!*\n\n## 2. Utilize pluralization:\n\ni18next also has built-in support for [pluralization](https://www.i18next.com/translation-function/plurals), making it easy to handle different plural forms of a word in different languages. To use this feature, simply specify the different plural forms of a word in your translation file and i18next will automatically use the correct form based on the current language and count.\n<br />\n*Check out [this section in the video](https://youtu.be/SA_9i4TtxLQ?t=485) crash course!*\n\n## 3. Take advantage of interpolation:\n\ni18next supports [interpolation](https://www.i18next.com/translation-function/interpolation), that allows you to insert dynamic values into your translations. This can be useful for displaying user-specific information, such as a username or a date. To use interpolation, simply include placeholders in your translation string, and pass an object containing the values to i18next.\n<br />\n*Check out [this section in the video](https://youtu.be/SA_9i4TtxLQ?t=433) crash course!*\n\n## 4. Handle fallbacks:\n\ni18next provides several [fallback](https://www.i18next.com/principles/fallback) options to handle missing translations.\n\n- [Language fallback](https://www.i18next.com/principles/fallback#language-fallback): you can specify a fallback language in case the current language is not available.\n- [Namespace fallback](https://www.i18next.com/principles/fallback#namespace-fallback): you can specify a fallback namespace in case the current namespace is not available.\n- [Key fallback](https://www.i18next.com/principles/fallback#key-fallback): you can specify a fallback key in case the current key is not available.\n\n## 5. Use a [language detector](https://www.i18next.com/overview/plugins-and-utils#language-detector):\n\n[i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) is a plugin that detects the user's preferred language based on their browser settings. This can be very useful for providing a better user experience by automatically displaying the website in the user's preferred language.\n\n## 6. Leverage i18next backend plugins:\n\ni18next offers several [backend plugins](https://www.i18next.com/overview/plugins-and-utils#backends) that allow you to load translations from various sources, such as a JSON file, a remote server, or a database. This can be useful for loading translations on demand or for providing an offline mode for your application. Some examples of i18next backend plugins include [i18next-http-backend](https://github.com/i18next/i18next-http-backend) and [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend). With the help of [i18next-chained-backend](https://github.com/i18next/i18next-chained-backend) you could also combine different backends to create [fallbacks](https://www.i18next.com/how-to/backend-fallback) or [caching](https://www.i18next.com/how-to/caching) concepts.\n\n## 7. Use the context feature:\n\ni18next provides a [context feature](https://www.i18next.com/translation-function/context) which allows you to provide additional context information for a translation in order to disambiguate between different translations of the same key. This can be useful when a word or phrase can have multiple meanings and the context helps to disambiguate the intended meaning. For example, providing gender-specific translations, like \"he\" and \"she\" for a specific phrase.\n\n## 8. Use different i18n formats:\n\ni18next supports different [i18n formats](https://www.i18next.com/overview/plugins-and-utils#i18n-formats) such as [ICU message](../i18n-formats-javascript/#icu) format which is widely used in Java and C++. This allows you to use the same translations across different platforms and technologies. To use different i18n formats, you can use i18next plugins such as [i18next-icu](https://github.com/i18next/i18next-icu).\n\n## 9. Integrate with locize:\n\n[locize](/) is a cloud-based translation management system ([TMS](../tms/)) that integrates seamlessly with [i18next](https://www.i18next.com). By using locize, you can easily manage your translations and collaborate with translators and editors. locize also provides a powerful [editor](https://docs.locize.com/different-views) and a [translation memory](https://docs.locize.com/whats-inside/translation-memory), making it easy to reuse translations and ensure consistency across your application.\nTo integrate locize with i18next, you can for example use the [i18next-locize-backend](https://github.com/locize/i18next-locize-backend) plugin. This plugin allows you to load translations from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network) and automatically syncs them with your application. [Here](https://youtu.be/ds-yEEYP1Ks?t=423) you can see what this could look like.\n<br />\n*Check out [this section in the video](https://youtu.be/SA_9i4TtxLQ?t=1076) crash course!*\n\n## Conclusion:\n\nIn this post, we've explored some tips and tricks for using i18next to its full potential. By using namespaces, pluralization, interpolation, fallbacks, i18next-browser-languagedetector, leveraging i18next backend plugins and context feature, you can provide a better user experience for your users. Integrating it with [locize](/) allows you to easily manage your translations and collaborate with translators and editors. With i18next, you have all the tools you need to make your application truly international.\nIf you're new to i18next, you might check out [the complete free i18next crash course video](https://youtu.be/SA_9i4TtxLQ):\n\n{% youtube SA_9i4TtxLQ %}","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"}]},{"title":"How to build a scalable localization strategy for your fast-growing tech company","slug":"scalable-localization-strategy","date":"un22fin22","updated":"un22fin22","comments":true,"path":"scalable-localization-strategy/","link":"","permalink":"https://locize.com/blog/scalable-localization-strategy/","excerpt":"","text":"As the CTO, manager or tech lead of a fast-growing tech company, you&#39;re likely focused on maintaining a competitive edge and scaling your product to reach a global audience. However, localization can often be an afterthought in the software development process, and the lack of a clear localization strategy can lead to delays, inconsistencies, and increased costs. One of the key challenges in localization is striking the balance between speed and quality. On one hand, you want to get your product to market as quickly as possible, but on the other hand, you also want to ensure that your localized content is accurate, relevant, and culturally appropriate. To achieve this balance, it&#39;s essential to integrate localization early in the development process and to establish clear guidelines and processes for your localization team. Another challenge is maintaining consistency and reducing costs as your product and localization team scale. To tackle this, you can implement automation and translation memory tools that can help to improve efficiency and reduce the need for manual translation and review. Collaboration is also crucial to a successful localization strategy. Having all the stakeholders involved in the localization process, including product, development and localization teams, can help to ensure that the localized content is consistent and that the localization process is streamlined. This can be achieved through the implementation of a centralized localization management platform that enables real-time translation delivery, versioning, translation memory, and collaboration tools for teams. To help with this, locize is a powerful, yet easy-to-use localization platform that can help you to achieve all of the above. It offers real-time translation delivery, collaboration tools, advanced features like versioning and translation memory, as well as a wide variety of integrations that can be easily integrated with your existing tools and workflow. Best practices and real-world examples of how successful tech companies have approached localization are many, like Netflix, Facebook, and Microsoft they have build scalable localization strategies that enabled them to reach global audiences while maintaining a high level of quality and consistency. When it comes to choosing the right localization platform for your company, there are many factors to consider, including features, pricing, and customer support. Try locize for free and see how it can help you to streamline your localization process, improve consistency, and reach a global audience. In conclusion, implementing a scalable localization strategy is essential for any fast-growing tech company that wants to maintain a competitive edge and reach a global audience. By integrating localization early in the development process, implementing automation and translation memory tools, and using a centralized localization management platform like locize, you can achieve the right balance between speed and quality, reduce costs, and enhance collaboration among your teams. Try locize today and see the difference it can make for your business.","raw":"---\ntitle: How to build a scalable localization strategy for your fast-growing tech company\ndescription: This article emphasizes the challenges that CTOs of fast-growing tech companies often face with regard to localization and provides a clear picture of how locize can help overcome those challenges by providing real-time translation delivery, advanced features and collaboration tools, and integrations with existing tools and workflow, which are all important factors that a CTO might consider when evaluating a localization platform. \n\ndate: 2023-01-10\ntags:\n  - localization\n  - international strategy\n  - global localization\n  - internationalization\n  - tech lead\n  - engineering manager\nthumbnail: scalable-localization-strategy/title.jpg\n---\n\n![](title.jpg)\n\nAs the CTO, manager or tech lead of a fast-growing tech company, you're likely focused on maintaining a competitive edge and scaling your product to reach a [global audience](../grow-online-business/). However, localization can often be an afterthought in the [software development](../what-is-software-localization/) process, and the lack of a clear [localization strategy](../localization-strategy/) can lead to delays, inconsistencies, and increased costs.\n\nOne of the key challenges in localization is **striking the balance** between **speed** and **quality**. On one hand, you want to get your product to market as quickly as possible, but on the other hand, you also want to ensure that your localized content is accurate, relevant, and culturally appropriate. To achieve this balance, it's essential to [integrate localization early in the development process](../localization-fun/) and to establish clear guidelines and processes for your localization team.\n\nAnother challenge is **maintaining consistency** and **reducing costs** as your product and localization team scale. To tackle this, you can implement [automation](https://docs.locize.com/whats-inside/auto-machine-translation) and [translation memory](https://docs.locize.com/whats-inside/translation-memory) tools that can help to improve efficiency and reduce the need for manual translation and [review](https://docs.locize.com/whats-inside/review-workflow).\n\n**Collaboration** is also crucial to a successful [localization strategy](../localization-strategy/). Having all the stakeholders involved in the localization process, including [product, development and localization teams](/for-your-team.html), can help to ensure that the localized content is consistent and that the localization process is streamlined. This can be achieved through the implementation of a centralized [localization management platform](../tms/) that enables [real-time translation delivery](https://docs.locize.com/whats-inside/cdn-content-delivery-network), [versioning](https://docs.locize.com/more/versioning), [translation memory](https://docs.locize.com/whats-inside/translation-memory), and [collaboration tools](https://docs.locize.com/more/notifications) for teams.\n\nTo help with this, **[locize](/)** is a powerful, yet easy-to-use localization platform that can help you to achieve all of the above. It offers [real-time translation delivery](https://docs.locize.com/whats-inside/cdn-content-delivery-network), [collaboration tools](https://docs.locize.com/whats-inside/review-workflow), advanced features like [versioning](https://docs.locize.com/more/versioning) and [translation memory](https://docs.locize.com/whats-inside/translation-memory), as well as a wide [variety of integrations](https://docs.locize.com/integration/instrumenting-your-code) that can be easily integrated with your existing tools and workflow.\n\nBest practices and real-world examples of how successful tech companies have approached localization are many, like [Netflix](https://www.netflix.com), [Facebook](https://facebook.com), and [Microsoft](https://microsoft.com) they have build scalable localization strategies that enabled them to reach [global audiences](../globalization-vs-localization/) while maintaining a high level of quality and consistency.\n\nWhen it comes to choosing the right [localization platform](../i18n-l10n-t9n-tms/) for your company, there are many factors to consider, including features, pricing, and customer support. Try [locize for free](https://www.locize.app/register) and see how it can help you to streamline your localization process, improve consistency, and reach a global audience.\n\nIn conclusion, implementing a scalable [localization strategy](../localization-strategy/) is essential for any fast-growing tech company that wants to maintain a competitive edge and [reach a global audience](../grow-online-business/). By integrating localization early in the development process, implementing automation and translation memory tools, and using a centralized localization management platform like [locize](/), you can achieve the **right balance between speed and quality**, reduce costs, and enhance collaboration among your teams.\n\nTry [locize](https://www.locize.app/register) today and see the difference it can make for your business.\n\n{% youtube ds-yEEYP1Ks %}\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"},{"name":"tech lead","slug":"tech-lead","permalink":"https://locize.com/blog/tags/tech-lead/"},{"name":"engineering manager","slug":"engineering-manager","permalink":"https://locize.com/blog/tags/engineering-manager/"}]},{"title":"i18n with Next.js 13 and app directory / App Router (an i18next guide)","slug":"next-13-app-dir-i18n","date":"un11fin11","updated":"un11fin11","comments":true,"path":"next-13-app-dir-i18n/","link":"","permalink":"https://locize.com/blog/next-13-app-dir-i18n/","excerpt":"","text":"At Next.js Conf, the Vercel team announced Next.js 13 which introduced the new app directory / App Router paradigm. It includes support for Layouts, Server Components, Streaming and Support for Data Fetching. Awesome! Next.js 13 has been released! It seems pretty fast and it lays the foundations to be dynamic without limits. Afterthoughts...This sounds good, but looking more into the app directory / App Router paradigm, it looks like this is a completely new Next.js setup... not really comparable to the old one... What does this mean regarding i18n? Looking at the docs it seems our old approaches will not work anymore. Nice features provided by next-i18next (and other Next.js related i18n modules), like described here and here are not suited to this new app directory setup. So you don't need next-i18next anymore! A new approachIn this section, you&#39;ll see how we can internationalize the new app directory with the use of i18next, react-i18next and i18next-resources-to-backend. npm install i18next react-i18next i18next-resources-to-backend Folder structure Language detection i18n instrumentation Language switcher Client side Bonus 1. Folder structure Let&#39;s start by creating a new folder structure that uses the language as url parameter. A so-called dynamic segment: 1234567.└── app └── [lng] ├── second-page | └── page.js ├── layout.js └── page.js The app/[lng]/page.js file could look like this: 123456789101112import Link from &#x27;next/link&#x27;export default function Page(&#123; params: &#123; lng &#125; &#125;) &#123; return ( &lt;&gt; &lt;h1&gt;Hi there!&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;/second-page`&#125;&gt; second page &lt;/Link&gt; &lt;/&gt; )&#125; And the app/[lng]/second-page/page.js file could look like this: 123456789101112import Link from &#x27;next/link&#x27;export default function Page(&#123; params: &#123; lng &#125; &#125;) &#123; return ( &lt;&gt; &lt;h1&gt;Hi from second page!&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;`&#125;&gt; back &lt;/Link&gt; &lt;/&gt; )&#125; Last the app/[lng]/layout.js file could look like this: 1234567891011121314151617181920212223import &#123; dir &#125; from &#x27;i18next&#x27;const languages = [&#x27;en&#x27;, &#x27;de&#x27;]export async function generateStaticParams() &#123; return languages.map((lng) =&gt; (&#123; lng &#125;))&#125;export default function RootLayout(&#123; children, params: &#123; lng &#125;&#125;) &#123; return ( &lt;html lang=&#123;lng&#125; dir=&#123;dir(lng)&#125;&gt; &lt;head /&gt; &lt;body&gt; &#123;children&#125; &lt;/body&gt; &lt;/html&gt; )&#125; 2. Language detection Now navigating to http://localhost:3000/en or http://localhost:3000/de should show something, and also the links to the second page and back should work, but navigating to http://localhost:3000 will return a 404 error. To fix that we&#39;ll create a Next.js middleware and refactor a bit of code: Let&#39;s first create a new file app/i18n/settings.js: 12export const fallbackLng = &#x27;en&#x27;export const languages = [fallbackLng, &#x27;de&#x27;] Then adapt the app/[lng]/layout.js file: 12345678910111213141516171819202122import &#123; dir &#125; from &#x27;i18next&#x27;import &#123; languages &#125; from &#x27;../i18n/settings&#x27;export async function generateStaticParams() &#123; return languages.map((lng) =&gt; (&#123; lng &#125;))&#125;export default function RootLayout(&#123; children, params: &#123; lng &#125;&#125;) &#123; return ( &lt;html lang=&#123;lng&#125; dir=&#123;dir(lng)&#125;&gt; &lt;head /&gt; &lt;body&gt; &#123;children&#125; &lt;/body&gt; &lt;/html&gt; )&#125; And finally create a middleware.js file: npm install accept-language 1234567891011121314151617181920212223242526272829303132333435import &#123; NextResponse &#125; from &#x27;next/server&#x27;import acceptLanguage from &#x27;accept-language&#x27;import &#123; fallbackLng, languages, cookieName &#125; from &#x27;./app/i18n/settings&#x27;acceptLanguage.languages(languages)export const config = &#123; // matcher: &#x27;/:lng*&#x27; matcher: [&#x27;/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)&#x27;]&#125;export function middleware(req) &#123; let lng if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value) if (!lng) lng = acceptLanguage.get(req.headers.get(&#x27;Accept-Language&#x27;)) if (!lng) lng = fallbackLng // Redirect if lng in path is not supported if ( !languages.some(loc =&gt; req.nextUrl.pathname.startsWith(`/$&#123;loc&#125;`)) &amp;&amp; !req.nextUrl.pathname.startsWith(&#x27;/_next&#x27;) ) &#123; return NextResponse.redirect(new URL(`/$&#123;lng&#125;$&#123;req.nextUrl.pathname&#125;`, req.url)) &#125; if (req.headers.has(&#x27;referer&#x27;)) &#123; const refererUrl = new URL(req.headers.get(&#x27;referer&#x27;)) const lngInReferer = languages.find((l) =&gt; refererUrl.pathname.startsWith(`/$&#123;l&#125;`)) const response = NextResponse.next() if (lngInReferer) response.cookies.set(cookieName, lngInReferer) return response &#125; return NextResponse.next()&#125; Navigating to the root path / will now check if there&#39;s already a cookie with the last chosen language, as fallback it will check the Accept-Language header and the last fallback is the defined fallback language. The detected language will be used to redirect to the appropriate page. 3. i18n instrumentation Let&#39;s prepare i18next in the app/i18n/index.js file: We&#39;re not using the i18next singleton here but creating a new instance on each useTranslation call, because during compilation everything seems to be executed in parallel. Having a separate instance will keep the translations consistent. 123456789101112131415161718192021import &#123; createInstance &#125; from &#x27;i18next&#x27;import resourcesToBackend from &#x27;i18next-resources-to-backend&#x27;import &#123; initReactI18next &#125; from &#x27;react-i18next/initReactI18next&#x27;import &#123; getOptions &#125; from &#x27;./settings&#x27;const initI18next = async (lng, ns) =&gt; &#123; const i18nInstance = createInstance() await i18nInstance .use(initReactI18next) .use(resourcesToBackend((language, namespace) =&gt; import(`./locales/$&#123;language&#125;/$&#123;namespace&#125;.json`))) .init(getOptions(lng, ns)) return i18nInstance&#125;export async function useTranslation(lng, ns, options = &#123;&#125;) &#123; const i18nextInstance = await initI18next(lng, ns) return &#123; t: i18nextInstance.getFixedT(lng, Array.isArray(ns) ? ns[0] : ns, options.keyPrefix), i18n: i18nextInstance &#125;&#125; In the app/i18n/settings.js file we&#39;ll add the i18next options: 12345678910111213141516export const fallbackLng = &#x27;en&#x27;export const languages = [fallbackLng, &#x27;de&#x27;]export const defaultNS = &#x27;translation&#x27;export const cookieName = &#x27;i18next&#x27;export function getOptions (lng = fallbackLng, ns = defaultNS) &#123; return &#123; // debug: true, supportedLngs: languages, fallbackLng, lng, fallbackNS: defaultNS, defaultNS, ns &#125;&#125; Let&#39;s prepare some translation files: 12345678910.└── app └── i18n └── locales ├── en | ├── translation.json | └── second-page.json └── de ├── translation.json └── second-page.json app/i18n/locales/en/translation.json: 1234&#123; &quot;title&quot;: &quot;Hi there!&quot;, &quot;to-second-page&quot;: &quot;To second page&quot;&#125; app/i18n/locales/de/translation.json: 1234&#123; &quot;title&quot;: &quot;Hallo Leute!&quot;, &quot;to-second-page&quot;: &quot;Zur zweiten Seite&quot;&#125; app/i18n/locales/en/second-page.json: 1234&#123; &quot;title&quot;: &quot;Hi from second page!&quot;, &quot;back-to-home&quot;: &quot;Back to home&quot;&#125; app/i18n/locales/de/second-page.json: 1234&#123; &quot;title&quot;: &quot;Hallo von der zweiten Seite!&quot;, &quot;back-to-home&quot;: &quot;Zurück zur Hauptseite&quot;&#125; Now we&#39;re ready to use that in our pages... Server pages can by async this way we can await the useTranslation response. app/[lng]/page.js: 1234567891011121314import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../i18n&#x27;export default async function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = await useTranslation(lng) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;/second-page`&#125;&gt; &#123;t(&#x27;to-second-page&#x27;)&#125; &lt;/Link&gt; &lt;/&gt; )&#125; app/[lng]/second-page/page.js: 1234567891011121314import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../../i18n&#x27;export default async function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = await useTranslation(lng, &#x27;second-page&#x27;) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;`&#125;&gt; &#123;t(&#x27;back-to-home&#x27;)&#125; &lt;/Link&gt; &lt;/&gt; )&#125; 4. Language switcher Now let&#39;s define a language switcher in a Footer component: app/[lng]/components/Footer/index.js: 12345678910111213141516171819202122232425import Link from &#x27;next/link&#x27;import &#123; Trans &#125; from &#x27;react-i18next/TransWithoutContext&#x27;import &#123; languages &#125; from &#x27;../../../i18n/settings&#x27;import &#123; useTranslation &#125; from &#x27;../../../i18n&#x27;export const Footer = async (&#123; lng &#125;) =&gt; &#123; const &#123; t &#125; = await useTranslation(lng, &#x27;footer&#x27;) return ( &lt;footer style=&#123;&#123; marginTop: 50 &#125;&#125;&gt; &lt;Trans i18nKey=&quot;languageSwitcher&quot; t=&#123;t&#125;&gt; Switch from &lt;strong&gt;&#123;&#123;lng&#125;&#125;&lt;/strong&gt; to:&#123;&#x27; &#x27;&#125; &lt;/Trans&gt; &#123;languages.filter((l) =&gt; lng !== l).map((l, index) =&gt; &#123; return ( &lt;span key=&#123;l&#125;&gt; &#123;index &gt; 0 &amp;&amp; (&#x27; or &#x27;)&#125; &lt;Link href=&#123;`/$&#123;l&#125;`&#125;&gt; &#123;l&#125; &lt;/Link&gt; &lt;/span&gt; ) &#125;)&#125; &lt;/footer&gt; )&#125; You see we can also use the react-i18next Trans component. A new namespace: app/i18n/locales/en/footer.json: 123&#123; &quot;languageSwitcher&quot;: &quot;Switch from &lt;1&gt;&#123;&#123;lng&#125;&#125;&lt;/1&gt; to: &quot;&#125; app/i18n/locales/de/footer.json: 123&#123; &quot;languageSwitcher&quot;: &quot;Wechseln von &lt;1&gt;&#123;&#123;lng&#125;&#125;&lt;/1&gt; nach: &quot;&#125; And add that Footer component to the pages: app/[lng]/page.js: 12345678910111213141516import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../i18n&#x27;import &#123; Footer &#125; from &#x27;./components/Footer&#x27;export default async function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = await useTranslation(lng) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;/second-page`&#125;&gt; &#123;t(&#x27;to-second-page&#x27;)&#125; &lt;/Link&gt; &lt;Footer lng=&#123;lng&#125;/&gt; &lt;/&gt; )&#125; app/[lng]/second-page/page.js: 12345678910111213141516import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../../i18n&#x27;import &#123; Footer &#125; from &#x27;../components/Footer&#x27;export default async function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = await useTranslation(lng, &#x27;second-page&#x27;) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;`&#125;&gt; &#123;t(&#x27;back-to-home&#x27;)&#125; &lt;/Link&gt; &lt;Footer lng=&#123;lng&#125;/&gt; &lt;/&gt; )&#125; 🥳 Awesome, you&#39;ve just created your first language switcher! 5. Client side So far we&#39;ve created server side pages only. So what do client side pages look like? Since client side react components can&#39;t async we need to do some adjustments. Let&#39;s introduce the app/i18n/client.js file: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x27;use client&#x27;import &#123; useEffect, useState &#125; from &#x27;react&#x27;import i18next from &#x27;i18next&#x27;import &#123; initReactI18next, useTranslation as useTranslationOrg &#125; from &#x27;react-i18next&#x27;import &#123; useCookies &#125; from &#x27;react-cookie&#x27;import resourcesToBackend from &#x27;i18next-resources-to-backend&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import &#123; getOptions, languages, cookieName &#125; from &#x27;./settings&#x27;const runsOnServerSide = typeof window === &#x27;undefined&#x27;// i18next .use(initReactI18next) .use(LanguageDetector) .use(resourcesToBackend((language, namespace) =&gt; import(`./locales/$&#123;language&#125;/$&#123;namespace&#125;.json`))) .init(&#123; ...getOptions(), lng: undefined, // let detect the language on client side detection: &#123; order: [&#x27;path&#x27;, &#x27;htmlTag&#x27;, &#x27;cookie&#x27;, &#x27;navigator&#x27;], &#125;, preload: runsOnServerSide ? languages : [] &#125;)export function useTranslation(lng, ns, options) &#123; const [cookies, setCookie] = useCookies([cookieName]) const ret = useTranslationOrg(ns, options) const &#123; i18n &#125; = ret if (runsOnServerSide &amp;&amp; lng &amp;&amp; i18n.resolvedLanguage !== lng) &#123; i18n.changeLanguage(lng) &#125; else &#123; // eslint-disable-next-line react-hooks/rules-of-hooks const [activeLng, setActiveLng] = useState(i18n.resolvedLanguage) // eslint-disable-next-line react-hooks/rules-of-hooks useEffect(() =&gt; &#123; if (activeLng === i18n.resolvedLanguage) return setActiveLng(i18n.resolvedLanguage) &#125;, [activeLng, i18n.resolvedLanguage]) // eslint-disable-next-line react-hooks/rules-of-hooks useEffect(() =&gt; &#123; if (!lng || i18n.resolvedLanguage === lng) return i18n.changeLanguage(lng) &#125;, [lng, i18n]) // eslint-disable-next-line react-hooks/rules-of-hooks useEffect(() =&gt; &#123; if (cookies.i18next === lng) return setCookie(cookieName, lng, &#123; path: &#x27;/&#x27; &#125;) &#125;, [lng, cookies.i18next]) &#125; return ret&#125; On client side the normal i18next singleton is ok. It will be initialized just once. And we can make use of the &quot;normal&quot; useTranslation hook. We just wrap it to have the possibility to pass in the language. To align with the server side language detection we make use of i18next-browser-languagedetector and configure it accordingly. We also need to create 2 versions of the Footer component. 12345678.└── app └── [lng] └── components └── Footer ├── client.js ├── FooterBase.js └── index.js app/[lng]/components/Footer/FooterBase.js: 1234567891011121314151617181920212223import Link from &#x27;next/link&#x27;import &#123; Trans &#125; from &#x27;react-i18next/TransWithoutContext&#x27;import &#123; languages &#125; from &#x27;../../../i18n/settings&#x27;export const FooterBase = (&#123; t, lng &#125;) =&gt; &#123; return ( &lt;footer style=&#123;&#123; marginTop: 50 &#125;&#125;&gt; &lt;Trans i18nKey=&quot;languageSwitcher&quot; t=&#123;t&#125;&gt; Switch from &lt;strong&gt;&#123;&#123;lng&#125;&#125;&lt;/strong&gt; to:&#123;&#x27; &#x27;&#125; &lt;/Trans&gt; &#123;languages.filter((l) =&gt; lng !== l).map((l, index) =&gt; &#123; return ( &lt;span key=&#123;l&#125;&gt; &#123;index &gt; 0 &amp;&amp; (&#x27; or &#x27;)&#125; &lt;Link href=&#123;`/$&#123;l&#125;`&#125;&gt; &#123;l&#125; &lt;/Link&gt; &lt;/span&gt; ) &#125;)&#125; &lt;/footer&gt; )&#125; The server side part continuous to use the async version, app/[lng]/components/Footer/index.js: 1234567import &#123; useTranslation &#125; from &#x27;../../../i18n&#x27;import &#123; FooterBase &#125; from &#x27;./FooterBase&#x27;export const Footer = async (&#123; lng &#125;) =&gt; &#123; const &#123; t &#125; = await useTranslation(lng, &#x27;footer&#x27;) return &lt;FooterBase t=&#123;t&#125; lng=&#123;lng&#125; /&gt;&#125; The client side part will use the new i18n/client version, app/[lng]/components/Footer/client.js: 123456789&#x27;use client&#x27;import &#123; FooterBase &#125; from &#x27;./FooterBase&#x27;import &#123; useTranslation &#125; from &#x27;../../../i18n/client&#x27;export const Footer = (&#123; lng &#125;) =&gt; &#123; const &#123; t &#125; = useTranslation(lng, &#x27;footer&#x27;) return &lt;FooterBase t=&#123;t&#125; lng=&#123;lng&#125; /&gt;&#125; A client side page could look like this - app/[lng]/client-page/page.js: 123456789101112131415161718192021222324252627&#x27;use client&#x27;import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../../i18n/client&#x27;import &#123; Footer &#125; from &#x27;../components/Footer/client&#x27;import &#123; useState &#125; from &#x27;react&#x27;export default function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = useTranslation(lng, &#x27;client-page&#x27;) const [counter, setCounter] = useState(0) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;p&gt;&#123;t(&#x27;counter&#x27;, &#123; count: counter &#125;)&#125;&lt;/p&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCounter(Math.max(0, counter - 1))&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCounter(Math.min(10, counter + 1))&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;Link href=&#123;`/$&#123;lng&#125;`&#125;&gt; &lt;button type=&quot;button&quot;&gt; &#123;t(&#x27;back-to-home&#x27;)&#125; &lt;/button&gt; &lt;/Link&gt; &lt;Footer lng=&#123;lng&#125; /&gt; &lt;/&gt; )&#125; With some translation resources: app/i18n/locales/en/client-page.json: 1234567&#123; &quot;title&quot;: &quot;Client page&quot;, &quot;counter_one&quot;: &quot;one selected&quot;, &quot;counter_other&quot;: &quot;&#123;&#123;count&#125;&#125; selected&quot;, &quot;counter_zero&quot;: &quot;none selected&quot;, &quot;back-to-home&quot;: &quot;Back to home&quot;&#125; app/i18n/locales/de/client-page.json: 1234567&#123; &quot;title&quot;: &quot;Client Seite&quot;, &quot;counter_one&quot;: &quot;eines ausgewählt&quot;, &quot;counter_other&quot;: &quot;&#123;&#123;count&#125;&#125; ausgewählt&quot;, &quot;counter_zero&quot;: &quot;keines ausgewählt&quot;, &quot;back-to-home&quot;: &quot;Zurück zur Hauptseite&quot;&#125; And a link in our initial page - app/[lng]/page.js: 1234567891011121314151617181920import Link from &#x27;next/link&#x27;import &#123; useTranslation &#125; from &#x27;../i18n&#x27;import &#123; Footer &#125; from &#x27;./components/Footer&#x27;export default async function Page(&#123; params: &#123; lng &#125; &#125;) &#123; const &#123; t &#125; = await useTranslation(lng) return ( &lt;&gt; &lt;h1&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h1&gt; &lt;Link href=&#123;`/$&#123;lng&#125;/second-page`&#125;&gt; &#123;t(&#x27;to-second-page&#x27;)&#125; &lt;/Link&gt; &lt;br /&gt; &lt;Link href=&#123;`/$&#123;lng&#125;/client-page`&#125;&gt; &#123;t(&#x27;to-client-page&#x27;)&#125; &lt;/Link&gt; &lt;Footer lng=&#123;lng&#125;/&gt; &lt;/&gt; )&#125; ...with translation resources: app/i18n/locales/en/translation.json: 12345&#123; &quot;title&quot;: &quot;Hi there!&quot;, &quot;to-second-page&quot;: &quot;To second page&quot;, &quot;to-client-page&quot;: &quot;To client page&quot;&#125; app/i18n/locales/de/translation.json: 12345&#123; &quot;title&quot;: &quot;Hallo Leute!&quot;, &quot;to-second-page&quot;: &quot;Zur zweiten Seite&quot;, &quot;to-client-page&quot;: &quot;Zur clientseitigen Seite&quot;&#125; 🎉🥳 Congratulations 🎊🎁 The result should look like this: 🧑‍💻 The complete code of an example app can be found here. 6. Bonus Connect to an awesome translation management system and manage your translations outside of your code. Let&#39;s synchronize the translation files with locize. This can be done on-demand or on the CI-Server or before deploying the app. What to do to reach this step: in locize: signup at https://locize.app/register and login in locize: create a new project install the locize-cli (npm i locize-cli) in locize: add all your additional languages (this can also be done via API or with using the migrate command of the locize-cli) Use the locize-cliUse the locize download command to always download the published locize translations to your local repository (app/i18n/locales) before bundling your app. example Alternatively, you can also use the locize sync command to synchronize your local repository (app/i18n/locales) with what is published on locize. example 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18n in the new app directory setup, Next.js, i18next, react-i18next, react-i18next, i18next-resources-to-backend and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: i18n with Next.js 13 and app directory / App Router (an i18next guide)\ndescription: Looking for a way to internationalize your Next.js 13 project with the new app directory / App Router paradigm? Then this guide is for you!\n\ndate: 2023-01-02\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - next-i18next\n  - next\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - translation\nthumbnail: next-13-app-dir-i18n/next-13-app-dir-i18n.jpg\n\nlabel: next-13-app-dir-i18n\nlang: en\n---\n\n![](next-13-app-dir-i18n.jpg \"locize © inweso GmbH\")\n\nAt [Next.js Conf](https://nextjs.org/conf), the [Vercel](https://vercel.com) team [announced Next.js 13](https://nextjs.org/blog/next-13) which introduced the new [app directory / App Router paradigm](https://nextjs.org/docs/app).\n<br />\nIt includes support for [Layouts](https://nextjs.org/blog/next-13#layouts), [Server Components](https://nextjs.org/blog/next-13#server-components), [Streaming](https://nextjs.org/blog/next-13#streaming) and [Support for Data Fetching](https://nextjs.org/blog/next-13#data-fetching).\n\n> Awesome! **Next.js 13** has been [released](https://nextjs.org/blog/next-13)!\n<br />\nIt seems pretty fast and it lays the foundations to be dynamic without limits.\n\n## Afterthoughts...\n\nThis sounds good, but looking more into the app directory / App Router paradigm, it looks like this is a completely new Next.js setup... not really comparable to the old one...\n\n> What does this mean regarding i18n?\n\nLooking at the [docs](https://nextjs.org/docs/app/building-your-application/routing/internationalization) it seems our old approaches will not work anymore.\n\n![](not-planned.jpg)\n\n<b>\nNice features provided by <a href=\"https://next.i18next.com\" target=\"_blank\">next-i18next</a> <i>(and other Next.js related i18n modules)</i>, like described <a href=\"../next-i18next/\" target=\"_blank\">here</a> and <a href=\"../next-i18n-static/\" target=\"_blank\">here</a> are not suited to this new app directory setup.\n<br />\n<span style=\"text-decoration: underline;\">So you don't need next-i18next anymore!</span>\n</b>\n\n\n## A new approach\n\nIn this section, you'll see how we can internationalize the new app directory with the use of [i18next](https://www.i18next.com), [react-i18next](https://react.i18next.com) and [i18next-resources-to-backend](https://github.com/i18next/i18next-resources-to-backend).\n<br />\n`npm install i18next react-i18next i18next-resources-to-backend`\n\n1. [Folder structure](#step-1)\n2. [Language detection](#step-2)\n3. [i18n instrumentation](#step-3)\n4. [Language switcher](#step-4)\n5. [Client side](#step-5)\n6. [Bonus](#step-6)\n\n\n### 1. Folder structure <a name=\"step-1\"></a>\n\nLet's start by creating a new folder structure that uses the language as url parameter. A so-called [dynamic segment](https://nextjs.org/docs/app/api-reference/functions/generate-static-params#single-dynamic-segment):\n\n```\n.\n└── app\n    └── [lng]\n        ├── second-page\n        |   └── page.js\n        ├── layout.js\n        └── page.js\n```\n\nThe `app/[lng]/page.js` file could look like this:\n\n```js\nimport Link from 'next/link'\n\nexport default function Page({ params: { lng } }) {\n  return (\n    <>\n      <h1>Hi there!</h1>\n      <Link href={`/${lng}/second-page`}>\n        second page\n      </Link>\n    </>\n  )\n}\n```\n\nAnd the `app/[lng]/second-page/page.js` file could look like this:\n\n```js\nimport Link from 'next/link'\n\nexport default function Page({ params: { lng } }) {\n  return (\n    <>\n      <h1>Hi from second page!</h1>\n      <Link href={`/${lng}`}>\n        back\n      </Link>\n    </>\n  )\n}\n```\n\nLast the `app/[lng]/layout.js` file could look like this:\n\n```js\nimport { dir } from 'i18next'\n\nconst languages = ['en', 'de']\n\nexport async function generateStaticParams() {\n  return languages.map((lng) => ({ lng }))\n}\n\nexport default function RootLayout({\n  children,\n  params: {\n    lng\n  }\n}) {\n  return (\n    <html lang={lng} dir={dir(lng)}>\n      <head />\n      <body>\n        {children}\n      </body>\n    </html>\n  )\n}\n```\n\n## 2. Language detection <a name=\"step-2\"></a>\n\nNow navigating to `http://localhost:3000/en` or `http://localhost:3000/de` should show something, and also the links to the second page and back should work, but navigating to `http://localhost:3000` will return a 404 error.\n<br />\nTo fix that we'll create a Next.js middleware and refactor a bit of code:\n\nLet's first create a new file `app/i18n/settings.js`:\n\n```js\nexport const fallbackLng = 'en'\nexport const languages = [fallbackLng, 'de']\n```\n\nThen adapt the `app/[lng]/layout.js` file:\n\n```js\nimport { dir } from 'i18next'\nimport { languages } from '../i18n/settings'\n\nexport async function generateStaticParams() {\n  return languages.map((lng) => ({ lng }))\n}\n\nexport default function RootLayout({\n  children,\n  params: {\n    lng\n  }\n}) {\n  return (\n    <html lang={lng} dir={dir(lng)}>\n      <head />\n      <body>\n        {children}\n      </body>\n    </html>\n  )\n}\n```\n\nAnd finally create a `middleware.js` file:\n<br />\n`npm install accept-language`\n\n```js\nimport { NextResponse } from 'next/server'\nimport acceptLanguage from 'accept-language'\nimport { fallbackLng, languages, cookieName } from './app/i18n/settings'\n\nacceptLanguage.languages(languages)\n\nexport const config = {\n  // matcher: '/:lng*'\n  matcher: ['/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)']\n}\n\nexport function middleware(req) {\n  let lng\n  if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value)\n  if (!lng) lng = acceptLanguage.get(req.headers.get('Accept-Language'))\n  if (!lng) lng = fallbackLng\n\n  // Redirect if lng in path is not supported\n  if (\n    !languages.some(loc => req.nextUrl.pathname.startsWith(`/${loc}`)) &&\n    !req.nextUrl.pathname.startsWith('/_next')\n  ) {\n    return NextResponse.redirect(new URL(`/${lng}${req.nextUrl.pathname}`, req.url))\n  }\n\n  if (req.headers.has('referer')) {\n    const refererUrl = new URL(req.headers.get('referer'))\n    const lngInReferer = languages.find((l) => refererUrl.pathname.startsWith(`/${l}`))\n    const response = NextResponse.next()\n    if (lngInReferer) response.cookies.set(cookieName, lngInReferer)\n    return response\n  }\n\n  return NextResponse.next()\n}\n```\n\n![](middleware.gif)\n\nNavigating to the root path `/` will now check if there's already a cookie with the last chosen language, as fallback it will check the `Accept-Language` header and the last fallback is the defined fallback language.\n<br />\nThe detected language will be used to redirect to the appropriate page.\n\n\n## 3. i18n instrumentation <a name=\"step-3\"></a>\n\nLet's prepare i18next in the `app/i18n/index.js` file:\n<br />\nWe're not using the i18next singleton here but creating a new instance on each `useTranslation` call, because during compilation everything seems to be executed in parallel. Having a separate instance will keep the translations consistent.\n\n```js\nimport { createInstance } from 'i18next'\nimport resourcesToBackend from 'i18next-resources-to-backend'\nimport { initReactI18next } from 'react-i18next/initReactI18next'\nimport { getOptions } from './settings'\n\nconst initI18next = async (lng, ns) => {\n  const i18nInstance = createInstance()\n  await i18nInstance\n    .use(initReactI18next)\n    .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))\n    .init(getOptions(lng, ns))\n  return i18nInstance\n}\n\nexport async function useTranslation(lng, ns, options = {}) {\n  const i18nextInstance = await initI18next(lng, ns)\n  return {\n    t: i18nextInstance.getFixedT(lng, Array.isArray(ns) ? ns[0] : ns, options.keyPrefix),\n    i18n: i18nextInstance\n  }\n}\n```\n\nIn the `app/i18n/settings.js` file we'll add the i18next options:\n<br />\n\n```js\nexport const fallbackLng = 'en'\nexport const languages = [fallbackLng, 'de']\nexport const defaultNS = 'translation'\nexport const cookieName = 'i18next'\n\nexport function getOptions (lng = fallbackLng, ns = defaultNS) {\n  return {\n    // debug: true,\n    supportedLngs: languages,\n    fallbackLng,\n    lng,\n    fallbackNS: defaultNS,\n    defaultNS,\n    ns\n  }\n}\n```\n\nLet's prepare some translation files:\n\n```\n.\n└── app\n    └── i18n\n        └── locales\n            ├── en\n            |   ├── translation.json\n            |   └── second-page.json\n            └── de\n                ├── translation.json\n                └── second-page.json\n```\n\n`app/i18n/locales/en/translation.json`:\n```json\n{\n  \"title\": \"Hi there!\",\n  \"to-second-page\": \"To second page\"\n}\n```\n\n`app/i18n/locales/de/translation.json`:\n```json\n{\n  \"title\": \"Hallo Leute!\",\n  \"to-second-page\": \"Zur zweiten Seite\"\n}\n```\n\n`app/i18n/locales/en/second-page.json`:\n```json\n{\n  \"title\": \"Hi from second page!\",\n  \"back-to-home\": \"Back to home\"\n}\n```\n\n`app/i18n/locales/de/second-page.json`:\n```json\n{\n  \"title\": \"Hallo von der zweiten Seite!\",\n  \"back-to-home\": \"Zurück zur Hauptseite\"\n}\n```\n\n\nNow we're ready to use that in our pages...\n<br />\nServer pages can by `async` this way we can await the `useTranslation` response.\n\n`app/[lng]/page.js`:\n\n```js\nimport Link from 'next/link'\nimport { useTranslation } from '../i18n'\n\nexport default async function Page({ params: { lng } }) {\n  const { t } = await useTranslation(lng)\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <Link href={`/${lng}/second-page`}>\n        {t('to-second-page')}\n      </Link>\n    </>\n  )\n}\n```\n\n`app/[lng]/second-page/page.js`:\n\n```js\nimport Link from 'next/link'\nimport { useTranslation } from '../../i18n'\n\nexport default async function Page({ params: { lng } }) {\n  const { t } = await useTranslation(lng, 'second-page')\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <Link href={`/${lng}`}>\n        {t('back-to-home')}\n      </Link>\n    </>\n  )\n}\n```\n\n![](app_de_1.jpg)\n\n### 4. Language switcher <a name=\"step-4\"></a>\n\nNow let's define a language switcher in a Footer component:\n\n`app/[lng]/components/Footer/index.js`:\n\n```js\nimport Link from 'next/link'\nimport { Trans } from 'react-i18next/TransWithoutContext'\nimport { languages } from '../../../i18n/settings'\nimport { useTranslation } from '../../../i18n'\n\nexport const Footer = async ({ lng }) => {\n  const { t } = await useTranslation(lng, 'footer')\n  return (\n    <footer style={{ marginTop: 50 }}>\n      <Trans i18nKey=\"languageSwitcher\" t={t}>\n        Switch from <strong>{{lng}}</strong> to:{' '}\n      </Trans>\n      {languages.filter((l) => lng !== l).map((l, index) => {\n        return (\n          <span key={l}>\n            {index > 0 && (' or ')}\n            <Link href={`/${l}`}>\n              {l}\n            </Link>\n          </span>\n        )\n      })}\n    </footer>\n  )\n}\n```\n\nYou see we can also use the [react-i18next Trans component](https://react.i18next.com/latest/trans-component).\n\nA new namespace:\n\n`app/i18n/locales/en/footer.json`:\n\n```json\n{\n  \"languageSwitcher\": \"Switch from <1>{{lng}}</1> to: \"\n}\n```\n\n`app/i18n/locales/de/footer.json`:\n\n```json\n{\n  \"languageSwitcher\": \"Wechseln von <1>{{lng}}</1> nach: \"\n}\n```\n\nAnd add that Footer component to the pages:\n\n`app/[lng]/page.js`:\n\n```js\nimport Link from 'next/link'\nimport { useTranslation } from '../i18n'\nimport { Footer } from './components/Footer'\n\nexport default async function Page({ params: { lng } }) {\n  const { t } = await useTranslation(lng)\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <Link href={`/${lng}/second-page`}>\n        {t('to-second-page')}\n      </Link>\n      <Footer lng={lng}/>\n    </>\n  )\n}\n```\n\n`app/[lng]/second-page/page.js`:\n\n```js\nimport Link from 'next/link'\nimport { useTranslation } from '../../i18n'\nimport { Footer } from '../components/Footer'\n\nexport default async function Page({ params: { lng } }) {\n  const { t } = await useTranslation(lng, 'second-page')\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <Link href={`/${lng}`}>\n        {t('back-to-home')}\n      </Link>\n      <Footer lng={lng}/>\n    </>\n  )\n}\n```\n\n![](switcher.gif)\n\n**🥳 Awesome, you've just created your first language switcher!**\n\n\n### 5. Client side <a name=\"step-5\"></a>\n\nSo far we've created server side pages only.\n<br />\nSo what do client side pages look like?\n\nSince client side react components can't `async` we need to do some adjustments.\n\n\nLet's introduce the `app/i18n/client.js` file:\n\n```js\n'use client'\n\nimport { useEffect, useState } from 'react'\nimport i18next from 'i18next'\nimport { initReactI18next, useTranslation as useTranslationOrg } from 'react-i18next'\nimport { useCookies } from 'react-cookie'\nimport resourcesToBackend from 'i18next-resources-to-backend'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport { getOptions, languages, cookieName } from './settings'\n\nconst runsOnServerSide = typeof window === 'undefined'\n\n// \ni18next\n  .use(initReactI18next)\n  .use(LanguageDetector)\n  .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))\n  .init({\n    ...getOptions(),\n    lng: undefined, // let detect the language on client side\n    detection: {\n      order: ['path', 'htmlTag', 'cookie', 'navigator'],\n    },\n    preload: runsOnServerSide ? languages : []\n  })\n\nexport function useTranslation(lng, ns, options) {\n  const [cookies, setCookie] = useCookies([cookieName])\n  const ret = useTranslationOrg(ns, options)\n  const { i18n } = ret\n  if (runsOnServerSide && lng && i18n.resolvedLanguage !== lng) {\n    i18n.changeLanguage(lng)\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const [activeLng, setActiveLng] = useState(i18n.resolvedLanguage)\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (activeLng === i18n.resolvedLanguage) return\n      setActiveLng(i18n.resolvedLanguage)\n    }, [activeLng, i18n.resolvedLanguage])\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!lng || i18n.resolvedLanguage === lng) return\n      i18n.changeLanguage(lng)\n    }, [lng, i18n])\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (cookies.i18next === lng) return\n      setCookie(cookieName, lng, { path: '/' })\n    }, [lng, cookies.i18next])\n  }\n  return ret\n}\n```\n\nOn client side the normal i18next singleton is ok. It will be initialized just once. And we can make use of the \"normal\" useTranslation hook. We just wrap it to have the possibility to pass in the language.\n\nTo align with the server side [language detection](#step-2) we make use of [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) and configure it accordingly.\n\n\nWe also need to create 2 versions of the Footer component.\n\n\n```\n.\n└── app\n    └── [lng]\n        └── components\n            └── Footer\n                ├── client.js\n                ├── FooterBase.js\n                └── index.js\n```\n\n`app/[lng]/components/Footer/FooterBase.js`:\n\n```js\nimport Link from 'next/link'\nimport { Trans } from 'react-i18next/TransWithoutContext'\nimport { languages } from '../../../i18n/settings'\n\nexport const FooterBase = ({ t, lng }) => {\n  return (\n    <footer style={{ marginTop: 50 }}>\n      <Trans i18nKey=\"languageSwitcher\" t={t}>\n        Switch from <strong>{{lng}}</strong> to:{' '}\n      </Trans>\n      {languages.filter((l) => lng !== l).map((l, index) => {\n        return (\n          <span key={l}>\n            {index > 0 && (' or ')}\n            <Link href={`/${l}`}>\n              {l}\n            </Link>\n          </span>\n        )\n      })}\n    </footer>\n  )\n}\n```\n\nThe server side part continuous to use the `async` version, `app/[lng]/components/Footer/index.js`:\n\n```js\nimport { useTranslation } from '../../../i18n'\nimport { FooterBase } from './FooterBase'\n\nexport const Footer = async ({ lng }) => {\n  const { t } = await useTranslation(lng, 'footer')\n  return <FooterBase t={t} lng={lng} />\n}\n```\n\nThe client side part will use the new `i18n/client` version, `app/[lng]/components/Footer/client.js`:\n\n```js\n'use client'\n\nimport { FooterBase } from './FooterBase'\nimport { useTranslation } from '../../../i18n/client'\n\nexport const Footer = ({ lng }) => {\n  const { t } = useTranslation(lng, 'footer')\n  return <FooterBase t={t} lng={lng} />\n}\n```\n\nA client side page could look like this - `app/[lng]/client-page/page.js`:\n\n```js\n'use client'\n\nimport Link from 'next/link'\nimport { useTranslation } from '../../i18n/client'\nimport { Footer } from '../components/Footer/client'\nimport { useState } from 'react'\n\nexport default function Page({ params: { lng } }) {\n  const { t } = useTranslation(lng, 'client-page')\n  const [counter, setCounter] = useState(0)\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <p>{t('counter', { count: counter })}</p>\n      <div>\n        <button onClick={() => setCounter(Math.max(0, counter - 1))}>-</button>\n        <button onClick={() => setCounter(Math.min(10, counter + 1))}>+</button>\n      </div>\n      <Link href={`/${lng}`}>\n        <button type=\"button\">\n          {t('back-to-home')}\n        </button>\n      </Link>\n      <Footer lng={lng} />\n    </>\n  )\n}\n```\n\nWith some translation resources:\n\n`app/i18n/locales/en/client-page.json`:\n\n```json\n{\n  \"title\": \"Client page\",\n  \"counter_one\": \"one selected\",\n  \"counter_other\": \"{{count}} selected\",\n  \"counter_zero\": \"none selected\",\n  \"back-to-home\": \"Back to home\"\n}\n```\n\n`app/i18n/locales/de/client-page.json`:\n\n```json\n{\n  \"title\": \"Client Seite\",\n  \"counter_one\": \"eines ausgewählt\",\n  \"counter_other\": \"{{count}} ausgewählt\",\n  \"counter_zero\": \"keines ausgewählt\",\n  \"back-to-home\": \"Zurück zur Hauptseite\"\n}\n```\n\nAnd a link in our initial page - `app/[lng]/page.js`:\n\n```js\nimport Link from 'next/link'\nimport { useTranslation } from '../i18n'\nimport { Footer } from './components/Footer'\n\nexport default async function Page({ params: { lng } }) {\n  const { t } = await useTranslation(lng)\n  return (\n    <>\n      <h1>{t('title')}</h1>\n      <Link href={`/${lng}/second-page`}>\n        {t('to-second-page')}\n      </Link>\n      <br />\n      <Link href={`/${lng}/client-page`}>\n        {t('to-client-page')}\n      </Link>\n      <Footer lng={lng}/>\n    </>\n  )\n}\n```\n\n...with translation resources:\n\n`app/i18n/locales/en/translation.json`:\n```json\n{\n  \"title\": \"Hi there!\",\n  \"to-second-page\": \"To second page\",\n  \"to-client-page\": \"To client page\"\n}\n```\n\n`app/i18n/locales/de/translation.json`:\n```json\n{\n  \"title\": \"Hallo Leute!\",\n  \"to-second-page\": \"Zur zweiten Seite\",\n  \"to-client-page\": \"Zur clientseitigen Seite\"\n}\n```\n\n**🎉🥳 Congratulations 🎊🎁**\n\n\nThe result should look like this:\n\n![](result.gif)\n\n*🧑‍💻 The complete code of an example app can be found [here](https://github.com/i18next/next-13-app-dir-i18next-example).*\n\n\n### 6. Bonus <a name=\"step-6\"></a>\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\nConnect to an awesome [translation management system](../tms/) and manage your translations outside of your code.\n\nLet's synchronize the translation files with [locize](https://locize.com).\nThis can be done on-demand or on the CI-Server or before deploying the app.\n\n#### What to do to reach this step:\n1. in locize: signup at https://locize.app/register and [login](https://docs.locize.com/integration/getting-started/create-a-user-account)\n2. in locize: [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n3. install the [locize-cli](https://github.com/locize/locize-cli) (`npm i locize-cli`)\n4. in locize: add all your additional languages (this can also be done via [API](https://docs.locize.com/integration/api#add-new-language) or with using the [migrate command](https://github.com/i18next/next-13-app-dir-i18next-example/blob/main/package.json#L10) of the locize-cli)\n\n#### Use the [locize-cli](https://github.com/locize/locize-cli)\nUse the `locize download` command to always download the published locize translations to your local repository (`app/i18n/locales`) before bundling your app. *[example](https://github.com/i18next/next-13-app-dir-i18next-example/blob/main/package.json#L11)*\n\nAlternatively, you can also use the `locize sync` command to synchronize your local repository (`app/i18n/locales`) with what is published on locize. *[example](https://github.com/i18next/next-13-app-dir-i18next-example/blob/main/package.json#L12)*\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about i18n in the new app directory setup, [Next.js](https://nextjs.org), [i18next](https://www.i18next.com), [react-i18next](https://react.i18next.com), [react-i18next](https://react.i18next.com), [i18next-resources-to-backend](https://github.com/i18next/i18next-resources-to-backend) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"next","slug":"next","permalink":"https://locize.com/blog/tags/next/"},{"name":"next-i18next","slug":"next-i18next","permalink":"https://locize.com/blog/tags/next-i18next/"}]},{"title":"Localization at Networkme (by Marcelo Manteigas)","slug":"networkme-locize","date":"un44fin44","updated":"un11fin11","comments":true,"path":"networkme-locize/","link":"","permalink":"https://locize.com/blog/networkme-locize/","excerpt":"","text":"Networkme is a career discovery and development platform that helps students find the best job for them to start their careers. We are often recognized as the “Linkedin for students” because we provide an ecosystem for companies to interact directly with their future talent through a platform that is better suited for this particular use case. The ProblemFrom the get-go we implemented our platform in 3 languages, Portuguese, English and Spanish to cover all the Iberian market and hopefully to capture some international user and companies looking to hire/work in this region. Our initial approach was to have a local JSON file inside the application to manage the different copies in the platform. However, as we grew in size and to currently 6 different web applications, it became almost impossible to manage everything effectively. In fact, at some point any request to change copy in any of the platform was taking 2 days to fulfill and changes would only reflect in the production environment according to the deploy schedule which could take a week. This obviously generated a lot of frustration for both the technical team because they were spending a lot of time fulfilling these requests instead of progressing in the roadmap, and the business team felt like we were not moving at the speed they needed. We found locize as a solution to give autonomy to business teams to make changes in the application copy and relive the technical team from this burden. Also, by using the locize features to better encapsulate the different projects we were able to implement governance features and drastically reduce the complexity to manage application with more than 10 thousand words. Favorite FeaturesThe best thing about using locize that really changed our game was the ability to have an in-context editor that allows non-technical collaborator to easily interface with our application copy creating an abstraction between the technical implementation in a JSON format. That is very powerful to help them navigate with agility and drastically reduced the risk of breaking anything in the application since they were changing directly in the application. The ability to create different projects and having RBAS implemented was especially important to implement the necessary governance to avoid conflicting work or worst having users accidently committing mistakes Final Thoughtslocize really changed positively our dynamic inside Networkme between business and technical teams by reducing the amount of time managing copy in the web applications and empowering the copywriters with the autonomy to move at the speed they expect. The development team became at least 20% more productive, since the only thing they needed to do was to create the keys through the development process and all the copy management afterwards was outside the set of their responsibilities. If you&#39;re new to locize, watch the demo video to learn more about it:","raw":"---\ntitle: Localization at Networkme (by Marcelo Manteigas)\ndescription: This is a guest blog post written by Marcelo Manteigas describing the experience with locize.\n\ndate: 2022-12-29\ntags:\n  - localization\n  - internationalization\n  - guest post\nthumbnail: networkme-locize/title.jpg\n---\n\n![](title.jpg)\n\n[Networkme](https://www.networkme.io) is a career discovery and development platform that helps students find the best job for them to start their careers. We are often recognized as the “Linkedin for students” because we provide an ecosystem for companies to interact directly with their future talent through a platform that is better suited for this particular use case. \n\n## The Problem\n\nFrom the get-go we implemented our platform in 3 languages, Portuguese, English and Spanish to cover all the Iberian market and hopefully to capture some international user and companies looking to hire/work in this region. Our initial approach was to have a local JSON file inside the application to manage the different copies in the platform. However, as we grew in size and to currently 6 different web applications, it became almost impossible to manage everything effectively. In fact, at some point any request to change copy in any of the platform was taking 2 days to fulfill and changes would only reflect in the production environment according to the deploy schedule which could take a week.\n\nThis obviously generated a lot of frustration for both the technical team because they were spending a lot of time fulfilling these requests instead of progressing in the roadmap, and the business team felt like we were not moving at the speed they needed.\n\nWe found [locize](/) as a solution to give autonomy to business teams to make changes in the application copy and relive the technical team from this burden. Also, by using the [locize](/) features to better encapsulate the different projects we were able to implement governance features and drastically reduce the complexity to manage application with more than 10 thousand words.\n\n\n## Favorite Features\n\nThe best thing about using locize that really changed our game was the ability to have an [in-context editor](https://docs.locize.com/whats-inside/context#incontext-view) that allows non-technical collaborator to easily interface with our application copy creating an abstraction between the technical implementation in a JSON format. That is very powerful to help them navigate with agility and drastically reduced the risk of breaking anything in the application since they were changing directly in the application.\n\n\n![](incontext.jpg)\n\nThe ability to create different projects and having RBAS implemented was especially important to implement the necessary governance to avoid conflicting work or worst having users accidently committing mistakes\n\n\n## Final Thoughts\n\n[locize](/) really changed positively our dynamic inside Networkme between business and technical teams by reducing the amount of time managing copy in the web applications and empowering the copywriters with the autonomy to move at the speed they expect.\nThe development team became **at least 20% more productive**, since the only thing they needed to do was to create the keys through the development process and all the copy management afterwards was outside the set of their responsibilities.\n\nIf you're new to locize, watch the [demo video](https://youtu.be/ds-yEEYP1Ks) to learn more about it:\n{% youtube ds-yEEYP1Ks %}","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"guest post","slug":"guest-post","permalink":"https://locize.com/blog/tags/guest-post/"}]},{"title":"Localization strategy - How to build with examples","slug":"localization-strategy","date":"un33fin33","updated":"un55fin55","comments":true,"path":"localization-strategy/","link":"","permalink":"https://locize.com/blog/localization-strategy/","excerpt":"","text":"Today, you&#39;re going to learn how to build your strategy for a successful globalization. You will get a method on how you can increase your sales and make your customers more happy. The best part? We provide you with a step-by-step plan of what you need to get to your localization strategies. We&#39;ll also show you some examples of major brands and how they did it. What you can expect What is a strategy for localization Why do you need such a strategy Build your localization approach (step-by-step) Benefits of localization Localization checklist Examples Summary What is a localization strategy?A localization strategy is a way of dealing with a company&#39;s customers&#39; purchasing habits, behavior, and cultural differences throughout globalization. Why do you need it?It will undoubtedly be difficult to develop local leadership, sales, and other skills. In a local market, there may be unanticipated obstacles, ranging from minor details to issues with complying with country-specific legislation. With this in mind, globalization should be a step-by-step strategic process that takes into account the genuine cost and time required, as well as the possible prospects offered by new markets. According to a study of harvard business review the management of the company which succeeded in going global acted like this: They ensure that the company has the necessary expertise and abilities. They match the size and breadth of the international opportunity to the firm&#39;s objectives and capabilities. Likewise, they modify the firm&#39;s marketing policies and processes in response to the opportunity. They guarantee that the firm&#39;s legal and ethical policies allow for international flexibility while adhering to corporate compliance. They encourage a company culture that accepts some financial ambiguity and market volatility. ➡️ Ultimately, they have prepared well and accepted some mistakes to happen. That is also what you need for your localization strategy! Because localized products and services better meet local market circumstances and minimize cultural barriers, professional localization helps to lower the barrier for new prospective customers. Localization enhances your customer base by allowing more customers to learn about your items. Build your localization approach (step-by-step)PrepareGet the right people involved in your company to do this project. And create a reasonable timeline for achieving the end goal. Try to attract local talents: To get the right and experienced workers will may give you insights in the cultural aspects Gather the inputsTo determine whether there is a strong potential to join the markets, it might be beneficial to send someone there to learn from local partners or individuals. In addition, conduct the following research: Discover the facts and data about a new target country. Learn how to determine prices: legal and economic variations in the target nation may be a barrier. ➡️ The most important part is to get a better understanding of which brands are your primary rivals and how consumers buy in that market. This will provide the structure for everything you do after that. Create your visionYour mission statement should describe what your company does and how it is different from other organizations in the new market. Your vision statement should be a future state of what your organization wants to achieve over time with the project. Build the planMake a international business plan: Evaluate your needs and goals When looking at the content marketing side of things, you should setup a process to create the marketing message and see what results can be produced in other markets (Messages, graphics, and UX elements). Successful marketing campaigns can help to test out if your strategy is working and if we&#39;re targeting the right audience. Finally, do the customer segmentation which defines the different groups of people or organizations a company aims to reach or serve. Make tests with localized contentTest your strategy by reaching out to potential buyers in new markets with your messaging. To begin, make use of the slogans, key phrases, and CTAs identified in the localized-marketing strategy when developing the plan. Begin with a pilot project to get traction, and then consider localizing entire experiences based on the data. The objective should also be to see if your communications can persuade them to engage with your business. For example, moderated customer journey testing can assist you in understanding and appreciating acceptable ways of interacting with local cultures and meeting their specific buyer expectations. A thumbs-up gesture, for example, may be acceptable in the United States or the United Kingdom but may be considered insulting in Australia. Hire someone who can do customer experience testing; this is an important aspect of how customers connect with your business. Examine what your website visitors are doing and where they are clicking when they visit your site. There are a lot of methods to simplify the continuing problem of maintaining excellent customer experience. Put the strategy into practiceEnsure your project leads pushing things forward. Build an internal and external strategy communication plan. And setup the action plan for future work needed. Also define the Key Performance Indicators (KPI) that measures the result will come to your organization from the actions taken. Multi-lingual websiteUsually, for a multi-lingual website the first thing to think about is the language URL format. Source: WPML These are the best practices from Google regarding the URL format: For different language versions, there should be different URL Use a hreflang-tag to help Google find the correct language Use a single language for content and navigation on each page and avoid side-by-side translations Let the user choose the page language, add hyperlinks to each language version ➡️ The below URL formats are recommended: country-specific: yoursite.de subdomains with gTLD: de.yoursite.com subdirectories with gTLD: example.com/de/ Not recommended are URL parameters like yoursite.com?loc=de Benefits of localization 1. It helps to reduce immediate costsLack of preparation can result in significant up-front expenses like product or service recalls or the need to alter marketing tactics when entering a new market. If you use a thorough localization plan, the likelihood of the above happening and the added costs that result from it will be reduced. 2. It improves branding&#39;s trustIt considers the branding colors and marketing messages that are suitable for the regional market. Every nation has a different idea of what is &quot;normal.&quot; The promotion of new goods and services is one of branding&#39;s most significant advantages. People who are loyal to a brand are inevitably interested in any new products the brand releases. This is essential for brands which are going global. 3. It increases the revenueThere are now unexplored markets of billions of clients that are prepared to buy. As long as the additional profits earned surpass the costs of entering the new market, more customers lead to better sales. According to recent study, businesses that use localization typically make 1.5 times as much as those that don&#39;t. Not only the revenue, also the return on investment can be improved if you use the right translation management system during the process of internationalization. Because in this way the project managers and translators can work much more efficient and you’ll be sure to get the most out of your resources. If you apply the proper translation management system during the internationalization process, you may increase not only the revenue but also the return on investment. Since this will allow the project managers, developers and translators to work much more productively and ensure that you make the most of your resources. In this case managing translated content is simple and doesn&#39;t require manual project team communication. 4. Less customer churnThe number of consumers or subscribers who ceased using your product or service over a specific time period is referred to as your customer churn rate. The degree to which your product will satisfy customers and reduce customer turnover depends on a number of factors. Localization is helping to reduce overall churn in this situation. The most crucial factors, including language barriers, local customer habits, and cultural considerations, will be taken into account during localization of a business. Localization ChecklistIf you have setup your localization-strategy and successfully decided how you will structure the corporate website, then it&#39;s time to start localizing your content. The meaning of localization is adjusting your content to encourage customers in new markets to buy from you. Decide how to integrate localization in the development process Let your developer add new segments to translation management system Let your translators start the work Review the work of the translators Deliver the content to the end users Check your progress with project metrics ➡️ Especially with using a localization service, you can see the impact of your content and the strategy right away when enter new markets. You can also determine whether the strategy is working as intended. ExamplesLocalization has clearly become a competitive advantage. If your business wants to enter and thrive in new markets in this global economy, you must localize your experience for people all around the world. On the following lines, we show you popular brands which have their own successful strategy for localization: 1) World Wide Fund For Nature (WWF)WWF is doing a lot to engage prospective audiences throughout the world. By emphasizing the information that is most important to readers, the WWF is able to create a more appealing experience with more engaging content that is always new and fresh. ✅ It is not only translating its website; it is providing the appropriate material to the appropriate viewers. 2) Starbucks Coffee CompanyThe company&#39;s website has been localized, making it available in the local language and in accordance with local tastes. They tailor the formulas and packaging to the market, emphasizing local ingredients and creative designs. Starbucks, for example, was localizing its brand and adapting to Indian culture in India. It presents various goods with an Indian flavor and emphasizes tea over coffee since Indians are more associated with tea. In the United Kingdom, Starbucks adapted to local tastes by including scones and bacon butties on select menus. Even more examples from our clients you will find in our blog post about website localization SummaryThe strategy for effective localization is successful if you can gather the necessary information about your target buyers and devise a plan of action to match their expectations. We hope this guide showed you what a strategy is and why it&#39;s important. With this basic knowledge you now maybe better understand the concept of localization. Localization will guarantee a significant return on investment that will amaze all of your company&#39;s stakeholders. Now we want to turn it over to you: Do you plan to build up a localization strategy? Are you going to test your slogans and CTA? Or maybe you’re going to use our checklist. Or maybe you have a question about something you read. Either way, let us know by leaving a message to support@locize.com right now. The implementation of the software part can be assisted by our team&#39;s extensive knowledge and the appropriate localization software of us. register","raw":"---\ntitle: Localization strategy - How to build with examples\ndescription: How to build a localization strategy, and understand the concept of localization to achieve growth during globalization.\ndate: 2022-12-07 15:49:50\ntags:\n  - localization\n  - marketing\n  - international strategy\n  - transnational strategy\n  - successful global localization \nthumbnail: localization-strategy/localization-strategy-concept.webp\n---\n\n<br/>\n\n{% youtube PtFEPtsmp-Y %}\n\n\nToday, you're going to learn how to build your strategy for a successful globalization.\n\nYou will get a method on how you can increase your sales and make your customers more happy.\n\n> The best part?\n\nWe provide you with a <b>step-by-step plan of what you need</b> to get to your localization strategies. \n\nWe'll also show you some examples of major brands and how they did it.\n\n\n## What you can expect\n* [What is a strategy for localization](#what)\n* [Why do you need such a strategy](#why)\n* [Build your localization approach (step-by-step)](#build)\n* [Benefits of localization](#localization)\n* [Localization checklist](#checklist)\n* [Examples](#examples)\n* [Summary](#summary)\n\n\n## What is a localization strategy?<a name=\"what\"></a>\nA localization strategy is a <b>way of dealing with a company's customers' purchasing habits, behavior, and cultural differences</b> throughout globalization.\n\n![](localization-strategy-concept.webp \"Localization strategy\")\n\n## Why do you need it?<a name=\"why\"></a>\nIt will undoubtedly be difficult to develop local leadership, sales, and other skills. In a local market, there may be unanticipated obstacles, ranging from minor details to issues with complying with country-specific legislation.\n\nWith this in mind, globalization should be a step-by-step strategic process that takes into account the genuine cost and time required, as well as the possible prospects offered by new markets.\n\nAccording to a <a href=\"https://hbr.org/2016/04/does-your-company-have-what-it-takes-to-go-global?ab=at_art_art_1x1\" title=\"study of harvard business review\">study of harvard business review</a> the management of the company which succeeded in going global acted like this:\n\n- They ensure that the company has the necessary expertise and abilities.\n- They match the size and breadth of the international opportunity to the firm's objectives and capabilities.\n- Likewise, they modify the firm's marketing policies and processes in response to the opportunity.\n- They guarantee that the firm's legal and ethical policies allow for international flexibility while adhering to corporate compliance.\n- They encourage a company culture that accepts some financial ambiguity and market volatility.\n\n➡️ <b>Ultimately, they have prepared well and accepted some mistakes to happen. That is also what you need for your localization strategy!</b>\n\n![](hbr-win-lose-global.webp \"harvard business review win lose global\")\n\nBecause localized products and services better meet local market circumstances and minimize cultural barriers, professional localization helps to lower the barrier for new prospective customers. \n\nLocalization enhances your customer base by allowing more customers to learn about your items.\n\n## Build your localization approach (step-by-step)<a name=\"build\"></a>\n\n### Prepare\nGet the right people involved in your company to do this project. And create a reasonable timeline for achieving the end goal.\n\nTry to attract local talents: To get the right and experienced workers will may give you insights in the cultural aspects\n\n### Gather the inputs\n\nTo determine whether there is a strong potential to join the markets, it might be beneficial to send someone there to learn from local partners or individuals.\n\nIn addition, conduct the following research: Discover the facts and data about a new target country.\n\nLearn how to determine prices: legal and economic variations in the target nation may be a barrier.\n\n\n\n➡️ The most important part is to get a better understanding of which brands are your primary rivals and how consumers buy in that market. This will provide the structure for everything you do after that.\n\n\n### Create your vision\nYour mission statement should describe what your company does and how it is different from other organizations in the new market. \n\nYour vision statement should be a future state of what your organization wants to achieve over time with the project.\n\n### Build the plan \n\nMake a international business plan: Evaluate your needs and goals \n\nWhen looking at the content marketing side of things, you should setup a process to create the marketing message and see what results can be produced in other markets (Messages, graphics, and UX elements).\n\nSuccessful marketing campaigns can help to test out if your strategy is working and if we're targeting the right audience.\n\nFinally, do the customer segmentation which defines the different groups of people or organizations a company aims to reach or serve.\n\n\n\n### Make tests with localized content\nTest your strategy by reaching out to potential buyers in new markets with your messaging.\n\nTo begin, make use of the slogans, key phrases, and CTAs identified in the <a href=\"/blog/localization-marketing/\" title=\"localized-marketing\">localized-marketing</a> strategy when developing the plan.\n\nBegin with a pilot project to get traction, and then consider localizing entire experiences based on the data.\n\nThe objective should also be to see if your communications can persuade them to engage with your business.\n\nFor example, moderated customer journey testing can assist you in understanding and appreciating acceptable ways of interacting with local cultures and meeting their specific buyer expectations.\n\nA thumbs-up gesture, for example, may be acceptable in the United States or the United Kingdom but may be considered insulting in Australia.\n\nHire someone who can do customer experience testing; this is an important aspect of how customers connect with your business. Examine what your website visitors are doing and where they are clicking when they visit your site.\n\nThere are a lot of methods to simplify the continuing problem of maintaining excellent customer experience.\n\n### Put the strategy into practice\nEnsure your project leads pushing things forward. \n\nBuild an internal and external strategy communication plan.\n\nAnd setup the action plan for future work needed. \n\nAlso define the Key Performance Indicators (KPI) that measures the result will come to your organization from the actions taken.\n\n#### Multi-lingual website\nUsually, for a multi-lingual website the first thing to think about is the language URL format.\n\n<br>\n\n![](language-url.webp \"language url example\")\n<small style=\"font-size:0.7rem\">Source: <a href=\"https://wpml.org/documentation/getting-started-guide/language-setup/language-url-options/\" title=\"WPML\">WPML</a> </small>\n<br>\n\nThese are the <a href=\"https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-sites?hl=en\" title=\"best practices from Google\">best practices from Google</a> regarding the URL format:\n\n- For different language versions, there should be different URL\n- Use a hreflang-tag to help Google find the correct language\n- Use a single language for content and navigation on each page and avoid side-by-side translations\n- Let the user choose the page language, add hyperlinks to each language version\n\n➡️ The below URL formats are recommended: \n\ncountry-specific: <b>yoursite.de</b><br>\nsubdomains with gTLD: <b>de.yoursite.com</b><br>\nsubdirectories with gTLD: <b>example.com/de/</b>\n\nNot recommended are URL parameters like <b>yoursite.com?loc=de</b>\n\n\n## Benefits of localization<a name=\"localization\"></a>\n\n![](benefits.webp \"benefits of localization\")\n\n\n### 1. It helps to reduce immediate costs\nLack of preparation can result in significant up-front expenses like product or service recalls or the need to alter marketing tactics when entering a new market. If you use a thorough localization plan, the likelihood of the above happening and the added costs that result from it will be reduced.\n\n\n### 2. It improves branding's trust\nIt considers the branding colors and marketing messages that are suitable for the regional market. Every nation has a different idea of what is \"normal.\" \n\nThe promotion of new goods and services is one of branding's most significant advantages. People who are loyal to a brand are inevitably interested in any new products the brand releases. This is essential for brands which are going global.\n\n### 3. It increases the revenue\nThere are now unexplored markets of billions of clients that are prepared to buy. As long as the additional profits earned surpass the costs of entering the new market, more customers lead to better sales. \n\nAccording to <a href=\"https://hbr.org/2006/04/localization-the-revolution-in-consumer-markets\" title=\"recent study\">recent study</a>, businesses that use localization typically make 1.5 times as much as those that don't.\n\nNot only the revenue, also the <a href=\"https://en.wikipedia.org/wiki/Return_on_investment\">return on investment</a> can be improved if you use the right <a href=\"https://locize.com/blog/tms/\" title=\"translation management system\">translation management system</a> during the process of internationalization. \n\nBecause in this way the project managers and translators can work much more efficient and you’ll be sure to get the most out of your resources.\n\nIf you apply the proper <a href=\"https://locize.com/blog/tms/\" title=\"translation management system\">translation management system</a> during the internationalization process, you may increase not only the revenue but also the <a href=\"https://en.wikipedia.org/wiki/Return_on_investment\">return on investment</a>. \n\nSince this will allow the project managers, developers and translators to work much more productively and ensure that you make the most of your resources. In this case managing translated content is simple and doesn't require manual project team communication.\n\n\n### 4. Less customer churn\nThe number of consumers or subscribers who ceased using your product or service over a specific time period is referred to as your customer churn rate.\n\nThe degree to which your product will satisfy customers and reduce customer turnover depends on a number of factors. Localization is helping to reduce overall churn in this situation. \n\nThe most crucial factors, including language barriers, local customer habits, and cultural considerations, will be taken into account during localization of a business.\n\n\n\n## Localization Checklist<a name=\"checklist\"></a>\n\nIf you have setup your localization-strategy and successfully decided how you will structure the corporate website, then it's time to start localizing your content.\n\n<a href=\"/blog/localization/\" title=\"The meaning of localization\">The meaning of localization</a> is adjusting your content to encourage customers in new markets to buy from you.\n\n- Decide how to integrate localization in the development process\n- Let your developer add new segments to translation management system\n- Let your translators start the work\n- Review the work of the translators\n- Deliver the content to the end users\n- Check your progress with project metrics\n\n➡️ Especially with using a <a href=\"https://locize.com/\" title=\"localization service\">localization service</a>, you can see the <b>impact of your content and the strategy right away when enter new markets</b>. You can also determine whether the strategy is working as intended.\n\n## Examples<a name=\"examples\"></a>\n\nLocalization has clearly become a competitive advantage. If your business wants to enter and thrive in new markets in this global economy, you must localize your experience for people all around the world.\n\nOn the following lines, we show you popular brands which have their own successful strategy for localization:\n\n#### 1) [World Wide Fund For Nature (WWF)](https://www.worldwildlife.org/)\n\nWWF is doing a lot to engage prospective audiences throughout the world. \n\n<a href=\"https://www.worldwildlife.org/\" title=\"wwf\">![wwf](wwf.webp \"wwf\")</a>\n\n\nBy emphasizing the information that is most important to readers, the WWF is able to create a more appealing experience with more engaging content that is always new and fresh.\n\n✅ It is not only translating its website; it is providing the appropriate material to the appropriate viewers. \n\n\n\n#### 2) [Starbucks Coffee Company](https://www.starbucks.com/)\n\nThe company's website has been localized, making it available in the local language and in accordance with local tastes.\n\n<a href=\"https://www.starbucks.com/\" title=\"Starbucks Coffee Company\">![Starbucks Coffee Company](starbucks.webp \"starbucks\")</a>\n\nThey tailor the formulas and packaging to the market, emphasizing local ingredients and creative designs.\n\nStarbucks, for example, was localizing its brand and adapting to Indian culture in India. It presents various goods with an Indian flavor and emphasizes tea over coffee since Indians are more associated with tea. \n\nIn the United Kingdom, Starbucks adapted to local tastes by including scones and bacon butties on select menus.\n\nEven more examples from our clients you will find in our blog post about <a href=\"/blog/website-localization/\" title=\"website localization\">website localization</a> \n\n## Summary<a name=\"summary\"></a>\n\nThe strategy for effective localization is successful if you can gather the necessary information about your target buyers and devise a plan of action to match their expectations.\n\nWe hope this guide showed you what a strategy is and why it's important. With this basic knowledge you now maybe better understand the concept of localization.\n\nLocalization will guarantee a significant return on investment that will amaze all of your company's stakeholders.\n\n<b>Now we want to turn it over to you:</b>\n\nDo you plan to build up a localization strategy?\n\nAre you going to test your slogans and CTA? Or maybe you’re going to use our checklist.\n\nOr maybe you have a question about something you read.\n\nEither way, let us know by leaving a message to <a href=\"mailto:support@locize.com\" title=\"support@locize.com\">support@locize.com</a> right now.</br>\n\nThe implementation of the software part can be assisted by our team's extensive knowledge and the appropriate <a href=\"https://locize.com/\" title=\"localization software\">localization software</a> of us.\n\n<a class=\"btn btn-outline btn-xl\" style=\"color:white\" href=\"https://www.locize.app/register\" title=\"register to locize\">register</a>","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"marketing","slug":"marketing","permalink":"https://locize.com/blog/tags/marketing/"},{"name":"transnational strategy","slug":"transnational-strategy","permalink":"https://locize.com/blog/tags/transnational-strategy/"},{"name":"successful global localization","slug":"successful-global-localization","permalink":"https://locize.com/blog/tags/successful-global-localization/"}]},{"title":"The hidden localization costs","slug":"hidden-localization-costs","date":"un55fin55","updated":"un00fin00","comments":true,"path":"hidden-localization-costs/","link":"","permalink":"https://locize.com/blog/hidden-localization-costs/","excerpt":"","text":"Big companies that reach hundreds of countries can spend millions on translation costs alone and still not reach all their audience. There are revealing facts about the business growth for high-quality localized content to engage new audiences, grow brand recognition and loyalty and boost revenue. Localized content is important to enhance top of funnel efforts. Everyone can estimate the cost of content localization by obtaining bids from language service providers. But companies often forget the actual translation work cost is just a minimal part of the complete localization costs. What many may not consider when calculating the budget are the hidden costs of localization, for example: extract source files from your software project copy-pasting, exporting, importing, etc... from your resource files to various file formats for translation and back again order translations, sending emails to translators to check how much they have translated, proofreading... converting files to different formats, getting charged by translation agencies for converting your files to formats used by the translators import/sync translated resources back to your software project, resolve conflicts because in the meantime new features or software changes have been made, etc... release new version of software because of translation issue, new roundtrip for a better alignement, a dedicated resource for technical writer/translator/coordinator development team &lt;-&gt; translation team alignments managing the localization process with tools and workflows that haven&#39;t changed for a lot of years delayed rollout because of delayed translations, alternatively lock down content changes 2 to 3 months ahead of the launch date to carry out localization ... In terms of your investment, the above hidden costs tend to be higher than the actual cost of translation. How to get rid of these hidden costs? ➡️ Good processes and modern tools that are focused on you with your development team and not only the translation service provider. By improving workflow processes and using a modern translation management system like locize, the content is translated faster and your software is released more efficiently. Moreover, you will reach your target audiences faster, trying to get ahead of your competition.","raw":"---\ntitle: The hidden localization costs\ndescription: There are a lot of hidden costs when you're investigating your software localization process.\n\ndate: 2022-12-02\ntags:\n  - localization\n  - international strategy\n  - global localization\n  - internationalization\n\nthumbnail: hidden-localization-costs/title.jpg\n\nlabel: hidden-localization-costs\nlang: en\n---\n\n![](title.jpg)\n\nBig companies that reach hundreds of countries can spend millions on translation costs alone and still not reach all their audience.\n\nThere are [revealing facts](../grow-online-business/) about the business growth for high-quality localized content to engage new audiences, grow brand recognition and loyalty and boost revenue.\n\nLocalized content is important to enhance top of funnel efforts. Everyone can estimate the cost of content localization by obtaining bids from [language service providers](/services.html#translationservices).\nBut companies often forget the actual translation work cost is just a minimal part of the complete localization costs.\n\nWhat many may not consider when calculating the budget are the hidden costs of localization, for example:\n\n- extract source files from your software project\n- copy-pasting, exporting, importing, etc... from your resource files to various file formats for translation and back again\n- order translations, sending emails to translators to check how much they have translated, proofreading...\n- converting files to different formats, getting charged by translation agencies for converting your files to formats used by the translators\n- import/sync translated resources back to your software project, resolve conflicts because in the meantime new features or software changes have been made, etc...\n- release new version of software because of translation issue, new roundtrip\n- for a better alignement, a dedicated resource for technical writer/translator/coordinator\n- [development team <-> translation team alignments](../help-tech-leads/)\n- managing the localization process with tools and workflows that haven't changed for a lot of years\n- [delayed rollout](https://youtu.be/YQryHo1iHb8) because of delayed translations, alternatively lock down content changes 2 to 3 months ahead of the launch date to carry out localization\n- ...\n\nIn terms of your investment, the above hidden costs tend to be higher than the actual cost of translation.\n\n>How to get rid of these hidden costs?\n\n➡️ Good processes and [modern tools](../i18n-l10n-t9n-tms/) that are focused on you with your development team and not only the translation service provider.\n\nBy [improving workflow processes](../8-signs-you-should-improve-your-localization-process/) and using a [modern](../modern-continuous-localization/) [translation management system](../tms/) like [locize](https://locize.com), the content is translated faster and your software is released more efficiently. Moreover, you will reach your target audiences faster, trying to get ahead of your competition.\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"}]},{"title":"Localization at Immersive Communities (by Mario Stopfer)","slug":"immersive-locize","date":"un22fin22","updated":"un66fin66","comments":true,"path":"immersive-locize/","link":"","permalink":"https://locize.com/blog/immersive-locize/","excerpt":"","text":"Immersive Communities is a social media platform for content creators. It allows users to create their community and have mambers write articles on any topic they care about. As a solo-developer, I&#39;ve worked for just over 4 years to deliver the platform to a global audience. Since my goal was to have a global reach from day one, it goes without saying that localization was something I took seriously. I&#39;ve decided to have the platform fully localized in 10 languages at launch. This, would certainly take a lot of time and effor, so I started looking for possible SaaS solutions to his problem. My first search result was locize and it looked promising so I gave it a go. Needless to say, I wasn&#39;t disappoined and I neded up using locize to fully localize my platform. Favorite FeaturesThe best thing about locize that I found useful was the ability to create multiple projects. Inside each project you can have multiple documents (namespaces), which came useful to me, since I would have at least 2 different website types. One would be the main website and the other, the other would represent all the other community websites where users can write articles on. Now I had the ability to load only the namespaces and translations I wanted, based on which website layout I was loading. The other invaluable feature was the ability to automatically translate all your phrases using Google Translate, but locize took it one step further by being compliant with i18next standards and also adding appropriate singular and plural translations. This would not be possible for me to do by myself since I would have to have inshight into the grammar rules of each language I wanted localized. Corner Cases handled with EaseAside from plurals, I also had to handle time and counts of items. Luckily, using interpolation, locize understood my request and properly formatted the time which I used to show how long ago each article was written. Also, the count of items, for example comments each article gets, was formatted properly. But this was not the biggest hurdle I had to jump over. My real challenge was to localize my Landing Page. The challenge came in the form of not only translating the text, but also adding the appropriate styling. Since different languages have different grammar rules, I couldn&#39;t just reuse a word which I translated previously, style it and add it to the phrase list. This means that I had to use regular white font with my titles, but also had to apply a CSS color gradient on some words, to indicate important part of each title. I had to add styling for each title at a different place and then have them translated and displayed to the user. The best part is that this was not just any text, but actually Markdown, which was then passed through a Markdown processor, which actually then generated styled HTML. The end result is that titles on the landing page have multiple styles applied to them. Final ThoughtsI found locize to be invaluable to my localization effort. I will continue using it for other projects and the ability to pause your project and pay less for your monthly subscription when you&#39;re not using it is an added bonus! In this article you can read a lot more about how I built this social network in 4 years as a solo developer. If you&#39;re new to locize, watch the demo video to learn more about it:","raw":"---\ntitle: Localization at Immersive Communities (by Mario Stopfer)\ndescription: This is a guest blog post written by Mario Stopfer describing the experience with locize.\n\ndate: 2022-11-08\ntags:\n  - localization\n  - internationalization\n  - guest post\nthumbnail: immersive-locize/title.jpg\n---\n\n![](title.jpg)\n\n[Immersive Communities](https://immersive.community) is a social media platform for content creators. It allows users to create their community and have mambers write articles on any topic they care about. As a solo-developer, I've worked for just over 4 years to deliver the platform to a global audience. Since my goal was to have a global reach from day one, it goes without saying that localization was something I took seriously.\n\nI've decided to have the platform fully localized in 10 languages at launch. This, would certainly take a lot of time and effor, so I started looking for possible SaaS solutions to his problem. My first search result was [locize](/) and it looked promising so I gave it a go. Needless to say, I wasn't disappoined and I neded up using [locize](/) to fully localize my platform.\n\n## Favorite Features\n\nThe best thing about [locize](/) that I found useful was the ability to create multiple projects. Inside each project you can have multiple documents ([namespaces](https://docs.locize.com/more/namespaces)), which came useful to me, since I would have at least 2 different website types.\n\nOne would be the main website and the other, the other would represent all the other community websites where users can write articles on. Now I had the ability to load only the [namespaces](https://docs.locize.com/more/namespaces) and translations I wanted, based on which website layout I was loading.\n\nThe other invaluable feature was the ability to automatically translate all your phrases using Google Translate, but [locize](/) took it one step further by being compliant with [i18next](https://www.i18next.com) standards and also adding appropriate singular and plural translations. This would not be possible for me to do by myself since I would have to have inshight into the grammar rules of each language I wanted localized.\n\n## Corner Cases handled with Ease\n\nAside from plurals, I also had to handle time and counts of items. Luckily, using interpolation, [locize](/) understood my request and properly formatted the time which I used to show how long ago each article was written. Also, the count of items, for example comments each article gets, was formatted properly. But this was not the biggest hurdle I had to jump over.\n\nMy real challenge was to localize my [Landing Page](https://immersive.community/home/login). The challenge came in the form of not only translating the text, but also adding the appropriate styling. Since different languages have different grammar rules, I couldn't just reuse a word which I translated previously, style it and add it to the phrase list.\n\nThis means that I had to use regular white font with my titles, but also had to apply a **CSS** color gradient on some words, to indicate important part of each title. I had to add styling for each title at a different place and then have them translated and displayed to the user. \n\nThe best part is that this was not just any text, but actually **Markdown**, which was then passed through a Markdown processor, which actually then generated styled **HTML**. The end result is that titles on the landing page have multiple styles applied to them.\n\n![](screens.jpg)\n\n## Final Thoughts\n\nI found [locize](/) to be invaluable to my localization effort. I will continue using it for other projects and the ability to pause your project and pay less for your monthly subscription when you're not using it is an added bonus!\n\nIn [this article](https://betterprogramming.pub/how-i-built-a-social-network-in-4-years-as-a-solo-developer-4af70fb2d4c8) you can read a lot more about how I built this social network in 4 years as a solo developer.\n\nIf you're new to locize, watch the [demo video](https://youtu.be/ds-yEEYP1Ks) to learn more about it:\n{% youtube ds-yEEYP1Ks %}\n\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"guest post","slug":"guest-post","permalink":"https://locize.com/blog/tags/guest-post/"}]},{"title":"Multi tenant architecture | locize","slug":"multi-tenant","date":"un33fin33","updated":"un66fin66","comments":true,"path":"multi-tenant/","link":"","permalink":"https://locize.com/blog/multi-tenant/","excerpt":"","text":"You&#39;re going to learn about a subject today that is more popular than ever. We now offer our consumers this unique functionality. Without the client having to pay more, this will contribute to raising the value of our localization software. Let&#39;s start by reviewing basic definitional information concerning multi-tenant as well as the benefits of such an architecture. Definition: Multi tenantA software that is multi-tenant may serve several customers with a single application instance. A single instance of a software program (and its underlying database and technology) supports several tenants in multi-tenant software architecture, also known as software multi-tenancy (or user accounts). Each tenant can customize the program by changing some basic parameters. This might involve the look and feel of the user interface, user administration, or adding custom code to the program. In this situation, instead of a dedicated server, the space for each tenant or client is shared. The multi-tenant nature of SaaS systems necessitates a greater emphasis on ensuring that all efforts are taken to isolate tenant resources. There are three main types of multi tenant architecture: 1) Shared databaseA multi-tenancy architecture with a multi-tenant database is a single, shared database structure. Because shared resources are used, this is the simplest of the three kinds and has a relatively low cost to tenants. To host tenants and store data, this design employs a single application and database instance. Using a single, common database schema provides for faster scaling, but can result in greater total running expenses. 2) Single database with several schemasA single database with several schemas is another approach to multi-tenancy. This approach has a single application instance and separate databases for each tenant. Because of this design, each individual database incurs more expenses and requires more administrative effort. It is useful when data from various clients must be processed differently, such as when they are located in different countries with different legislation. 3) Several databasesData is stored in numerous databases in the third type of multi-tenant architecture. This approach is very difficult in terms of administration and maintenance, however renters may be distinguished from one another using a predefined criterion. The advantages of multi tenant applicationsThe huge advantage for shared resources is that it will make the entry cost very low and the scalability easier and faster. These are the main other advantages of multi-tenant architecture: Lower costs: When compare to other hosting architectures, it’s costs less than a single infrastructure is used for multiple tenants No maintenance at all: Always up-to-date code as the host is taking care of maintenance. New features are implemented without the customer&#39;s involvement and just once. Highly scalable: The architecture is easily scalable on demand, new users access to the same instance Easy customization: It’s highly flexible, allowing each tenant client to modify the application to their individual business needs without incurring the expense, time, and risk of having an own development. High productivity: There is an improvement in productivity for the tenant because there is no need to manage the infrastructure. Multi-tenant vs. single-tenantThe main difference is the access to source-code. In single-tenant architectures, a tenant will have a singular instance of an application dedicated to them. The key distinction is the availability of source code. A tenant in a single-tenant architecture will have a single instance of an application devoted to them. ExampleAssume that each client has a separate residence that is completely cut off from any nearby structures. In a multi-tenant cloud architecture, tenants reside in several apartments inside the same structure. The same security system and communal utilities link them all. However, each tenant&#39;s privacy is protected within their apartment since they each have a key. But it&#39;s more probable that their neighbors&#39; behavior will affect how comfortable they are in the flat. How locize introduce multi-tenant in translation managementFor locize the multi-tenant approach is less of the classical infrastrucutre topic, but it still makes perfect sense for the translation management system since it functions as a fully independent application/project that is integrated into your own application or website. This means that our customers (you) can in turn integrate the own customers or other projects into the account without opening another account. Uniqueness The concept of multi-tenancy is absolutely new and exclusive to the localization industry. Use the most up to date software for this purpose, locize With the multi-tentant function to happen: With limited access, you can assign your own clients a dedicated project without spending money on new infrastructure. Advanced user management enhances workflow flexibility in general. The localization software will increase in scale from its current level. Testimonials Check out our customer success stories for more examples of who is using our service. ➡️ Read more: Here you will find the instructions how to add a multi-tenant project for locize. Your primary project&#39;s material serves as the foundation for the projects developed under &quot;Tenants.&quot; The tenant project has a complete list of all current and upcoming translations. Now, tenants have the option of maintaining translations exactly as you gave them or changing values as necessary. You can choose to pay such expenses by letting the consumer pay with his own credit card or by subscribing to those tenant projects using your main subscription. Additional links➡️ Create a free new user account for multi tenant experience ➡️ Find out more about what a translation management system is ➡️ Find out more about localization","raw":"---\ntitle: Multi tenant architecture | locize\ndescription: What is Multi-Tenant Architecture? And how we increase the value of the client by improving our software with it.\n\ndate: 2022-10-12\ntags:\n  - software architecture\n  - cloud\n  - multi-tenancy\n  - customers\n  - data\n\nthumbnail: multi-tenant/multi-tenant-application.webp\n---\n\n![multi-tenant-application](multi-tenant-application.webp)\n\nYou're going to learn about a subject today that is more popular than ever.\n\n**We now offer our consumers this unique functionality. Without the client having to pay more, this will contribute to raising the value of our localization software.**\n\nLet's start by reviewing basic definitional information concerning multi-tenant as well as the benefits of such an architecture.\n\n## Definition: Multi tenant\n\nA software that is multi-tenant may serve several customers with a single application instance. A single instance of a software program (and its underlying database and technology) supports several tenants in multi-tenant software architecture, also known as software multi-tenancy (or user accounts).\n\nEach tenant can customize the program by changing some basic parameters. This might involve the look and feel of the user interface, user administration, or adding custom code to the program.\n\nIn this situation, instead of a dedicated server, the space for each tenant or client is shared. The multi-tenant nature of SaaS systems necessitates a greater emphasis on ensuring that all efforts are taken to isolate tenant resources.\n\nThere are three main types of multi tenant architecture:\n\n#### 1) Shared database\nA multi-tenancy architecture with a multi-tenant database is a single, shared database structure. Because shared resources are used, this is the simplest of the three kinds and has a relatively low cost to tenants.\nTo host tenants and store data, this design employs a single application and database instance. Using a single, common database schema provides for faster scaling, but can result in greater total running expenses.\n\n#### 2) Single database with several schemas\nA single database with several schemas is another approach to multi-tenancy. This approach has a single application instance and separate databases for each tenant. Because of this design, each individual database incurs more expenses and requires more administrative effort. It is useful when data from various clients must be processed differently, such as when they are located in different countries with different legislation.\n\n#### 3) Several databases\nData is stored in numerous databases in the third type of multi-tenant architecture. This approach is very difficult in terms of administration and maintenance, however renters may be distinguished from one another using a predefined criterion.\n\n![source: diegosucaria.info](multi-tenant-architecture.webp)\n\n\n\n### The advantages of multi tenant applications\nThe huge advantage for shared resources is that it will make the entry cost very low and the scalability easier and faster. These are the main other advantages of multi-tenant architecture:\n\n- <b>Lower costs:</b> When compare to other hosting architectures, it’s costs less than a single infrastructure is used for multiple tenants\n- <b>No maintenance at all:</b> Always up-to-date code as the host is taking care of maintenance. New features are implemented without the customer's involvement and just once.\n- <b>Highly scalable:</b> The architecture is easily scalable on demand, new users access to the same instance\n- <b>Easy customization:</b> It’s highly flexible, allowing each tenant client to modify the application to their individual business needs without incurring the expense, time, and risk of having an own development.\n- <b>High productivity:</b> There is an improvement in productivity for the tenant because there is no need to manage the infrastructure.\n\n### Multi-tenant vs. single-tenant\nThe main difference is the access to source-code. In single-tenant architectures, a tenant will have a singular instance of an application dedicated to them. \nThe key distinction is the availability of source code. A tenant in a single-tenant architecture will have a single instance of an application devoted to them.\n\n\n#### Example\nAssume that each client has a separate residence that is completely cut off from any nearby structures. In a multi-tenant cloud architecture, tenants reside in several apartments inside the same structure. \n\nThe same security system and communal utilities link them all. However, each tenant's privacy is protected within their apartment since they each have a key. But it's more probable that their neighbors' behavior will affect how comfortable they are in the flat.\n\n<br /><br />\n\n### How locize introduce multi-tenant in translation management\n\nFor locize the multi-tenant approach is less of the classical infrastrucutre topic, but it still makes perfect sense for the translation management system since it functions as a fully independent application/project that is integrated into your own application or website.\n\nThis means that our customers (you) can in turn integrate the own customers or other projects into the account without opening another account.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\">Uniqueness</h3>\n<p style=\"color:grey;\">The concept of multi-tenancy is absolutely new and exclusive to the localization industry. Use the most up to date software for this purpose, <a style=\"color:orange\" href=\"https://www.locize.app/register\" title=\"locize\">locize</a></p>\n</div>\n\n\nWith the multi-tentant function to happen:\n\n- With limited access, you can assign your own clients a dedicated project without spending money on new infrastructure.\n- Advanced user management enhances workflow flexibility in general.\n- The localization software will increase in scale from its current level.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<h3 style=\"color:orange;\">Testimonials</h3>\n<p style=\"color:grey;\">Check out our <a href=\"/customers.html\" title=\"customer success stories\">customer success stories</a> for more examples of who is using our service.</p>\n</div>\n\n\n➡️ <b>Read more:</b> <a style=\"color:orange\" href=\"https://docs.locize.com/more/multi-tenant\" title=\"multi tenant docs\">Here you will find the instructions</a> how to add a multi-tenant project for locize.\n\n![locize-multi-tenant](locize-multi-tenant.webp)\n\nYour primary project's material serves as the foundation for the projects developed under \"Tenants.\"\n\nThe tenant project has a complete list of all current and upcoming translations.\n\nNow, tenants have the option of maintaining translations exactly as you gave them or changing values as necessary.\n\nYou can choose to pay such expenses by letting the consumer pay with his own credit card or by subscribing to those tenant projects using your main subscription.\n\n\n### Additional links\n\n➡️ Create a free new [user account](https://www.locize.app/register) for multi tenant experience\n\n➡️ Find out more about [what a translation management system is](/blog/tms/)\n\n➡️ Find out more about [localization](../localization/)","categories":[],"tags":[{"name":"software architecture","slug":"software-architecture","permalink":"https://locize.com/blog/tags/software-architecture/"},{"name":"cloud","slug":"cloud","permalink":"https://locize.com/blog/tags/cloud/"},{"name":"multi-tenancy","slug":"multi-tenancy","permalink":"https://locize.com/blog/tags/multi-tenancy/"},{"name":"customers","slug":"customers","permalink":"https://locize.com/blog/tags/customers/"},{"name":"data","slug":"data","permalink":"https://locize.com/blog/tags/data/"}]},{"title":"What is a Translation Management System (2023)","slug":"tms","date":"un44fin44","updated":"un00fin00","comments":true,"path":"tms/","link":"","permalink":"https://locize.com/blog/tms/","excerpt":"","text":"The translation management system (TMS) is a software to simplify the human translation process. In order to handle translations and make things simpler for the translator, the program automates non-essential activities and offers useful features. This lowers the amount of resources required and makes the translation process more effective. The TMS includes several capabilities to localize material for various markets and enable users to interact with contextualized content, thus it is not simply for translating text. Table of contents What functions does it require? Benefits of using a TMS What to consider while comparing various software solutions Why choose locize as your TMS What functions does it require? A TMS is made for the purpose of centrally managing translation and localization tasks. Let&#39;s examine the six main functions that a translation management platform should have: Managing translation workflows Managing terminology Use translation memory Get the history and numbers Auto machine translation Integration API Managing translation workflowsThe TMS reduce the amount of manual effort performed during each of the steps. Otherwise, it could be difficult for your managers, translators, and reviewers to coordinate and promptly execute crucial project specifics, which frequently results in a longer time to market. Define what to translate Sending files to translators During translation Receiving files from translators Maybe review the files The TMS reduce the amount of manual effort performed during each of the steps. Otherwise, it could be difficult for your managers, translators, and reviewers to coordinate and promptly execute crucial project specifics, which frequently results in a longer time to market. A good TMS will trigger a review procedure each time a translation is modified. Until one of the translation suggestions is accepted, the actual value won't change. Managing terminologyTerminology is the fundamental cornerstone of all translations. To describe objects and form sentences, people use words, phrases, and jargon. If your content generation has to be extended, certain criteria for managing material must be established for all parties involved. You should keep track of terms that should or shouldn&#39;t be translated via a glossary. It exists to facilitate the use of the language that your business likes by human translators. Use the translation memoryA TMS&#39;s translation memory feature is especially crucial since it greatly boosts the productivity of language localization language localization. You can utilize words and phrases from previous work rather than coming up with new language every time. To assist human translators, sentences that have already been translated are stored in a database called a translation memory (TM). Get the history and numbersEvery project management tool must provide the most crucial indicators about budget, progress, and other factors. The majority of the tasks are contained in one program by the TMS. As a result, reporting the numbers is a must. The data insights from the TMS help improve the administration of your localization projects. Additionally, keeping track of all previous translations might be helpful. In the event of an inconvenience, it is possible to demonstrate at any moment who made what changes and when. Locize, our translation management system, offers an overview of the control center with the key figures for the ongoing project: The control center of our localization software displays all pertinent high-level data: user management billing (customer details, billing history, budget limit, ...) project settings (slack integration, webhook, integration metrics, ...) ordering (services, pending orders) branches project health and metrics Auto Machine TranslationWith this capability, the TMS attempts to entirely automate the translation process. Traditionally, an application program interface (API) is used to connect translated texts to an engine that handles the translation automatically. Because the results from artificial intelligence are typically not 100% fine, a translator is frequently needed to evaluate the auto translation output. For locize, the entire automatic machine translation process occurs in the backend, which means you&#39;ll see the translated result after saving the new keys in reference language. Should you choose machine translation, a translation agency or a freelancer?These are three options when there is a need of translating content. Whether to engage a translation agency, a freelancer, or make use of machine translation. Machine translation would be the most cost-effective approach because it is virtually free. However, if no one reviews the translated information, there will undoubtedly be a lack of quality. Freelance translators are frequently enthusiastic about their work. They are frequently subject specialists who can execute sophisticated translations in their fields. This might be a wonderful alternative for those on a restricted budget. Working with a person rather than a firm is less expensive, and you don&#39;t have to sacrifice quality. Translation agencies have greater resources to devote to your job than a freelancer. In addition, they offer a wide range of translation and localization services. They have extensive expertise in assisting you to overcome linguistic and cultural difficulties. You will discover your ideal match for sure. Integration APIAPI technology is used by excellent TMS to connect to and interact with cloud-based services. This enables it to automate and expand translation management in any content management system for all content kinds. There is thorough documentation for locize on how to utilize an API to integrate any of your applications. The documentation may be found at docs.locize.com/integration/api. Benefits of using a TMS Manual transmission and receipt of translated texts is inefficient for bigger projects and may result in unstructured chaos and significant financial loss. If regular spreadsheets are inadequate for managing the volume of material, the TMS is for you. Because a good TMS is Highly scalable Easy to integrate Easy to understand Help with professional translation Unleash localization progress Notifies whenever something significant occurs In any event, if a company need expert translation for its own brand material, it makes sense to employ a TMS to make the translation process much easier. On the surface, it appears to be a large investment, but upon closer inspection, the investment will pay for itself many times over as the process becomes much more efficient and dependable. It&#39;s also how larger businesses do it; they have content management systems (CMS) as independent but linked applications or as simple add-ons that can meet particular multilingual requirements. What to consider while comparing various software solutions When you compare different TMS software, then ask the following questions regarding your business: Who will be impacted and how quickly (stakeholders, customers, employees)? How will the TMS improve the end-user experience? How much are we willing to spend on a TMS? Which infrastructure will the developed material be hosted on? Is it possible to automate any process? Why choose locize as your TMS locize is an excellent product for several reasons: Simple interface for managing translations. It is possible to regulate exactly what each translator sees, and they like doing so. The interface also allows you to check what translations are lacking and divide your application into multiple namespaces. Additionally, locize is the key piece to localize your software project, together with i18next. locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business. ➡️ Watch our introduction video ➡️ Create a new user account for free ➡️ Check out how to add a new project","raw":"---\ntitle: What is a Translation Management System (2023)\ndescription: You want to understand and find the best translation management system. Then this article is for you, we will assist you. \n\ndate: 2022-09-15\ntags:\n  - translation project management\n  - language localization\n  - tms\n  - how to choose\n\nthumbnail: tms/tms.webp\n\nlabel: tms\nlang: en\n---\n\n![what is a translation management system](what-is-a-translation-management-system.webp)\n\n\n\nThe translation management system (TMS) is a software to simplify the human translation process. In order to handle translations and make things simpler for the translator, the program automates non-essential activities and offers useful features. \n\nThis lowers the amount of resources required and makes the translation process more effective.\n\nThe TMS includes several capabilities to localize material for various markets and enable users to interact with contextualized content, thus it is not simply for translating text.\n\n\n\n\n## Table of contents\n  * [What functions does it require?](#functions)\n  * [Benefits of using a TMS](#benefits)\n  * [What to consider while comparing various software solutions](#compare)\n  * [Why choose locize as your TMS](#locize)\n\n\n## What functions does it require? <a name=\"functions\"></a>\n\nA TMS is made for the purpose of centrally managing translation and <a href=\"/blog/localization/\" title=\" localization\">localization</a> tasks. Let's examine the six main functions that a translation management platform should have:\n\n1. Managing translation workflows\n2. Managing terminology\n3. Use translation memory\n4. Get the history and numbers\n5. Auto machine translation\n6. Integration API\n\n\n![checklist](feedback.webp)\n\n### Managing translation workflows\n\nThe TMS reduce the amount of manual effort performed during each of the steps. Otherwise, it could be difficult for your managers, translators, and reviewers to coordinate and promptly execute crucial project specifics, which frequently results in a longer time to market.\n\n1. Define what to translate\n2. Sending files to translators\n3. During translation\n4. Receiving files from translators \n5. Maybe review the files\n\nThe TMS reduce the amount of manual effort performed during each of the steps. Otherwise, it could be difficult for your managers, translators, and reviewers to coordinate and promptly execute crucial project specifics, which frequently results in a longer time to market.\n\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n<p style=\"color:grey;\">\n  A good TMS will trigger a review procedure each time a translation is modified. Until one of the translation suggestions is accepted, the actual value won't change.\n</p>\n</div>\n\n### Managing terminology\n\nTerminology is the fundamental cornerstone of all translations. To describe objects and form sentences, people use words, phrases, and jargon. \n\nIf your content generation has to be extended, certain criteria for managing material must be established for all parties involved. \n\nYou should keep track of terms that should or shouldn't be translated via a glossary. It exists to facilitate the use of the language that your business likes by human translators.\n\n### Use the translation memory\nA TMS's translation memory feature is especially crucial since it greatly boosts the productivity of language localization <a href=\"/blog/language-localization/\" title=\"language localization\">language localization</a>. \n\nYou can utilize words and phrases from previous work rather than coming up with new language every time. To assist human translators, sentences that have already been translated are stored in a database called a translation memory (TM).\n\n![database](analytics.webp)\n\n### Get the history and numbers \nEvery project management tool must provide the most crucial indicators about budget, progress, and other factors.\n\nThe majority of the tasks are contained in one program by the TMS. As a result, reporting the numbers is a must. The data insights from the TMS help improve the administration of your localization projects.\n\nAdditionally, keeping track of all previous translations might be helpful. In the event of an inconvenience, it is possible to demonstrate at any moment who made what changes and when.\n\nLocize, our translation management system, offers an overview of the control center with the key figures for the ongoing project:\n\n![control center](control-center.webp)\n\nThe control center of our <a href=\"/\" title=\"localization software\">localization software</a> displays all pertinent high-level data:\n\n- user management\n- billing (customer details, billing history, budget limit, ...)\n- project settings (slack integration, webhook, integration metrics, ...)\n- ordering (services, pending orders)\n- branches\n- project health and metrics\n\n\n### Auto Machine Translation\n\nWith this capability, the TMS attempts to entirely automate the translation process. Traditionally, an application program interface (API) is used to connect translated texts to an engine that handles the translation automatically. \n\nBecause the results from artificial intelligence are typically not 100% fine, a translator is frequently needed to evaluate the auto translation output.\n\nFor locize, the entire automatic machine translation process occurs in the backend, which means you'll see the translated result after saving the new keys in reference language.\n\n\n#### Should you choose machine translation, a translation agency or a freelancer?\nThese are three options when there is a need of translating content. Whether to engage a translation agency, a freelancer, or make use of machine translation. \n\nMachine translation would be the most cost-effective approach because it is virtually free. However, if no one reviews the translated information, there will undoubtedly be a lack of quality.\n\nFreelance translators are frequently enthusiastic about their work. They are frequently subject specialists who can execute sophisticated translations in their fields. This might be a wonderful alternative for those on a restricted budget. Working with a person rather than a firm is less expensive, and you don't have to sacrifice quality.\n\nTranslation agencies have greater resources to devote to your job than a freelancer. In addition, they offer a wide range of translation and localization services. They have extensive expertise in assisting you to overcome linguistic and cultural difficulties.\n\nYou will discover your ideal match for sure.\n\n### Integration API\n\nAPI technology is used by excellent TMS to connect to and interact with cloud-based services. This enables it to automate and expand translation management in any content management system for all content kinds.\n\nThere is thorough documentation for locize on how to utilize an API to integrate any of your applications. The documentation may be found at [docs.locize.com/integration/api](https://docs.locize.com/integration/api).\n\n\n## Benefits of using a TMS <a name=\"benefits\"></a>\n\nManual transmission and receipt of translated texts is inefficient for bigger projects and may result in unstructured chaos and significant financial loss. If regular spreadsheets are inadequate for managing the volume of material, the TMS is for you.\n\nBecause a good TMS is \n\n- Highly scalable\n- Easy to integrate\n- Easy to understand\n- Help with professional translation\n- Unleash localization progress\n- Notifies whenever something significant occurs\n\nIn any event, if a company need expert translation for its own brand material, it makes sense to employ a TMS to make the translation process much easier. \n\nOn the surface, it appears to be a large investment, but upon closer inspection, the investment will pay for itself many times over as the process becomes much more efficient and dependable.\n\nIt's also how larger businesses do it; they have content management systems (CMS) as independent but linked applications or as simple add-ons that can meet particular multilingual requirements.\n\n\n## What to consider while comparing various software solutions <a name=\"compare\"></a>\n\nWhen you compare different TMS software, then ask the following questions regarding your business:\n\n- Who will be impacted and how quickly (stakeholders, customers, employees)?\n- How will the TMS improve the end-user experience?\n- How much are we willing to spend on a TMS?\n- Which infrastructure will the developed material be hosted on?\n- Is it possible to automate any process?\n\n\n## Why choose locize as your TMS <a name=\"locize\"></a>\n\nlocize is an excellent product for several reasons: Simple interface for managing translations. It is possible to regulate exactly what each translator sees, and they like doing so. The interface also allows you to check what translations are lacking and divide your application into multiple namespaces.\n<br />\nAdditionally, locize is the [key piece](../i18n-l10n-t9n-tms/) to localize your software project, together with [i18next](https://www.i18next.com).\n\nlocize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n\n\n➡️ [Watch our introduction video](https://docs.locize.com)\n\n➡️ [Create a new user account for free](https://www.locize.app/register)\n\n➡️ [Check out how to add a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n\n{% youtube YQryHo1iHb8 %}","categories":[],"tags":[{"name":"tms","slug":"tms","permalink":"https://locize.com/blog/tags/tms/"},{"name":"how to choose","slug":"how-to-choose","permalink":"https://locize.com/blog/tags/how-to-choose/"},{"name":"translation project management","slug":"translation-project-management","permalink":"https://locize.com/blog/tags/translation-project-management/"},{"name":"language localization","slug":"language-localization","permalink":"https://locize.com/blog/tags/language-localization/"}]},{"title":"Smart help for tech leaders and engineering managers","slug":"help-tech-leads","date":"un22fin22","updated":"un11fin11","comments":true,"path":"help-tech-leads/","link":"","permalink":"https://locize.com/blog/help-tech-leads/","excerpt":"","text":"Tech leaders and engineering managers have probably one of the most schizophrenic and ambitious role. If you are in such a position, you may know why... Let&#39;s start by telling what some tasks and responsibilities this roles entail. What is a tech team leader / engineering manager doing? If there was just one word to describe it, I would call them &quot;foreman&quot;. Because they basically set the direction for the team and making sure everyone understands and follows major technical and non-technical decisions. This may sound simple, but it isn&#39;t. On your engineering team you need to establish psychological safety, with mentoring your team members by inspiring and guiding them. You need to take ownership of your decisions. The motivation of the team members needs always to be fed also by providing an environment that encourages (personal) development. This may basically create a strong team culture. Manage and resolve difficult conversations with the team members, by setting clear goals and expectations. This will give your team more clarity. Also hiring the right talent is crucial. And since remote working / home office is becoming more and more common, you also need to handle knowledge transfer and promote efficient coding with distributed workforces. One of the imortant virtues is your and your team&#39;s adaptability. Balancing speed and quality and maintaining productivity and velocity. At the same time improving the team performance by defining it and aligning it to the business. Oh yes, the business... Such a person needs to become an expert not only in communicating with its technical team, but also with the nontechnical business stakeholders. For sure resolving customer issues is also important. The delicate balancing what engineers like to do versus what needs to be done. Somehow manage the too often existing mentality that one group works on &quot;the business&quot; and the other works on the &quot;code&quot; or the &quot;release&quot;, by trying to &quot;connect&quot; the work that the engineers do to the business. How may a tech team leader / engineering manager feel? Often feeling disconnected from the actual coding work. They no longer have peers who can trade-notes with, problem-solve, and empathize with... feeling alone. In the eyes of your team they’re &quot;the business&quot; and in the eyes of the executives &quot;those coders&quot;. Directly in the middle of the tension between the business sides and the technical side of the company. Some situations Your team is insisting that something needs to be refactored first – long overdue tech debt that is piling up and your superior is on you to ship something by an unreasonable date. The financial department is saying the headcount is limited, and promoting your overperforming engineer is no longer possible, because not in the budget anymore. The head of business management obligates you to finish a feature that just doesn’t work. The sales manager is indirectly expressing negative feelings by questioning why your team is working on a specific feature and not what they heard about from sales news. The program manager is asking you for a list of every engineer working on a specific project. The localization manager is telling you, your team should have submitted the source language texts 3 month ago. And you try to explain that 3 month ago, the complete feature was not required and not specified at all. And your team is soberingly trying to convince you that they can&#39;t do a feature freeze since they&#39;re developing with the agile methodology. So you&#39;re trying to manage also the tension between the development team and translation team. ... Do you start to recognize what I mean? And to put the cherry on top, you can&#39;t go to the head of sales to say the program manager is on your case and that your team is refusing to develop a feature. You can&#39;t tell the customer, the next release will come with unverified texts and no translations, because the localization team and product development team work with different process methodologies. Tech team leaders / engineering managers are alone! Is there something that we could do to help? While this may seem a bit of a caricature of the challenges of the competitive engineering lead roles, I&#39;m sure that certain situations are familiar to you in one form or another. Of course, I don&#39;t have an all-encompassing solution to improve this, but I do have a specific suggestion for resolving a particular center of tension. Imagine this: The developers work as usual on their features and create strings on-the-fly. Those new texts get&#39;s automatically pushed as missing strings to the translation management system (TMS). The translators work on new translations and can instantaneously validate the translations. Since translations are &quot;connected&quot; directly to your software product, they can be released at any time. This way you can also fix translations of your previously released product, without having to redeploy it. If you do so, you have to make sure you can have more than one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this, it is even possible to change or add translations without shipping a new release of your software! You may also want to have some reviewing workflow, a history, integrated ordering of external translations, context information, etc... Cool this will for sure calm down some tensions, but isn&#39;t this a little over the top... an extra tooling and deployment — does not all this just add more complexity and effort? You don’t have to build this yourself!!! — There is locize!locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business. By using locize, tech team leader / engineering manager enables collaboration to bridge the gap between localization and development. This makes you faster, more efficient and saves you money overall. Just start with the free trial. There&#39;s no harm... Try everything, set up your locize project, compare it with your existing process and validate it with your team members. Watch the demo video to learn more about it: btw: If you&#39;re already using the open source internationalization (i18n) framework i18next, then you are already using locize&#39;s best partner. Because locize was created by the maintainers of i18next. Integrating i18next with locize is even easier.","raw":"---\ntitle: Smart help for tech leaders and engineering managers\ndescription: This article will help the work of tech/team leaders and engineering managers with a smart advice for the localization topic.\n\ndate: 2022-09-06\ntags:\n  - localization\n  - international strategy\n  - global localization\n  - internationalization\n  - tech lead\n  - engineering manager\nthumbnail: help-tech-leads/title.jpg\n\nlabel: help-tech-leads\nlang: en\n---\n\n![](title.jpg)\n\nTech leaders and engineering managers have probably one of the most schizophrenic and ambitious role.\n\nIf you are in such a position, you may know why...\n<br />\nLet's start by telling what some tasks and responsibilities this roles entail.\n\n## What is a tech team leader / engineering manager doing?\n\n![](foreman.jpg)\n\nIf there was just one word to describe it, I would call them **\"foreman\"**.\nBecause they basically set the direction for the team and making sure everyone understands and follows major technical and non-technical decisions.\n<br />\nThis may sound simple, but it isn't.\n\nOn your engineering team you need to establish psychological safety, with mentoring your team members by inspiring and guiding them.\nYou need to take ownership of your decisions.\n<br />\nThe motivation of the team members needs always to be fed also by providing an environment that encourages (personal) development. This may basically create a strong team culture.\n<br />\nManage and resolve difficult conversations with the team members, by setting clear goals and expectations. This will give your team more clarity. Also hiring the right talent is crucial.\n<br />\nAnd since remote working / home office is becoming more and more common, you also need to handle knowledge transfer and promote efficient coding with distributed workforces.\n<br />\nOne of the imortant virtues is your and your team's adaptability.\nBalancing speed and quality and maintaining productivity and velocity.\nAt the same time improving the team performance by defining it and aligning it to the business.\n<br />\nOh yes, the business... \nSuch a person needs to become an expert not only in communicating with its technical team, but also with the nontechnical business stakeholders.\n<br />\nFor sure resolving customer issues is also important.\nThe delicate balancing what engineers like to do versus what needs to be done.\n<br />\nSomehow manage the too often existing mentality that one group works on \"the business\" and the other works on the \"code\" or the \"release\", by trying to \"connect\" the work that the engineers do to the business.\n\n\n## How may a tech team leader / engineering manager feel?\n\n![](alone.jpg)\n\nOften feeling disconnected from the actual coding work.\n<br />\nThey no longer have peers who can trade-notes with, problem-solve, and empathize with... feeling alone.\n<br />\nIn the eyes of your team they’re \"the business\" and in the eyes of the executives \"those coders\".\n<br />\nDirectly in the middle of the tension between the business sides and the technical side of the company.\n\n\n## Some situations <a name=\"situations\"></a>\n\n![](discuss.png)\n\nYour team is insisting that something needs to be refactored first – long overdue tech debt that is piling up and your superior is on you to ship something by an unreasonable date.\n\nThe financial department is saying the headcount is limited, and promoting your overperforming engineer is no longer possible, because not in the budget anymore.\n\nThe head of business management obligates you to finish a feature that just doesn’t work.\n\nThe sales manager is indirectly expressing negative feelings by questioning why your team is working on a specific feature and not what they heard about from sales news.\n\nThe program manager is asking you for a list of every engineer working on a specific project.\n\nThe localization manager is telling you, your team should have submitted the source language texts 3 month ago. And you try to explain that 3 month ago, the complete feature was not required and not specified at all.\n<br />\nAnd your team is soberingly trying to convince you that they can't do a feature freeze since they're developing with the agile methodology.\n<br />\nSo you're trying to manage also the tension between the development team and translation team.\n\n...\n\n>Do you start to recognize what I mean?\n\nAnd to put the cherry on top, you can't go to the head of sales to say the program manager is on your case and that your team is refusing to develop a feature.\n<br />\nYou can't tell the customer, the next release will come with unverified texts and no translations, because the localization team and product development team work with different process methodologies.\n\n>Tech team leaders / engineering managers are alone!\n\n\n## Is there something that we could do to help?\n\n![](solution.jpg)\n\nWhile this may seem a bit of a caricature of the challenges of the competitive engineering lead roles, I'm sure that certain situations are familiar to you in one form or another.\n\nOf course, I don't have an all-encompassing solution to improve this, but I do have a specific suggestion for resolving a particular center of tension.\n\nImagine this:\n\n1. The developers work as usual on their features and create strings on-the-fly. Those new texts get's automatically pushed as missing strings to the [translation management system (TMS)](../i18n-l10n-t9n-tms/#tms).\n2. The translators work on new translations and can instantaneously validate the translations.\n3. Since translations are \"connected\" directly to your software product, they can be released at any time. This way you can also fix translations of your previously released product, without having to redeploy it.\n\nIf you do so, you have to make sure you can have more than one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this, it is even possible to change or add translations without shipping a new release of your software!\nYou may also want to have some reviewing workflow, a history, integrated ordering of external translations, context information, etc...\n\n>Cool this will for sure calm down some tensions, but isn't this a little over the top... an extra tooling and deployment — does not all this just add more complexity and effort?\n\n#### You don’t have to build this yourself!!! — There is [locize](https://locize.com)!\n\n[locize](https://locize.com) removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n\nBy using [locize](https://locize.com), tech team leader / engineering manager enables collaboration to bridge the gap between localization and development. This makes you faster, more efficient and saves you money overall. Just start with the free trial. There's no harm... Try everything, set up your locize project, compare it with your existing process and validate it with [your team members](/for-your-team.html).\n\nWatch the [demo video](https://youtu.be/ds-yEEYP1Ks) to learn more about it:\n{% youtube ds-yEEYP1Ks %}\n\n*btw: If you're already using the open source internationalization (i18n) framework [i18next](https://www.i18next.com), then you are already using locize's best partner. Because locize was created by the maintainers of i18next. [Integrating i18next with locize is even easier.](/i18next.html#already-using-i18next)*\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"},{"name":"tech lead","slug":"tech-lead","permalink":"https://locize.com/blog/tags/tech-lead/"},{"name":"engineering manager","slug":"engineering-manager","permalink":"https://locize.com/blog/tags/engineering-manager/"}]},{"title":"Language localization - Everything you need to know","slug":"language-localization","date":"un33fin33","updated":"un55fin55","comments":true,"path":"language-localization/","link":"","permalink":"https://locize.com/blog/language-localization/","excerpt":"","text":"We live in a truly connected world. Technology is allowing organizations to work and operate with other businesses and consumers across the globe with ease. However, while this ability to engage with an audience anywhere in the world is allowing companies to expand and grow, it is also placing significant importance on language and the importance of effective translation. Language localization is an essential requirement for any business operating globally, helping them to connect and build stronger relationships with their clients. What is language localization, though, and how can it help you? We thought we would explore the process further. What is language localization?Many people believe that language localization and translation are interchangeable terms; however, they are two very different things. Localization is the strategy of adapting your brand’s services or products so that they are targeting the audience in a specific geographical region or international market. For example, while English might be spoken by one in four people across the globe, there are very distinctive differences between British and American English. Understanding these nuances is essential in building a strong relationship with your customers. Equally, perhaps you are looking to transfer your Spanish-language video game to a wider audience in another language. While translating the voiceovers is essential, there are also various cultural references and idioms that will need to be adapted. Why is language localization important?For any business or organization looking to work globally, language localization is essential in helping them to break into new markets. In the highly competitive world that we live in, it is vital that you are able to effectively communicate with your target audience in terms of language and cultural norms. Language localization will help to ensure that your brand feels completely natural to your audience. When consumers feel like they are working with a brand that understands them and is talking to them directly, they are far more likely to engage with them and utilize their services. In turn, this will help you to increase your reach and boost your sales. Of course, it is not only about increasing your reach. When customers are able to identify with your brand more closely, then you are more likely to generate much greater goodwill. It also helps you to create a stronger customer experience, ensuring you are reaching all of the required touchpoints that leave them feeling confident in your brand. What languages are most popular for localization? Thankfully, when it comes to language localization, you do need to translate your content into one of the over 7,150 languages that are currently used in the world today. Instead, you just need to ensure that you are transposing your website, brochures, and content into the language of your destination. Over half of the world’s population currently speaks one of 23 languages, and some of the most popular and widely used of these include: English (spoken by 16.5% of the world) Mandarin Chinese (12.3% of the world) Hindi (8.3% of the world) Spanish (7% of the world) French (3.6% of the world) Examples of language localizationLanguage localization is an all-encompassing term, and businesses will need to review everything from their website and marketing materials to contracts and manuals. There are a lot of things to consider when conducting localization, but some of the most important include: Spelling Spelling is one of the most important factors when it comes to localization, particularly when translating between British and American English. For example, the former uses ‘ise’ whereas the latter uses ‘ize’. Cultural references Cultural nuances and phrases are another important consideration. For example, in English, the phrase “put the cart before the horse” is a common quote; however, in France, they use the term Bulls instead of a horse. Visuals and colors Localization is much more than just the text. You will also need to ensure that your text is visually laid out correctly for your target audience (do they read left-to-right or right-to-left?), and you will also need to ensure you are using the right colors and themes that they will relate to. Grammar High-quality language localization should also factor in the grammatical rules of your chosen language. One small mistake in your written text can be the difference between your project being a success or a failure, so comprehensive proofreading is essential. Tone Another major factor to consider when undertaking language localization is the tone of the content. Different cultures and countries will have different expectations of the tone your documents should come in. That is why you need to ensure that you are using the correct dialect and nuances of your target audience. Translation vs. language localizationWhile translation and localization follow similar practices, there are distinct differences between the two. Translation involves simply transposing content from its original language into your chosen language. While this can be effective in helping readers understand the original context of the document or file, certain phrases and terms will not translate with the same meaning. For quick communication, this might not be such a problem. However, for professional documents such as contracts, manuals, research papers, and more, this could result in a major miscommunication. Localization, on the other hand, covers everything from meaning and grammar to the cultural, ethical, and societal guidelines of the destination language. This ensures that readers are able to get the exact same meaning from the content, no matter the language that they are reading it in. This often requires the work of a specialist who will be able to tailor and adjust the wording and structure accordingly so that it meets the expectations of the local audience. ConclusionFor any business looking to branch out into new countries or markets, then language localization is an essential requirement. In order to stand out above your competitors and showcase everything that makes your brand special to consumers, you need to ensure that you are communicating with them in their own language. This goes much further than simply translating your existing content into the new destination language and requires a comprehensive understanding of the minor nuances of your new market. This is where it is essential that you are working with a professional localization software that will not only be able to accurately transform your content but also stay up to date with the latest cultural trends to ensure you are always engaging with your audience correctly. In our ecosystem you will find all the services needed to accurately translate your website, documents, and content into the correct language, as well as ensure that the structure, flow, and meaning remain the same. So if you are planning on growing your business, speak to us today. Making a comprehensive localization strategy for your business, along with a step-by-step plan and KPIs to achieve, can be helpful for you. Start right now with our guide on localization strategy, we help you to start your way in localize your business.","raw":"---\ntitle: Language localization - Everything you need to know \ndescription: Understand the procedure for translating the product into the language appropriate for the specific geographic market.\n\ndate: 2022-08-24\ntags: \n  - examples\n  - internationalization\n  - globalisation\n  - process\nthumbnail: language-localization/language-localization.webp\n\nlabel: language-localization\nlang: en\n---\n\n\n![language localization](language-localization.webp)\n\nWe live in a truly connected world. Technology is allowing organizations to work and operate with other businesses and consumers across the globe with ease. However, while this ability to engage with an audience anywhere in the world is allowing companies to expand and grow, it is also placing significant importance on language and the importance of effective translation. \n\nLanguage localization is an essential requirement for any business operating globally, helping them to connect and build stronger relationships with their clients. What is language localization, though, and how can it help you? We thought we would explore the process further.\n\n\n## What is language localization?\nMany people believe that language localization and translation are interchangeable terms; however, they are two very different things. <a href=\"../localization/\" title=\"Localization\">Localization</a> is the strategy of adapting your brand’s services or products so that they are targeting the audience in a specific geographical region or international market. \n\nFor example, while English might be spoken by one in four people across the globe, there are very distinctive differences between British and American English. Understanding these nuances is essential in building a strong relationship with your customers. Equally, perhaps you are looking to transfer your Spanish-language video game to a wider audience in another language. While translating the voiceovers is essential, there are also various cultural references and idioms that will need to be adapted. \n\n## Why is language localization important?\nFor any business or organization looking to work globally, language localization is essential in helping them to break into new markets. In the highly competitive world that we live in, it is vital that you are able to effectively communicate with your target audience in terms of language and cultural norms. \n  \nLanguage localization will help to ensure that your brand feels completely natural to your audience. When consumers feel like they are working with a brand that understands them and is talking to them directly, they are far more likely to engage with them and utilize their services. In turn, this will help you to increase your reach and boost your sales.\n\nOf course, it is not only about increasing your reach. When customers are able to identify with your brand more closely, then you are more likely to generate much greater goodwill. It also helps you to create a stronger customer experience, ensuring you are reaching all of the required touchpoints that leave them feeling confident in your brand. \n\n## What languages are most popular for localization?\n Thankfully, when it comes to language localization, you do need to translate your content into one of the over 7,150 languages that are currently used in the world today. Instead, you just need to ensure that you are transposing your website, brochures, and content into the language of your destination. \n\nOver half of the world’s population currently speaks one of 23 languages, and some of the most popular and widely used of these include:\n- English (spoken by 16.5% of the world)\n- Mandarin Chinese (12.3% of the world)\n- Hindi (8.3% of the world)\n- Spanish (7% of the world)\n- French (3.6% of the world)\n\n![languages](languages.webp)\n\n## Examples of language localization\nLanguage localization is an all-encompassing term, and businesses will need to review everything from their website and marketing materials to contracts and manuals. There are a lot of things to consider when conducting localization, but some of the most important include:\n\nSpelling \nSpelling is one of the most important factors when it comes to localization, particularly when translating between British and American English. For example, the former uses ‘ise’ whereas the latter uses ‘ize’. \n\nCultural references \nCultural nuances and phrases are another important consideration. For example, in English, the phrase “put the cart before the horse” is a common quote; however, in France, they use the term Bulls instead of a horse.\n\nVisuals and colors \nLocalization is much more than just the text. You will also need to ensure that your text is visually laid out correctly for your target audience (do they read left-to-right or right-to-left?), and you will also need to ensure you are using the right colors and themes that they will relate to. \n\nGrammar\nHigh-quality language localization should also factor in the grammatical rules of your chosen language. \nOne small mistake in your written text can be the difference between your project being a success or a failure, so comprehensive proofreading is essential. \n\nTone \nAnother major factor to consider when undertaking language localization is the tone of the content. Different cultures and countries will have different expectations of the tone your documents should come in. That is why you need to ensure that you are using the correct dialect and nuances of your target audience. \n\n## Translation vs. language localization\nWhile translation and localization follow similar practices, there are distinct differences between the two. Translation involves simply transposing content from its original language into your chosen language. While this can be effective in helping readers understand the original context of the document or file, certain phrases and terms will not translate with the same meaning. \n\nFor quick communication, this might not be such a problem. However, for professional documents such as contracts, manuals, research papers, and more, this could result in a major miscommunication. Localization, on the other hand, covers everything from meaning and grammar to the cultural, ethical, and societal guidelines of the destination language. \n\nThis ensures that readers are able to get the exact same meaning from the content, no matter the language that they are reading it in. This often requires the work of a specialist who will be able to tailor and adjust the wording and structure accordingly so that it meets the expectations of the local audience. \n\n## Conclusion \nFor any business looking to branch out into new countries or markets, then language localization is an essential requirement. In order to stand out above your competitors and showcase everything that makes your brand special to consumers, you need to ensure that you are communicating with them in their own language. \n\nThis goes much further than simply translating your existing content into the new destination language and requires a comprehensive understanding of the minor nuances of your new market. This is where it is essential that you are working with a professional <a href=\"https://locize.com\" title=\"localization software\">localization software</a> that will not only be able to accurately transform your content but also stay up to date with the latest cultural trends to ensure you are always engaging with your audience correctly. \n\nIn our ecosystem you will find all the services needed to accurately translate your website, documents, and content into the correct language, as well as ensure that the structure, flow, and meaning remain the same. So if you are planning on growing your business, speak to us today. \n\nMaking a comprehensive localization strategy for your business, along with a step-by-step plan and KPIs to achieve, can be helpful for you. Start right now with our guide on <a href=\"https://locize.com\" title=\"localization strategy\">localization strategy</a>, we help you to start your way in localize your business.\n\n{% youtube PtFEPtsmp-Y %}\n\n\n\n\n\n\n\n","categories":[],"tags":[{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"examples","slug":"examples","permalink":"https://locize.com/blog/tags/examples/"},{"name":"globalisation","slug":"globalisation","permalink":"https://locize.com/blog/tags/globalisation/"},{"name":"process","slug":"process","permalink":"https://locize.com/blog/tags/process/"}]},{"title":"Best internationalization for Gatsby (an i18next based guide)","slug":"gatsby-i18n","date":"un22fin22","updated":"un33fin33","comments":true,"path":"gatsby-i18n/","link":"","permalink":"https://locize.com/blog/gatsby-i18n/","excerpt":"","text":"You know Gatsby, right? - If not, stop reading this article and make something else. Yes, Gatsby an open-source framework that combines functionality from React, GraphQL and Webpack into a single tool for building static websites and apps. But what does internationalization (i18n) look like in Gatsby? There are some plugins/libraries that may help instrumenting the Gatsby code for internationalization. In this article we will use a plugin based on the famous i18n framework i18next, respectively its great extension for React.js - react-i18next. The Gatsby plugin we&#39;re using is gatsby-plugin-react-i18next created by Dmitriy Nevzorov. TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher Internationalized links Interpolation and Pluralization Formatting Context Key extraction For sure! How does this look like? 👀 but there&#39;s more... (InContext Editor) 🎉🥳 Congratulations 🎊🎁 So first of all: &quot;Why i18next?&quot; When it comes to React localization, one of the most popular i18n framework is i18next with its react extension react-i18next, and for good reasons: i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it... Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript, React.js and basic Gatsby, before jumping to gatsby-plugin-react-i18next. This Gatsby localization example is not intended to be a Gatsby or React beginner tutorial. Getting started Take your own Gatsby project or create a new one, i.e. with the gatsby-cli. npx gatsby-cli new We will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: gatsby-plugin-react-i18next i18next react-i18next npm install gatsby-plugin-react-i18next i18next react-i18next Create a locales directory and add a subfolder for your default/reference language (i.e. en for English). There we will then add our namespace files, like: 123|-- en |-- common.json |-- index.json Let&#39;s add a languages.js file: 12345678910111213141516171819const &#123; join &#125; = require(&#x27;path&#x27;)const &#123; readdirSync, lstatSync &#125; = require(&#x27;fs&#x27;)const defaultLanguage = &#x27;en&#x27;;// based on the directories get the language codesconst languages = readdirSync(join(__dirname, &#x27;locales&#x27;)).filter((fileName) =&gt; &#123; const joinedPath = join(join(__dirname, &#x27;locales&#x27;), fileName) const isDirectory = lstatSync(joinedPath).isDirectory() return isDirectory&#125;);// defaultLanguage as firstlanguages.splice(languages.indexOf(defaultLanguage), 1);languages.unshift(defaultLanguage);module.exports = &#123; languages, defaultLanguage,&#125;; Import the languages.js file in the gatsby-config.js file and configure some plugins: 1234567891011121314151617181920212223242526272829303132const &#123; languages, defaultLanguage &#125; = require(&#x27;./languages&#x27;);// somewhere in your plugins add:module.exports = &#123; // ... plugins: [ &#123; resolve: `gatsby-source-filesystem`, options: &#123; path: `$&#123;__dirname&#125;/locales`, name: `locale` &#125; &#125;, &#123; resolve: &#x27;gatsby-plugin-react-i18next&#x27;, options: &#123; languages, defaultLanguage, siteUrl, i18nextOptions: &#123; // debug: true, fallbackLng: defaultLanguage, supportedLngs: languages, defaultNS: &#x27;common&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125; &#125;, &#125;, &#125;, // ... ]&#125; Now let&#39;s start to instrument our first internationalized text. Since gatsby-plugin-react-i18next is exporting all methods and components of react-i18next, we can do this: In a page file: 1234567891011121314151617181920212223242526272829303132333435import &#123; Trans, useTranslation &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;import &#123; graphql &#125; from &#x27;gatsby&#x27;;import React from &#x27;react&#x27;;// ...const IndexPage = () =&gt; &#123; const &#123; t &#125; = useTranslation(); return ( &lt;Layout&gt; &lt;Seo title=&#123;t(&#x27;seo&#x27;)&#125; /&gt; &lt;h1&gt; &lt;Trans i18nKey=&quot;title&quot;&gt;Hi people&lt;/Trans&gt; &lt;/h1&gt; &#123; /* ... */&#125; &lt;/Layout&gt; )&#125;export default IndexPage;export const query = graphql` query ($language: String!) &#123; locales: allLocale( filter: &#123; ns: &#123; in: [&quot;index&quot;] &#125;, language: &#123; eq: $language &#125; &#125; ) &#123; edges &#123; node &#123; ns data language &#125; &#125; &#125; &#125;`; Now also define an locales/en/index.json namespace file, like this: 1234&#123; &quot;seo&quot;: &quot;Home&quot;, &quot;title&quot;: &quot;Hi people&quot;&#125; And maybe also another one for German? locales/de/index.json: 1234&#123; &quot;seo&quot;: &quot;Startseite&quot;, &quot;title&quot;: &quot;Hallo Leute&quot;&#125; Language Switcher To be able to switch between different languages, we need a language switcher: 12345678910111213141516171819202122import &#123; Link, useI18next &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;import React from &#x27;react&#x27;;const Header = (&#123; siteTitle &#125;) =&gt; &#123; const &#123; languages, originalPath, t, i18n &#125; = useI18next(); return ( &lt;header className=&quot;main-header&quot;&gt; &#123;/* ... */&#125; &lt;ul className=&quot;languages&quot;&gt; &#123;languages.map((lng) =&gt; ( &lt;li key=&#123;lng&#125;&gt; &lt;Link to=&#123;originalPath&#125; language=&#123;lng&#125; style=&#123;&#123; textDecoration: i18n.resolvedLanguage === lng ? &#x27;underline&#x27; : &#x27;none&#x27; &#125;&#125;&gt; &#123;lng&#125; &lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/header&gt; );&#125;;export default Header; You should now see something like this: By default, on the first load, gatsby-plugin-react-i18next will fallback to the defaultLanguage if the browser&#39;s detected language is not included in the array of languages. If you want to fallback to a different language in the languages array, you can set the fallbackLanguage option. Now switching to de (German) should also work: 🥳 Awesome, you&#39;ve just created your first language switcher! Internationalized links Let&#39;s create a second page... 123456789101112131415161718192021222324252627282930313233343536373839import &#123; graphql &#125; from &#x27;gatsby&#x27;;import React, &#123; useState &#125; from &#x27;react&#x27;;import Layout from &#x27;../components/layout&#x27;;import &#123; useTranslation &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;const SecondPage = (props) =&gt; &#123; const &#123; t &#125; = useTranslation(); const [count, setCounter] = useState(0); return ( &lt;Layout&gt; &lt;Seo title=&#123;t(&#x27;title&#x27;)&#125; /&gt; &lt;h1&gt; &lt;Trans i18nKey=&quot;title&quot;&gt;Page two&lt;/Trans&gt; &lt;/h1&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;welcome&quot;&gt;Welcome to page 2&lt;/Trans&gt; (&#123;props.path&#125;) &lt;/p&gt; &#123;/* ... */&#125; &lt;/Layout&gt; );&#125;;export default SecondPage;export const query = graphql` query ($language: String!) &#123; locales: allLocale( filter: &#123; ns: &#123; in: [&quot;page-2&quot;] &#125;, language: &#123; eq: $language &#125; &#125; ) &#123; edges &#123; node &#123; ns data language &#125; &#125; &#125; &#125;`; A new namespace:locales/en/page-2.json 1234&#123; &quot;title&quot;: &quot;Page two&quot;, &quot;welcome&quot;: &quot;Welcome to page 2&quot;&#125; locales/de/page-2.json 1234&#123; &quot;title&quot;: &quot;Seite zwei&quot;, &quot;welcome&quot;: &quot;Willkommen auf Seite 2&quot;&#125; ...and link to that page from the first one: 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; Link, Trans, useTranslation &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;import &#123; graphql &#125; from &#x27;gatsby&#x27;;import React from &#x27;react&#x27;;// ...const IndexPage = () =&gt; &#123; const &#123; t &#125; = useTranslation(); return ( &lt;Layout&gt; &lt;Seo title=&#123;t(&#x27;seo&#x27;)&#125; /&gt; &lt;h1&gt; &lt;Trans i18nKey=&quot;title&quot;&gt;Hi people&lt;/Trans&gt; &lt;/h1&gt; &#123; /* ... */&#125; &lt;p&gt; &lt;Link to=&quot;/page-2/&quot;&gt; &lt;Trans i18nKey=&quot;goToPage2&quot;&gt;Go to page 2&lt;/Trans&gt; &lt;/Link&gt; &lt;/p&gt; &lt;/Layout&gt; )&#125;export default IndexPage;export const query = graphql` query ($language: String!) &#123; locales: allLocale( filter: &#123; ns: &#123; in: [&quot;index&quot;] &#125;, language: &#123; eq: $language &#125; &#125; ) &#123; edges &#123; node &#123; ns data language &#125; &#125; &#125; &#125;`; A new translation key for locales/en/index.json: 12345&#123; &quot;seo&quot;: &quot;Home&quot;, &quot;title&quot;: &quot;Hi people&quot;, &quot;goToPage2&quot;: &quot;Go to page 2&quot;&#125; locales/de/index.json: 12345&#123; &quot;seo&quot;: &quot;Startseite&quot;, &quot;title&quot;: &quot;Hallo Leute&quot;, &quot;goToPage2&quot;: &quot;Gehen Sie zu Seite 2&quot;&#125; The Link component exported from gatsby-plugin-react-i18nextautomatically links to the correct language. The Link component is identical to Gatsby Link component except that you can provide an additional language prop to create a link to a page with a different language. Interpolation and Pluralization i18next goes beyond just providing the standard i18n features. But for sure it&#39;s able to handle plurals and interpolation. Let&#39;s count each time a button gets clicked: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; graphql &#125; from &#x27;gatsby&#x27;;import React, &#123; useState &#125; from &#x27;react&#x27;;import Layout from &#x27;../components/layout&#x27;;import &#123; useTranslation &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;const SecondPage = (props) =&gt; &#123; const &#123; t &#125; = useTranslation(); const [count, setCounter] = useState(0); return ( &lt;Layout&gt; &lt;Seo title=&#123;t(&#x27;title&#x27;)&#125; /&gt; &lt;h1&gt; &lt;Trans i18nKey=&quot;title&quot;&gt;Page two&lt;/Trans&gt; &lt;/h1&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;welcome&quot;&gt;Welcome to page 2&lt;/Trans&gt; (&#123;props.path&#125;) &lt;/p&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCounter(count + 1); &#125;&#125;&gt;&#123; t(&#x27;counter&#x27;, &#123; count &#125;) &#125;&lt;/button&gt; &lt;/p&gt; &#123;/* ... */&#125; &lt;/Layout&gt; );&#125;;export default SecondPage;export const query = graphql` query ($language: String!) &#123; locales: allLocale( filter: &#123; ns: &#123; in: [&quot;page-2&quot;] &#125;, language: &#123; eq: $language &#125; &#125; ) &#123; edges &#123; node &#123; ns data language &#125; &#125; &#125; &#125;`; ...and extending the translation resources:locales/en/page-2.json 1234567&#123; &quot;title&quot;: &quot;Page two&quot;, &quot;welcome&quot;: &quot;Welcome to page 2&quot;, &quot;counter_one&quot;: &quot;clicked one time&quot;, &quot;counter_other&quot;: &quot;clicked &#123;&#123;count&#125;&#125; time&quot;, &quot;counter_zero&quot;: &quot;Click me!&quot;&#125; locales/de/page-2.json 1234567&#123; &quot;title&quot;: &quot;Seite zwei&quot;, &quot;welcome&quot;: &quot;Willkommen auf Seite 2&quot;, &quot;counter_one&quot;: &quot;einmal angeklickt&quot;, &quot;counter_other&quot;: &quot;&#123;&#123;count&#125;&#125; Mal geklickt&quot;, &quot;counter_zero&quot;: &quot;Klick mich!&quot;&#125; Based on the count value i18next will choose the correct plural form. i18next provides also the ability to have a special translation for &#123;count: 0&#125;, so that a more natural language can be used. If the count is 0, and a _zero entry is present, then it will be used instead of the regular language plural suffix (_other). Read more about pluralization and interpolation in the official i18next documentation. 💡 i18next is also able to handle languages with multiple plural forms, like arabic: 1234567891011121314151617181920// translation resources:&#123; &quot;key_zero&quot;: &quot;zero&quot;, &quot;key_one&quot;: &quot;singular&quot;, &quot;key_two&quot;: &quot;two&quot;, &quot;key_few&quot;: &quot;few&quot;, &quot;key_many&quot;: &quot;many&quot;, &quot;key_other&quot;: &quot;other&quot;&#125;// usage:t(&#x27;key&#x27;, &#123;count: 0&#125;); // -&gt; &quot;zero&quot;t(&#x27;key&#x27;, &#123;count: 1&#125;); // -&gt; &quot;singular&quot;t(&#x27;key&#x27;, &#123;count: 2&#125;); // -&gt; &quot;two&quot;t(&#x27;key&#x27;, &#123;count: 3&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 4&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 5&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 11&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 99&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 100&#125;); // -&gt; &quot;other&quot; Why are my plural keys not working? Are you seeing this warning in the development console (debug: true)? i18next::pluralResolver: Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling. With v21 i18next streamlined the suffix with the one used in the Intl API. In environments where the Intl.PluralRules API is not available (like older Android devices), you may need to polyfill the Intl.PluralRules API. In case it is not available it will fall back to the i18next JSON format v3 plural handling. And if your json is already using the new suffixes, your plural keys will probably not be shown. tldr; npm install intl-pluralrules 1import &#x27;intl-pluralrules&#x27; Formatting Now, let’s check out how we can use different date formats with the help of i18next and Luxon to handle date and time. npm install luxon We like to have a footer displaying the current date: 123456789101112131415161718192021222324252627282930313233343536373839import React from &#x27;react&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;import &#123; useI18next &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;// ...const Layout = (&#123; children &#125;) =&gt; &#123; const &#123; t, i18n &#125; = useI18next(); // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let&#x27;s add it here if (!i18n.services.formatter.date_huge) &#123; i18n.services.formatter.add(&#x27;date_huge&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE) &#125;); &#125; return ( &lt;&gt; &lt;Header /&gt; &lt;div style=&#123;&#123; margin: &#x27;0 auto&#x27;, maxWidth: 960, padding: &#x27;0 1.0875rem 1.45rem&#x27;, &#125;&#125; &gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;footer style=&#123;&#123; marginTop: 50 &#125;&#125;&gt; &lt;i&gt; &#123; t(&#x27;footer&#x27;, &#123; date: new Date() &#125;) &#125; &lt;/i&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/&gt; );&#125;;export default Layout; Import luxon and define a format function, like documented in the documentation and add the new translation key: locales/en/common.json 123&#123; &quot;footer&quot;: &quot;Today is &#123;&#123;date, date_huge&#125;&#125;&quot;&#125; locales/de/common.json 123&#123; &quot;footer&quot;: &quot;Heute ist &#123;&#123;date, date_huge&#125;&#125;&quot;&#125; 😎 Cool, now we have a language-specific date formatting! English: German: Context What about a specific greeting message based on the current daytime? i.e. morning, evening, etc. This is possible thanks to the context feature of i18next. Let&#39;s create a getGreetingTime function and use the result as context information for our footer translation: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from &#x27;react&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;import &#123; useI18next &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;// ...const getGreetingTime = (d = DateTime.now()) =&gt; &#123; const split_afternoon = 12; // 24hr time to split the afternoon const split_evening = 17; // 24hr time to split the evening const currentHour = parseFloat(d.toFormat(&#x27;hh&#x27;)); if (currentHour &gt;= split_afternoon &amp;&amp; currentHour &lt;= split_evening) &#123; return &#x27;afternoon&#x27;; &#125; else if (currentHour &gt;= split_evening) &#123; return &#x27;evening&#x27;; &#125; return &#x27;morning&#x27;;&#125;const Layout = (&#123; children &#125;) =&gt; &#123; const &#123; t, i18n &#125; = useI18next(); // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let&#x27;s add it here if (!i18n.services.formatter.date_huge) &#123; i18n.services.formatter.add(&#x27;date_huge&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE) &#125;); &#125; return ( &lt;&gt; &lt;Header /&gt; &lt;div style=&#123;&#123; margin: &#x27;0 auto&#x27;, maxWidth: 960, padding: &#x27;0 1.0875rem 1.45rem&#x27;, &#125;&#125; &gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;footer style=&#123;&#123; marginTop: 50 &#125;&#125;&gt; &lt;i&gt; &#123; t(&#x27;footer&#x27;, &#123; date: new Date(), context: getGreetingTime() &#125;) &#125; &lt;/i&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/&gt; );&#125;;export default Layout; And add some context-specific translations keys: locales/en/common.json 123456&#123; &quot;footer&quot;: &quot;Today is &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_afternoon&quot;: &quot;Good afternoon! It&#x27;s &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_evening&quot;: &quot;Good evening! Today was the &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_morning&quot;: &quot;Good morning! Today is &#123;&#123;date, date_huge&#125;&#125; | Have a nice day!&quot;&#125; locales/de/common.json 123456&#123; &quot;footer&quot;: &quot;Heute ist &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_afternoon&quot;: &quot;Guten Nachmittag! Es ist &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_evening&quot;: &quot;Guten Abend! Heute war der &#123;&#123;date, date_huge&#125;&#125;&quot;, &quot;footer_morning&quot;: &quot;Guten Morgen! Heute ist &#123;&#123;date, date_huge&#125;&#125; | Einen schönen Tag noch!&quot;&#125; 😁 Yeah, It works! Key extraction Thanks to the babel-plugin-i18next-extract you can automatically extract translations inside the t function and Trans component from your pages and save them in the namespace files. It works like this: First, install the required dependencies: npm install @babel/cli @babel/plugin-transform-typescript babel-plugin-i18next-extract Create or update the babel-extract.config.js file (do NOT name it babel.config.js, or it will be used by gatsby): 12345678910111213141516171819202122232425const &#123; defaultLanguage &#125; = require(&#x27;./languages&#x27;);process.env.NODE_ENV = &#x27;test&#x27;;module.exports = &#123; presets: [&#x27;babel-preset-gatsby&#x27;], plugins: [ [ &#x27;i18next-extract&#x27;, &#123; keyAsDefaultValue: [defaultLanguage], useI18nextDefaultValue: [defaultLanguage], // discardOldKeys: true, defaultNS: &#x27;common&#x27;, outputPath: &#x27;locales/&#123;&#123;locale&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;, customTransComponents: [[&#x27;gatsby-plugin-react-i18next&#x27;, &#x27;Trans&#x27;]], compatibilityJSON: &#x27;v4&#x27;, &#125; ] ], overrides: [ &#123; test: [`**/*.ts`, `**/*.tsx`], plugins: [[`@babel/plugin-transform-typescript`, &#123;isTSX: true&#125;]] &#125; ]&#125;; Add a script to your package.json: 123&quot;scripts&quot;: &#123; &quot;extract&quot;: &quot;babel --config-file ./babel-extract.config.js -o tmp/chunk.js &#x27;src/**/*.&#123;js,jsx,ts,tsx&#125;&#x27; &amp;&amp; rm -rf tmp&quot;&#125; If you want to extract translations per page for a specific namespace, you can add a special comment at the beginning of the page: 1234// i18next-extract-mark-ns-start indeximport React from &#x27;react&#x27;;// ... fyi: There are also other comment hints you can use. Prepared all your pages? Nice, so let&#39;s try that: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// i18next-extract-mark-ns-start indeximport React from &#x27;react&#x27;;import &#123; Link, Trans, useTranslation &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;import &#123; graphql, Link as GatsbyLink &#125; from &#x27;gatsby&#x27;;import &#123; StaticImage &#125; from &#x27;gatsby-plugin-image&#x27;;import Layout from &#x27;../components/layout&#x27;;import Seo from &#x27;../components/seo&#x27;;const IndexPage = () =&gt; &#123; const &#123; t &#125; = useTranslation(); return ( &lt;Layout&gt; &lt;Seo title=&#123;t(&#x27;seo&#x27;)&#125; /&gt; &lt;h1&gt; &lt;Trans i18nKey=&quot;title&quot;&gt;Hi people&lt;/Trans&gt; &lt;/h1&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;welcome&quot;&gt;Welcome to your new Gatsby site.&lt;/Trans&gt; &lt;/p&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;cta&quot;&gt;Now go build something great.&lt;/Trans&gt; &lt;/p&gt; &lt;p&gt; &lt;Link to=&quot;/page-2/&quot;&gt; &lt;Trans i18nKey=&quot;goToPage2&quot;&gt;Go to page 2&lt;/Trans&gt; &lt;/Link&gt; &lt;/p&gt; &lt;/Layout&gt; );&#125;;export default IndexPage;export const query = graphql` query ($language: String!) &#123; locales: allLocale( filter: &#123; ns: &#123; in: [&quot;common&quot;, &quot;index&quot;] &#125;, language: &#123; eq: $language &#125; &#125; ) &#123; edges &#123; node &#123; ns data language &#125; &#125; &#125; &#125;`; Running npm run extract will now add that new cta key to the namespace file: 1234567&#123; &quot;cta&quot;: &quot;Now go build something great.&quot;, &quot;goToPage2&quot;: &quot;Go to page 2&quot;, &quot;seo&quot;: &quot;Home&quot;, &quot;title&quot;: &quot;Hi people&quot;, &quot;welcome&quot;: &quot;Welcome to your new Gatsby site.&quot;&#125; Extra power This is all already great, but we can do even more! It would be nice, to have an overview showing which translations are missing and which files are completely translated... And think about when having extracted new keys, they would automatically be translated? To make this true we need a translation management... By sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you. This is the traditional way. But be aware, sending files around creates always an overhead. Does a better option exist? For sure! i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? and a lot more... Looking for something like this❓ Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... How does this look like? First you need to signup at locize and login. Then create a new project in locize and add all required languages. And finally you can add your translations either by using the cli or by importing the individual json files or via API. Now let&#39;s install the locize-cli: npm install -g locize-cli We&#39;ll prepare a new script that will synchronize our local changes with locize. And also an optional second script that will just download the newest translations from locize. Make sure you use your project-id and api-key: 1234&quot;scripts&quot;: &#123; &quot;syncLocales&quot;: &quot;locize sync --project-id=5d47a999-5c34-4161-a389-bc2189507a50 --ver=latest --api-key=42ca9d58-18da-44c7-8dd3-8f59b8c35bda --path=./locales&quot;, &quot;downloadLocales&quot;: &quot;locize download --project-id=5d47a999-5c34-4161-a389-bc2189507a50 --ver=latest --clean=true --path=./locales&quot;&#125; Use the npm run syncLocales script to synchronize your local repository with what is published on locize. Alternatively, you can also use the npm run downloadLocales script to always download the published locize translations to your local repository before bundling your app. If we now add a new translation key, like this: 1&lt;Trans i18nKey=&quot;newKey&quot;&gt;this will be added automatically after &quot;extract&quot; and &quot;syncLocales&quot;&lt;/Trans&gt; and run npm run export and then npm run syncLocales, we get this: locales/en/page-2.json: 123456789&#123; &quot;back&quot;: &quot;Go back to the homepage&quot;, &quot;counter_one&quot;: &quot;clicked one time&quot;, &quot;counter_other&quot;: &quot;clicked &#123;&#123;count&#125;&#125; time&quot;, &quot;counter_zero&quot;: &quot;Click me!&quot;, &quot;title&quot;: &quot;Page two&quot;, &quot;welcome&quot;: &quot;Welcome to page 2&quot;, &quot;newKey&quot;: &quot;this will be added automatically after \\&quot;extract\\&quot; and \\&quot;syncLocales\\&quot;&quot;&#125; locales/de/page-2.json: 123456789&#123; &quot;back&quot;: &quot;Gehen Sie zurück zur Startseite&quot;, &quot;counter_one&quot;: &quot;einmal angeklickt&quot;, &quot;counter_other&quot;: &quot;&#123;&#123;count&#125;&#125; Mal geklickt&quot;, &quot;counter_zero&quot;: &quot;Klick mich!&quot;, &quot;title&quot;: &quot;Seite zwei&quot;, &quot;welcome&quot;: &quot;Willkommen auf Seite 2&quot;, &quot;newKey&quot;: &quot;dies wird automatisch nach \\&quot;extract\\&quot; und \\&quot;syncLocales\\&quot; hinzugefügt&quot;&#125; Thanks to the optionally enabled automatic machine translation option, new keys not only gets added to locize, while developing the app, but are also automatically translated into the target languages using machine translation. 👀 but there&#39;s more... (InContext Editor) With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Want to see what this look like? Ok, first install the locize dependency: npm install locize Then in the code (we choose our layout.js file) add this: 123456789101112131415161718192021222324252627282930313233343536373839404142import React from &#x27;react&#x27;;import &#123; useI18next &#125; from &#x27;gatsby-plugin-react-i18next&#x27;;import &#123; locizePlugin, setEditorLng &#125; from &#x27;locize&#x27;;// ...const Layout = (&#123; children &#125;) =&gt; &#123; const &#123; t, i18n &#125; = useI18next(); // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let&#x27;s add it here if (!i18n.services.formatter.date_huge) &#123; i18n.services.formatter.add(&#x27;date_huge&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE) &#125;); // also the locize plugin normally is automatically configured, but here we need to do it that way locizePlugin.init(i18n); setEditorLng(i18n.resolvedLanguage); &#125; return ( &lt;&gt; &lt;Header /&gt; &lt;div style=&#123;&#123; margin: &#x27;0 auto&#x27;, maxWidth: 960, padding: &#x27;0 1.0875rem 1.45rem&#x27;, &#125;&#125; &gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;footer style=&#123;&#123; marginTop: 50 &#125;&#125;&gt; &lt;i&gt; &#123; t(&#x27;footer&#x27;, &#123; date: new Date(), context: getGreetingTime() &#125;) &#125; &lt;/i&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/&gt; );&#125;;export default Layout; And in the gatsby-config.js add some new react options: 12345678910111213141516171819202122232425262728293031323334const &#123; languages, defaultLanguage &#125; = require(&#x27;./languages&#x27;);module.exports = &#123; // ... plugins: [ &#123; resolve: `gatsby-source-filesystem`, options: &#123; path: `$&#123;__dirname&#125;/locales`, name: `locale` &#125; &#125;, &#123; resolve: &#x27;gatsby-plugin-react-i18next&#x27;, options: &#123; languages, defaultLanguage, siteUrl, i18nextOptions: &#123; // debug: true, fallbackLng: defaultLanguage, supportedLngs: languages, defaultNS: &#x27;common&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, react: &#123; bindI18n: &#x27;languageChanged editorSaved&#x27;, // the editorSaved event will trigger a rerender &#125; &#125;, &#125;, &#125;, // ... ]&#125; Then go to your locize project and define your in-context editor urls, like described here. The result will look like this: Isn&#39;t this great? 🧑‍💻 The complete code can be found here. If you want to learn more basics about i18next, there&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about gatsby-plugin-react-i18next, i18next, React.js localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: Best internationalization for Gatsby (an i18next based guide)\ndescription: Gatsby Localization made easy with this ✅ step-by-step guide using i18next.\n\ndate: 2022-08-09\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - gatsby\n  - gatsby-plugin-react-i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: gatsby-i18n/gatsby-i18next.jpg\n\nlabel: gatsby-i18n\nlang: en\n---\n\n![Gatsby Localization made easy with this step-by-step guide using i18next ✅](gatsby-i18next.jpg \"Gatsby Localization example\")\n\nYou know [Gatsby](https://www.gatsbyjs.com), right? - If not, stop reading this article and make something else.\n\nYes, Gatsby an open-source framework that combines functionality from React, GraphQL and Webpack into a single tool for building static websites and apps.\n\n> But what does internationalization (i18n) look like in Gatsby?\n\nThere are some plugins/libraries that may help instrumenting the Gatsby code for internationalization.\nIn this article we will use a plugin based on the famous i18n framework [i18next](https://www.i18next.com), respectively its great extension for [React.js](https://reactjs.org) - [react-i18next](https://react.i18next.com).\n<br />\nThe Gatsby plugin we're using is [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next) created by [Dmitriy Nevzorov](https://twitter.com/nevzorov_d).\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [Internationalized links](#i18n-link)\n    - [Interpolation and Pluralization](#interpolation-pluralization)\n    - [Formatting](#formatting)\n    - [Context](#context)\n    - [Key extraction](#extract)\n    - [For sure!](#for-sure)\n    - [How does this look like?](#how-look)\n    - [👀 but there's more... (InContext Editor)](#more)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\nWhen it comes to React localization, one of the most popular i18n framework is [i18next](https://www.i18next.com) with its react extension [react-i18next](https://react.i18next.com), and for good reasons:\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology ([React](../react-i18next/), [Angular](../angular-i18next/), [Vue](../i18next-vue/), ...).*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript, React.js and basic Gatsby, before jumping to [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next). This Gatsby localization example is not intended to be a Gatsby or React beginner tutorial.\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own Gatsby project or create a new one, i.e. with the [gatsby-cli](https://www.gatsbyjs.com/docs/reference/gatsby-cli/#new).\n\n`npx gatsby-cli new`\n\nWe will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next)\n- [i18next](https://www.i18next.com)\n- [react-i18next](https://react.i18next.com)\n\n`npm install gatsby-plugin-react-i18next i18next react-i18next`\n\nCreate a `locales` directory and add a subfolder for your default/reference language (i.e. `en` for English).\n<br />\nThere we will then add our namespace files, like:\n```\n|-- en\n    |-- common.json\n    |-- index.json\n```\n\nLet's add a `languages.js` file:\n```javascript\nconst { join } = require('path')\nconst { readdirSync, lstatSync } = require('fs')\n\nconst defaultLanguage = 'en';\n\n// based on the directories get the language codes\nconst languages = readdirSync(join(__dirname, 'locales')).filter((fileName) => {\n  const joinedPath = join(join(__dirname, 'locales'), fileName)\n  const isDirectory = lstatSync(joinedPath).isDirectory()\n  return isDirectory\n});\n// defaultLanguage as first\nlanguages.splice(languages.indexOf(defaultLanguage), 1);\nlanguages.unshift(defaultLanguage);\n\nmodule.exports = {\n  languages,\n  defaultLanguage,\n};\n```\n\nImport the `languages.js` file in the `gatsby-config.js` file and configure some plugins:\n```javascript\nconst { languages, defaultLanguage } = require('./languages');\n// somewhere in your plugins add:\nmodule.exports = {\n  // ...\n  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        path: `${__dirname}/locales`,\n        name: `locale`\n      }\n    },\n    {\n      resolve: 'gatsby-plugin-react-i18next',\n      options: {\n        languages,\n        defaultLanguage,\n        siteUrl,\n        i18nextOptions: {\n          // debug: true,\n          fallbackLng: defaultLanguage,\n          supportedLngs: languages,\n          defaultNS: 'common',\n          interpolation: {\n            escapeValue: false, // not needed for react as it escapes by default\n          }\n        },\n      },\n    },\n    // ...\n  ]\n}\n```\n\nNow let's start to instrument our first internationalized text.\n<br />\nSince [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next) is exporting all methods and components of [react-i18next](https://react.i18next.com), we can do this:\n<br />\nIn a page file:\n\n```javascript\nimport { Trans, useTranslation } from 'gatsby-plugin-react-i18next';\nimport { graphql } from 'gatsby';\nimport React from 'react';\n// ...\n\nconst IndexPage = () => {\n  const { t } = useTranslation();\n  return (\n    <Layout>\n      <Seo title={t('seo')} />\n      <h1>\n        <Trans i18nKey=\"title\">Hi people</Trans>\n      </h1>\n      { /* ... */}\n    </Layout>\n  )\n}\n\nexport default IndexPage;\n\nexport const query = graphql`\n  query ($language: String!) {\n    locales: allLocale(\n      filter: { ns: { in: [\"index\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`;\n```\n\nNow also define an `locales/en/index.json` namespace file, like this:\n```json\n{\n  \"seo\": \"Home\",\n  \"title\": \"Hi people\"\n}\n```\n\nAnd maybe also another one for German?\n\n`locales/de/index.json`:\n```json\n{\n  \"seo\": \"Startseite\",\n  \"title\": \"Hallo Leute\"\n}\n```\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nTo be able to switch between different languages, we need a language switcher:\n\n```javascript\nimport { Link, useI18next } from 'gatsby-plugin-react-i18next';\nimport React from 'react';\n\nconst Header = ({ siteTitle }) => {\n  const { languages, originalPath, t, i18n } = useI18next();\n  return (\n    <header className=\"main-header\">\n      {/* ... */}\n      <ul className=\"languages\">\n        {languages.map((lng) => (\n          <li key={lng}>\n            <Link to={originalPath} language={lng} style={{ textDecoration: i18n.resolvedLanguage === lng ? 'underline' : 'none' }}>\n              {lng}\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </header>\n  );\n};\n\nexport default Header;\n```\n\nYou should now see something like this:\n\n![gatsby language switcher](app_0.jpg \"locize © inweso GmbH\")\n\nBy default, on the first load, [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next) will fallback to the `defaultLanguage` if the browser's detected language is not included in the array of `languages`.\n\nIf you want to fallback to a different language in the `languages` array, you can set the `fallbackLanguage` option.\n\nNow switching to `de` (German) should also work:\n\n![gatsby language switcher](app_1.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\n### Internationalized links <a name=\"i18n-link\"></a>\n\nLet's create a second page...\n\n```javascript\nimport { graphql } from 'gatsby';\nimport React, { useState } from 'react';\nimport Layout from '../components/layout';\nimport { useTranslation } from 'gatsby-plugin-react-i18next';\n\nconst SecondPage = (props) => {\n  const { t } = useTranslation();\n  const [count, setCounter] = useState(0);\n  return (\n    <Layout>\n      <Seo title={t('title')} />\n      <h1>\n        <Trans i18nKey=\"title\">Page two</Trans>\n      </h1>\n      <p>\n        <Trans i18nKey=\"welcome\">Welcome to page 2</Trans> ({props.path})\n      </p>\n      {/* ... */}\n    </Layout>\n  );\n};\n\nexport default SecondPage;\n\nexport const query = graphql`\n  query ($language: String!) {\n    locales: allLocale(\n      filter: { ns: { in: [\"page-2\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`;\n```\n\nA new namespace:<br />`locales/en/page-2.json`\n```json\n{\n  \"title\": \"Page two\",\n  \"welcome\": \"Welcome to page 2\"\n}\n```\n\n`locales/de/page-2.json`\n```json\n{\n  \"title\": \"Seite zwei\",\n  \"welcome\": \"Willkommen auf Seite 2\"\n}\n```\n\n...and link to that page from the first one:\n\n```javascript\nimport { Link, Trans, useTranslation } from 'gatsby-plugin-react-i18next';\nimport { graphql } from 'gatsby';\nimport React from 'react';\n// ...\n\nconst IndexPage = () => {\n  const { t } = useTranslation();\n  return (\n    <Layout>\n      <Seo title={t('seo')} />\n      <h1>\n        <Trans i18nKey=\"title\">Hi people</Trans>\n      </h1>\n      { /* ... */}\n      <p>\n        <Link to=\"/page-2/\">\n          <Trans i18nKey=\"goToPage2\">Go to page 2</Trans>\n        </Link>\n      </p>\n    </Layout>\n  )\n}\n\nexport default IndexPage;\n\nexport const query = graphql`\n  query ($language: String!) {\n    locales: allLocale(\n      filter: { ns: { in: [\"index\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`;\n```\n\nA new translation key for `locales/en/index.json`:\n```json\n{\n  \"seo\": \"Home\",\n  \"title\": \"Hi people\",\n  \"goToPage2\": \"Go to page 2\"\n}\n```\n\n`locales/de/index.json`:\n```json\n{\n  \"seo\": \"Startseite\",\n  \"title\": \"Hallo Leute\",\n  \"goToPage2\": \"Gehen Sie zu Seite 2\"\n}\n```\n\nThe `Link` component exported from `gatsby-plugin-react-i18next`automatically links to the correct language.\n<br />\nThe `Link` component is identical to Gatsby Link component except that you can provide an additional language prop to create a link to a page with a different language.\n\n\n### Interpolation and Pluralization <a name=\"interpolation-pluralization\"></a>\n\ni18next goes beyond just providing the standard i18n features.\nBut for sure it's able to handle [plurals](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation).\n\nLet's count each time a button gets clicked:\n\n```javascript\nimport { graphql } from 'gatsby';\nimport React, { useState } from 'react';\nimport Layout from '../components/layout';\nimport { useTranslation } from 'gatsby-plugin-react-i18next';\n\nconst SecondPage = (props) => {\n  const { t } = useTranslation();\n  const [count, setCounter] = useState(0);\n  return (\n    <Layout>\n      <Seo title={t('title')} />\n      <h1>\n        <Trans i18nKey=\"title\">Page two</Trans>\n      </h1>\n      <p>\n        <Trans i18nKey=\"welcome\">Welcome to page 2</Trans> ({props.path})\n      </p>\n      <p>\n        <button onClick={() => {\n          setCounter(count + 1);\n        }}>{\n          t('counter', { count })\n        }</button>\n      </p>\n      {/* ... */}\n    </Layout>\n  );\n};\n\nexport default SecondPage;\n\nexport const query = graphql`\n  query ($language: String!) {\n    locales: allLocale(\n      filter: { ns: { in: [\"page-2\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`;\n```\n\n...and extending the translation resources:<br />`locales/en/page-2.json`\n```json\n{\n  \"title\": \"Page two\",\n  \"welcome\": \"Welcome to page 2\",\n  \"counter_one\": \"clicked one time\",\n  \"counter_other\": \"clicked {{count}} time\",\n  \"counter_zero\": \"Click me!\"\n}\n```\n\n`locales/de/page-2.json`\n```json\n{\n  \"title\": \"Seite zwei\",\n  \"welcome\": \"Willkommen auf Seite 2\",\n  \"counter_one\": \"einmal angeklickt\",\n  \"counter_other\": \"{{count}} Mal geklickt\",\n  \"counter_zero\": \"Klick mich!\"\n}\n```\n\nBased on the count value i18next will choose the correct plural form.\n\ni18next provides also the ability to have a special translation for `{count: 0}`, so that a more natural language can be used. If the `count` is `0`, and a `_zero` entry is present, then it will be used instead of the regular language plural suffix (`_other`).\n\nRead more about [pluralization](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation) in the [official i18next documentation](https://www.i18next.com/).\n\n![gatsby pluralization](app_2.gif \"locize © inweso GmbH\")\n\n*💡 i18next is also able to handle languages with multiple plural forms, like arabic:*\n\n```javascript\n// translation resources:\n{\n  \"key_zero\": \"zero\",\n  \"key_one\": \"singular\",\n  \"key_two\": \"two\",\n  \"key_few\": \"few\",\n  \"key_many\": \"many\",\n  \"key_other\": \"other\"\n}\n\n// usage:\nt('key', {count: 0}); // -> \"zero\"\nt('key', {count: 1}); // -> \"singular\"\nt('key', {count: 2}); // -> \"two\"\nt('key', {count: 3}); // -> \"few\"\nt('key', {count: 4}); // -> \"few\"\nt('key', {count: 5}); // -> \"few\"\nt('key', {count: 11}); // -> \"many\"\nt('key', {count: 99}); // -> \"many\"\nt('key', {count: 100}); // -> \"other\"\n```\n\n#### Why are my plural keys not working? <a name=\"pluralsv4\"></a>\n\nAre you seeing this warning in the development console (`debug: true`)?\n\n> i18next::pluralResolver: Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\n\nWith [v21](https://www.i18next.com/misc/migration-guide#v20.x.x-to-v21.0.0) i18next streamlined the suffix with the one used in the [Intl API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules/PluralRules).\nIn environments where the [Intl.PluralRules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/PluralRules) API  is not available (like older Android devices), you may need to [polyfill](https://github.com/eemeli/intl-pluralrules) the [Intl.PluralRules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/PluralRules) API.\nIn case it is not available it will fall back to the [i18next JSON format v3](https://www.i18next.com/misc/json-format#i-18-next-json-v3) plural handling. And if your json is already using the new suffixes, your plural keys will probably not be shown.\n\n*tldr;*\n\n`npm install intl-pluralrules`\n\n```javascript\nimport 'intl-pluralrules'\n```\n\n\n### Formatting <a name=\"formatting\"></a>\n\nNow, let’s check out how we can use different date formats with the help of [i18next](https://www.i18next.com) and [Luxon](https://moment.github.io/luxon) to handle date and time.\n\n`npm install luxon`\n\nWe like to have a footer displaying the current date:\n\n```javascript\nimport React from 'react';\nimport { DateTime } from 'luxon';\nimport { useI18next } from 'gatsby-plugin-react-i18next';\n// ...\n\nconst Layout = ({ children }) => {\n  const { t, i18n } = useI18next();\n\n  // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let's add it here\n  if (!i18n.services.formatter.date_huge) {\n    i18n.services.formatter.add('date_huge', (value, lng, options) => {\n      return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n    });\n  }\n\n  return (\n    <>\n      <Header />\n      <div\n        style={{\n          margin: '0 auto',\n          maxWidth: 960,\n          padding: '0 1.0875rem 1.45rem',\n        }}\n      >\n        <main>{children}</main>\n        <footer style={{ marginTop: 50 }}>\n          <i>\n            {\n              t('footer', { date: new Date() })\n            }\n          </i>\n        </footer>\n      </div>\n    </>\n  );\n};\n\nexport default Layout;\n```\n\nImport luxon and define a format function, like documented in the [documentation](https://www.i18next.com/translation-function/formatting) and add the new translation key:\n\n`locales/en/common.json`\n```json\n{\n  \"footer\": \"Today is {{date, date_huge}}\"\n}\n```\n\n`locales/de/common.json`\n```json\n{\n  \"footer\": \"Heute ist {{date, date_huge}}\"\n}\n```\n\n**😎 Cool, now we have a language-specific date formatting!**\n\nEnglish:\n![gatsby english](app_3.jpg \"locize © inweso GmbH\")\n\nGerman:\n![gatsby german](app_4.jpg \"locize © inweso GmbH\")\n\n\n### Context <a name=\"context\"></a>\n\nWhat about a specific greeting message based on the current daytime? i.e. morning, evening, etc.\nThis is possible thanks to the [context](https://www.i18next.com/translation-function/context) feature of i18next.\n\nLet's create a `getGreetingTime` function and use the result as context information for our footer translation:\n\n```javascript\nimport React from 'react';\nimport { DateTime } from 'luxon';\nimport { useI18next } from 'gatsby-plugin-react-i18next';\n// ...\n\nconst getGreetingTime = (d = DateTime.now()) => {\n  const split_afternoon = 12; // 24hr time to split the afternoon\n  const split_evening = 17; // 24hr time to split the evening\n  const currentHour = parseFloat(d.toFormat('hh'));\n\t\n  if (currentHour >= split_afternoon && currentHour <= split_evening) {\n    return 'afternoon';\n  } else if (currentHour >= split_evening) {\n    return 'evening';\n  }\n  return 'morning';\n}\n\nconst Layout = ({ children }) => {\n  const { t, i18n } = useI18next();\n\n  // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let's add it here\n  if (!i18n.services.formatter.date_huge) {\n    i18n.services.formatter.add('date_huge', (value, lng, options) => {\n      return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n    });\n  }\n\n  return (\n    <>\n      <Header />\n      <div\n        style={{\n          margin: '0 auto',\n          maxWidth: 960,\n          padding: '0 1.0875rem 1.45rem',\n        }}\n      >\n        <main>{children}</main>\n        <footer style={{ marginTop: 50 }}>\n          <i>\n            {\n              t('footer', { date: new Date(), context: getGreetingTime() })\n            }\n          </i>\n        </footer>\n      </div>\n    </>\n  );\n};\n\nexport default Layout;\n```\n\nAnd add some context-specific translations keys:\n\n`locales/en/common.json`\n```json\n{\n  \"footer\": \"Today is {{date, date_huge}}\",\n  \"footer_afternoon\": \"Good afternoon! It's {{date, date_huge}}\",\n  \"footer_evening\": \"Good evening! Today was the {{date, date_huge}}\",\n  \"footer_morning\": \"Good morning! Today is {{date, date_huge}} | Have a nice day!\"\n}\n```\n\n`locales/de/common.json`\n```json\n{\n  \"footer\": \"Heute ist {{date, date_huge}}\",\n  \"footer_afternoon\": \"Guten Nachmittag! Es ist {{date, date_huge}}\",\n  \"footer_evening\": \"Guten Abend! Heute war der {{date, date_huge}}\",\n  \"footer_morning\": \"Guten Morgen! Heute ist {{date, date_huge}} | Einen schönen Tag noch!\"\n}\n```\n\n**😁 Yeah, It works!**\n\n![gatsby translations](app_5.jpg \"locize © inweso GmbH\")\n\n\n### Key extraction <a name=\"extract\"></a>\n\nThanks to the [babel-plugin-i18next-extract](https://i18next-extract.netlify.app) you can automatically extract translations inside the `t` function and `Trans` component from your pages and save them in the namespace files.\n\nIt works like this:\n<br />\nFirst, install the required dependencies:\n\n`npm install @babel/cli @babel/plugin-transform-typescript babel-plugin-i18next-extract`\n\nCreate or update the `babel-extract.config.js` file (do NOT name it `babel.config.js`, or it will be used by gatsby):\n\n```javascript\nconst { defaultLanguage } = require('./languages');\nprocess.env.NODE_ENV = 'test';\nmodule.exports = {\n  presets: ['babel-preset-gatsby'],\n  plugins: [\n    [\n      'i18next-extract',\n      {\n        keyAsDefaultValue: [defaultLanguage],\n        useI18nextDefaultValue: [defaultLanguage],\n        // discardOldKeys: true,\n        defaultNS: 'common',\n        outputPath: 'locales/{{locale}}/{{ns}}.json',\n        customTransComponents: [['gatsby-plugin-react-i18next', 'Trans']],\n        compatibilityJSON: 'v4',\n      }\n    ]\n  ],\n  overrides: [\n    {\n      test: [`**/*.ts`, `**/*.tsx`],\n      plugins: [[`@babel/plugin-transform-typescript`, {isTSX: true}]]\n    }\n  ]\n};\n```\n\nAdd a script to your `package.json`:\n\n```json\n\"scripts\": {\n  \"extract\": \"babel --config-file ./babel-extract.config.js -o tmp/chunk.js 'src/**/*.{js,jsx,ts,tsx}' && rm -rf tmp\"\n}\n```\n\nIf you want to extract translations per page for a specific namespace, you can add a special comment at the beginning of the page:\n\n```javascript\n// i18next-extract-mark-ns-start index\n\nimport React from 'react';\n// ...\n```\n\nfyi: There are also other [comment hints](https://i18next-extract.netlify.app/#/comment-hints) you can use.\n\nPrepared all your pages? Nice, so let's try that:\n\n```javascript\n// i18next-extract-mark-ns-start index\n\nimport React from 'react';\nimport { Link, Trans, useTranslation } from 'gatsby-plugin-react-i18next';\nimport { graphql, Link as GatsbyLink } from 'gatsby';\nimport { StaticImage } from 'gatsby-plugin-image';\nimport Layout from '../components/layout';\nimport Seo from '../components/seo';\n\nconst IndexPage = () => {\n  const { t } = useTranslation();\n  return (\n    <Layout>\n      <Seo title={t('seo')} />\n      <h1>\n        <Trans i18nKey=\"title\">Hi people</Trans>\n      </h1>\n      <p>\n        <Trans i18nKey=\"welcome\">Welcome to your new Gatsby site.</Trans>\n      </p>\n      <p>\n        <Trans i18nKey=\"cta\">Now go build something great.</Trans>\n      </p>\n      <p>\n        <Link to=\"/page-2/\">\n          <Trans i18nKey=\"goToPage2\">Go to page 2</Trans>\n        </Link>\n      </p>\n    </Layout>\n  );\n};\n\nexport default IndexPage;\n\nexport const query = graphql`\n  query ($language: String!) {\n    locales: allLocale(\n      filter: { ns: { in: [\"common\", \"index\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`;\n```\n\nRunning `npm run extract` will now add that new `cta` key to the namespace file:\n\n```json\n{\n  \"cta\": \"Now go build something great.\",\n  \"goToPage2\": \"Go to page 2\",\n  \"seo\": \"Home\",\n  \"title\": \"Hi people\",\n  \"welcome\": \"Welcome to your new Gatsby site.\"\n}\n```\n\n### Extra power <a name=\"extra-power\"></a>\n\n**This is all already great, but we can do even more!**\n\nIt would be nice, to have an overview showing which translations are missing and which files are completely translated...\n<br />\nAnd think about when having extracted new keys, they would automatically be translated?\n<br />\nTo make this true we need a [translation management](../i18n-l10n-t9n-tms/)...\n\n\nBy sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you.\nThis is the traditional way. But be aware, sending files around creates always an overhead.\n\n> Does a better option exist?\n\n#### For sure! <a name=\"for-sure\"></a>\n\ni18next helps to get the application translated, and this is great - but there is more to it.\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- and a lot more...\n\n**Looking for something like this❓**\n\n- [Easy to integrate](https://docs.locize.com/integration/instrumenting-your-code#i-18-next)\n- Continuous deployment? [Continuous localization](https://locize.com/how-it-works.html#continouslocalization)!\n- Manage the translation files with ease\n- [Order professional translations](https://docs.locize.com/guides-tips-and-tricks/working-with-translators)\n- Analytics & Statistics\n- [Versioning of your translations](https://docs.locize.com/more/versioning)\n- [Automatic and On-Demand Machine Translation](https://docs.locize.com/whats-inside/auto-machine-translation)\n- [Riskfree: Take your data with you](https://docs.locize.com/more/general-questions/how-is-locize-different-from-the-alternatives#service-lock-in)\n- [Transparent and fair pricing](https://locize.com/pricing.html)\n- and a lot more...\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add all required languages. And finally you can add your translations either by using the [cli](https://github.com/locize/react-tutorial#use-the-locize-cli) or by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations).\n\nNow let's install the [locize-cli](https://github.com/locize/locize-cli):\n\n`npm install -g locize-cli`\n\nWe'll prepare a new script that will synchronize our local changes with locize.\nAnd also an optional second script that will just download the newest translations from locize.\nMake sure you use your project-id and api-key:\n\n```json\n\"scripts\": {\n  \"syncLocales\": \"locize sync --project-id=5d47a999-5c34-4161-a389-bc2189507a50 --ver=latest --api-key=42ca9d58-18da-44c7-8dd3-8f59b8c35bda --path=./locales\",\n  \"downloadLocales\": \"locize download --project-id=5d47a999-5c34-4161-a389-bc2189507a50 --ver=latest --clean=true --path=./locales\"\n}\n```\n\nUse the `npm run syncLocales` script to synchronize your local repository with what is published on locize.\n\nAlternatively, you can also use the `npm run downloadLocales` script to always download the published locize translations to your local repository before bundling your app.\n\n\nIf we now add a new translation key, like this:\n\n```javascript\n<Trans i18nKey=\"newKey\">this will be added automatically after \"extract\" and \"syncLocales\"</Trans>\n```\n\nand run `npm run export` and then `npm run syncLocales`, we get this:\n\n`locales/en/page-2.json`:\n```json\n{\n  \"back\": \"Go back to the homepage\",\n  \"counter_one\": \"clicked one time\",\n  \"counter_other\": \"clicked {{count}} time\",\n  \"counter_zero\": \"Click me!\",\n  \"title\": \"Page two\",\n  \"welcome\": \"Welcome to page 2\",\n  \"newKey\": \"this will be added automatically after \\\"extract\\\" and \\\"syncLocales\\\"\"\n}\n```\n\n`locales/de/page-2.json`:\n```json\n{\n  \"back\": \"Gehen Sie zurück zur Startseite\",\n  \"counter_one\": \"einmal angeklickt\",\n  \"counter_other\": \"{{count}} Mal geklickt\",\n  \"counter_zero\": \"Klick mich!\",\n  \"title\": \"Seite zwei\",\n  \"welcome\": \"Willkommen auf Seite 2\",\n  \"newKey\": \"dies wird automatisch nach \\\"extract\\\" und \\\"syncLocales\\\" hinzugefügt\"\n}\n```\n\n![new key](locize_new_key.jpg \"locize © inweso GmbH\")\n\n*Thanks to the optionally enabled [automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation) option, new keys not only gets added to locize, while developing the app, but are also automatically translated into the target languages using machine translation.*\n\n![gatsby translations](app_6.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... (InContext Editor) <a name=\"more\"></a>\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nWant to see what this look like?\n\nOk, first install the locize dependency:\n\n`npm install locize`\n\nThen in the code (we choose our `layout.js` file) add this:\n\n```javascript\nimport React from 'react';\nimport { useI18next } from 'gatsby-plugin-react-i18next';\nimport { locizePlugin, setEditorLng } from 'locize';\n// ...\n\nconst Layout = ({ children }) => {\n  const { t, i18n } = useI18next();\n\n  // defining custom formatters is normally done immediately after the i18next.init call, but with gatsby-plugin-react-i18next is not possible, so let's add it here\n  if (!i18n.services.formatter.date_huge) {\n    i18n.services.formatter.add('date_huge', (value, lng, options) => {\n      return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n    });\n    // also the locize plugin normally is automatically configured, but here we need to do it that way\n    locizePlugin.init(i18n);\n    setEditorLng(i18n.resolvedLanguage);\n  }\n\n  return (\n    <>\n      <Header />\n      <div\n        style={{\n          margin: '0 auto',\n          maxWidth: 960,\n          padding: '0 1.0875rem 1.45rem',\n        }}\n      >\n        <main>{children}</main>\n        <footer style={{ marginTop: 50 }}>\n          <i>\n            {\n              t('footer', { date: new Date(), context: getGreetingTime() })\n            }\n          </i>\n        </footer>\n      </div>\n    </>\n  );\n};\n\nexport default Layout;\n```\n\nAnd in the `gatsby-config.js` add some new react options:\n\n```javascript\nconst { languages, defaultLanguage } = require('./languages');\nmodule.exports = {\n  // ...\n  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        path: `${__dirname}/locales`,\n        name: `locale`\n      }\n    },\n    {\n      resolve: 'gatsby-plugin-react-i18next',\n      options: {\n        languages,\n        defaultLanguage,\n        siteUrl,\n        i18nextOptions: {\n          // debug: true,\n          fallbackLng: defaultLanguage,\n          supportedLngs: languages,\n          defaultNS: 'common',\n          interpolation: {\n            escapeValue: false, // not needed for react as it escapes by default\n          },\n          react: {\n            bindI18n: 'languageChanged editorSaved', // the editorSaved event will trigger a rerender\n          }\n        },\n      },\n    },\n    // ...\n  ]\n}\n```\n\nThen go to your locize project and define your in-context editor urls, like described [here](https://docs.locize.com/different-views/incontext#setup-and-configuration).\n\n**The result will look like this:**\n![i18next incontext](in_context.gif \"locize © inweso GmbH\")\n\n\n>Isn't this great?\n\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/locize-gatsby-example).*\n\nIf you want to learn more basics about i18next, there's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [gatsby-plugin-react-i18next](https://github.com/microapps/gatsby-plugin-react-i18next), [i18next](https://www.i18next.com), [React.js localization](https://react.i18next.com) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"gatsby","slug":"gatsby","permalink":"https://locize.com/blog/tags/gatsby/"},{"name":"gatsby-plugin-react-i18next","slug":"gatsby-plugin-react-i18next","permalink":"https://locize.com/blog/tags/gatsby-plugin-react-i18next/"}]},{"title":"Vue Localization - Internationalize with i18next","slug":"i18next-vue","date":"un11fin11","updated":"un33fin33","comments":true,"path":"i18next-vue/","link":"","permalink":"https://locize.com/blog/i18next-vue/","excerpt":"","text":"Since Vue.js is an approachable, performant and versatile framework for building web user interfaces, it also needs a best-in-class internationalization solution. You may know vue-i18n, but for those who already know i18next a Vue.js adapted version of i18next would be more appropriate. In this tutorial, we&#39;ll make use of the i18next-vue module. TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher How to get the current language? Interpolation and Pluralization Formatting Context Separate translations from code Better translation management For sure! How does this look like? save missing translations 👀 but there&#39;s more... 📦 Let&#39;s prepare for production 🚀 🎉🥳 Congratulations 🎊🎁 So first of all: &quot;Why i18next?&quot; When it comes to Vue localization, one of the most popular is i18next with its Vue extension i18next-vue, and for good reasons: i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it... Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic Vue.js, before jumping to i18next-vue. Getting started Take your own Vue project or create a new one, i.e. with the vue create cli command. npx @vue/cli create vue-starter-project We are going to adapt the app to detect the language according to the user’s preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: i18next i18next-vue i18next-browser-languagedetector npm install i18next i18next-vue i18next-browser-languagedetector Let&#39;s prepare an i18n.js file: 1234567891011121314151617181920212223242526import i18next from &#x27;i18next&#x27;import I18NextVue from &#x27;i18next-vue&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; // here we will place our translations... &#125; &#125; &#125; &#125;);export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Let&#39;s import that file in our main.js file: 12345import &#123; createApp &#125; from &#x27;vue&#x27;import i18n from &#x27;./i18n&#x27;import App from &#x27;./App.vue&#x27;i18n(createApp(App)).mount(&#x27;#app&#x27;) Now let&#39;s try to move some hard-coded text out to the translations. For the first text, we just use a simple welcome key to directly invoke the $t function. The $t is more or less the same as i18next.t. For the second text, we will use the v-html directive to directly output real HTML. Security WarningDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use v-html on trusted content and never on user-provided content. 123456789101112&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&#x27;welcome&#x27;) &#125;&#125;&lt;/h1&gt; &lt;p v-html=&quot;$t(&#x27;descr&#x27;)&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;&#125;&lt;/script&gt; The texts are now part of the translation resources: 123456789101112131415161718192021222324252627282930import i18next from &#x27;i18next&#x27;import I18NextVue from &#x27;i18next-vue&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; welcome: &#x27;Welcome to Your Vue.js App&#x27;, descr: &#x27;For a guide and recipes on how to configure / customize &#x27; + &#x27;this project,&lt;br&gt;check out the &#x27; + &#x27;&lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot; &#x27; + &#x27;rel=&quot;noopener&quot;&gt;vue-cli documentation&lt;/a&gt;.&#x27; &#125; &#125; &#125; &#125;);export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Language Switcher Now let&#39;s define a language switcher: 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&#x27;welcome&#x27;) &#125;&#125;&lt;/h1&gt; &lt;p v-html=&quot;$t(&#x27;descr&#x27;)&quot;&gt;&lt;/p&gt; &lt;hr /&gt; &lt;div&gt; &lt;div v-if=&quot;languages&quot;&gt; &lt;span v-for=&quot;(lng, index) in Object.keys(languages)&quot; :key=&quot;lng&quot;&gt; &lt;a v-if=&quot;$i18next.resolvedLanguage !== lng&quot; v-on:click=&quot;$i18next.changeLanguage(lng)&quot;&gt; &#123;&#123; languages[lng].nativeName &#125;&#125; &lt;/a&gt; &lt;strong v-if=&quot;$i18next.resolvedLanguage === lng&quot;&gt; &#123;&#123; languages[lng].nativeName &#125;&#125; &lt;/strong&gt; &lt;span v-if=&quot;index &lt; (Object.keys(languages).length - 1)&quot;&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;, data () &#123; return &#123; languages: &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; And also add some translations for the new language: 123456789101112131415161718192021222324252627282930313233343536373839import i18next from &#x27;i18next&#x27;import I18NextVue from &#x27;i18next-vue&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; welcome: &#x27;Welcome to Your Vue.js App&#x27;, descr: &#x27;For a guide and recipes on how to configure / customize &#x27; + &#x27;this project,&lt;br&gt;check out the &#x27; + &#x27;&lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot; &#x27; + &#x27;rel=&quot;noopener&quot;&gt;vue-cli documentation&lt;/a&gt;.&#x27; &#125; &#125;, de: &#123; translation: &#123; welcome: &#x27;Willkommen zu Deiner Vue.js App&#x27;, descr: &#x27;Eine Anleitung und Rezepte zum Konfigurieren/Anpassen &#x27; + &#x27;dieses Projekts findest du&lt;br&gt;in der &#x27; + &#x27;&lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot; &#x27; + &#x27;rel=&quot;noopener&quot;&gt;vue-cli-Dokumentation&lt;/a&gt;.&#x27; &#125; &#125; &#125; &#125;);export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; 🥳 Awesome, you&#39;ve just created your first language switcher! Thanks to i18next-browser-languagedetector now it tries to detect the browser language and automatically use that language if you&#39;ve provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as the preferred language. How to get the current language? Since i18next v21 there is i18next.resolvedLanguage. It is set to the current resolved language and it can be used as the primary used language, for example in a language switcher. If your detected language for example is en-US and you provided translations only for en (fallbackLng) instead i18next.resolvedLanguage will return en. i18next.language vs. i18next.languages vs. i18next.resolvedLanguage12345678910111213141516171819202122232425262728/* language */i18next.language;// Is set to the current detected or set language./* language */i18next.languages;// Is set to an array of language codes that will be used to look up the translation value.// When the language is set, this array is populated with the new language codes.// Unless overridden, this array is populated with less-specific versions of that code for fallback purposes, followed by the list of fallback languages// initialize with fallback languagesi18next.init(&#123; fallbackLng: [&quot;es&quot;, &quot;fr&quot;, &quot;en-US&quot;, &quot;dev&quot;]&#125;);// change the languagei18next.changeLanguage(&quot;en-US-xx&quot;);// new language and its more generic forms, followed by fallbacksi18next.languages; // [&quot;en-US-xx&quot;, &quot;en-US&quot;, &quot;en&quot;, &quot;es&quot;, &quot;fr&quot;, &quot;dev&quot;]// change the language againi18next.changeLanguage(&quot;de-DE&quot;);// previous language is not retainedi18next.languages; // [&quot;de-DE&quot;, &quot;de&quot;, &quot;es&quot;, &quot;fr&quot;, &quot;en-US&quot;, &quot;dev&quot;]/* resolvedLanguage */i18next.resolvedLanguage;// Is set to the current resolved language.// It can be used as primary used language,// for example in a language switcher. Interpolation and Pluralization i18next goes beyond just providing the standard i18n features. But for sure it&#39;s able to handle plurals and interpolation. If you like to see how this works, have a look at this section in that other blog post. Formatting Also, formatting can be done. If you like to see how this works, have a look at this section in that other blog post. Context What about a specific greeting message based on the current daytime? i.e. morning, evening, etc. This is possible thanks to the context feature of i18next. If you like to see how this works, have a look at this section in that other blog post. Separate translations from code Having the translations in our i18n.js file works, but is not that suitable to work with, for translators. Let&#39;s separate the translations from the code and place them in dedicated json files. Because this is a web application, i18next-http-backend will help us to do so. npm install i18next-http-backend Move the translations to the public folder: Adapt the i18n.js file to use the i18next-http-backend: 123456789101112131415161718192021222324import i18next from &#x27;i18next&#x27;import I18NextVue from &#x27;i18next-vue&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import Backend from &#x27;i18next-http-backend&#x27;i18next // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27; &#125;);export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Now the translations are loaded asynchronously. If you have slow network connectivity, you may notice until the translations are loaded only the i18n keys are shown. To prevent this, we make use of the new Suspense functionality of Vue.js. First, let&#39;s adapt the i18n.js file, by exporting the i18next init promise: 12345678910111213141516171819202122232425import i18next from &#x27;i18next&#x27;import I18NextVue from &#x27;i18next-vue&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import Backend from &#x27;i18next-http-backend&#x27;export const i18nextPromise = i18next // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27; &#125;);export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; ...and use that promise in the App.vue: 12345678910111213141516171819202122&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;TranslationShowCase /&gt;&lt;/template&gt;&lt;script&gt;import TranslationShowCase from &#x27;./components/TranslationShowCase.vue&#x27;import &#123; i18nextPromise &#125; from &#x27;./i18n.js&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; TranslationShowCase &#125;, // used in combination with Suspense. // useful when translations are not in-memory... async setup() &#123; await i18nextPromise return &#123;&#125; &#125;&#125;&lt;/script&gt; Let&#39;s create a new file: i.e. Suspenser.vue: 123456789101112131415161718192021222324&lt;template&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;App /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;Loading...&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt;import App from &#x27;./App.vue&#x27;export default &#123; name: &#x27;Suspenser&#x27;, components: &#123; App &#125;&#125;&lt;/script&gt; And use that in your main.js file: 12345import &#123; createApp &#125; from &#x27;vue&#x27;import i18n from &#x27;./i18n&#x27;import App from &#x27;./Suspenser.vue&#x27;i18n(createApp(App)).mount(&#x27;#app&#x27;) Now, as long as your translations get loaded you&#39;ll see the fallback template: Now your app looks still the same, but your translations are separated. If you want to support a new language, you just create a new folder and a new translation json file. This gives you the possibility to send the translations to some translators. Or if you&#39;re working with a translation management system you can just synchronize the files with a cli. Better translation management By sending the translations to some translators or translator agencies you have more control and a direct contact with them. But this also means more work for you. This is a traditional way. But be aware sending files around creates always an overhead. Does a better option exist? For sure! i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? How do you deploy translation changes without deploying your complete application? and a lot more... Looking for something like this❓ Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Profit from our content delivery network (CDN) Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... What does this look like? First, you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by using the cli or by importing the individual json files or via API. Done so, we&#39;re going to replace i18next-http-backend with i18next-locize-backend. npm install i18next-locize-backend After having imported the translations to locize, delete the locales folder. Adapt the i18n.js file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project: 1234567891011121314151617181920212223242526272829303132import I18NextVue from &#x27;i18next-vue&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;const locizeOptions = &#123; projectId: &#x27;94c21299-0cf5-4ad3-92eb-91f36fc3f20f&#x27;, apiKey: &#x27;bc8586d9-fceb-489c-86ac-2985393ed955&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;export const i18nextPromise = i18next // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions &#125;)export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; i18next-locize-backend offers functionality to retrieve the available languages directly from locize, let&#39;s use it: 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&#x27;welcome&#x27;) &#125;&#125;&lt;/h1&gt; &lt;p v-html=&quot;$t(&#x27;descr&#x27;)&quot;&gt;&lt;/p&gt; &lt;i&gt;&#123;&#123; $t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;) &#125;&#125;&lt;/i&gt; &lt;hr /&gt; &lt;div&gt; &lt;div v-if=&quot;languages&quot;&gt; &lt;span v-for=&quot;(lng, index) in Object.keys(languages)&quot; :key=&quot;lng&quot;&gt; &lt;a v-if=&quot;$i18next.resolvedLanguage !== lng&quot; v-on:click=&quot;$i18next.changeLanguage(lng)&quot;&gt; &#123;&#123; languages[lng].nativeName &#125;&#125; &lt;/a&gt; &lt;strong v-if=&quot;$i18next.resolvedLanguage === lng&quot;&gt; &#123;&#123; languages[lng].nativeName &#125;&#125; &lt;/strong&gt; &lt;span v-if=&quot;index &lt; (Object.keys(languages).length - 1)&quot;&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import i18next from &#x27;i18next&#x27;export default &#123; name: &#x27;TranslationShowCase&#x27;, data () &#123; return &#123; languages: [] &#125; &#125;, async mounted () &#123; this.languages = await i18next.services.backendConnector.backend.getLanguages() &#125;&#125;&lt;/script&gt; save missing translations Thanks to the use of the saveMissing functionality, new keys get added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options: 123456789101112131415161718192021222324252627282930313233import I18NextVue from &#x27;i18next-vue&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;const locizeOptions = &#123; projectId: &#x27;94c21299-0cf5-4ad3-92eb-91f36fc3f20f&#x27;, apiKey: &#x27;bc8586d9-fceb-489c-86ac-2985393ed955&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;export const i18nextPromise = i18next // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions, saveMissing: true &#125;)export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;i&gt;&#123;&#123; $t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;) &#125;&#125;&lt;/i&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see what the automatic machine translation workflow looks like! npm install locize-lastused locize use them in i18n.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import I18NextVue from &#x27;i18next-vue&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import LastUsed from &#x27;locize-lastused&#x27;import &#123; locizePlugin &#125; from &#x27;locize&#x27;const locizeOptions = &#123; projectId: &#x27;94c21299-0cf5-4ad3-92eb-91f36fc3f20f&#x27;, apiKey: &#x27;bc8586d9-fceb-489c-86ac-2985393ed955&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;export const i18nextPromise = i18next // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused .use(LastUsed) // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, saveMissing: true, backend: locizeOptions, locizeLastUsed: locizeOptions &#125;)export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Automatic machine translation: Last used translations filter: InContext Editor: 📦 Let&#39;s prepare for production 🚀 Now, we prepare the app for going to production. First, in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via API or via CLI. Lastly, enable Cache-Control max-age​ for that production version. Let&#39;s make use of the environment feature... Lets&#39; create a default environment file and one for development and one for production: .env: 1VUE_APP_LOCIZE_PROJECTID=94c21299-0cf5-4ad3-92eb-91f36fc3f20f .env.development: 12VUE_APP_LOCIZE_VERSION=latestVUE_APP_LOCIZE_APIKEY=bc8586d9-fceb-489c-86ac-2985393ed955 .env.production: 1VUE_APP_LOCIZE_VERSION=production Now let&#39;s adapt the i18n.js file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import I18NextVue from &#x27;i18next-vue&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import LastUsed from &#x27;locize-lastused&#x27;import &#123; locizePlugin &#125; from &#x27;locize&#x27;const isProduction = process.env.NODE_ENV === &#x27;production&#x27;const locizeOptions = &#123; projectId: process.env.VUE_APP_LOCIZE_PROJECTID, apiKey: process.env.VUE_APP_LOCIZE_APIKEY, // YOU should not expose your apps API key to production!!! version: process.env.VUE_APP_LOCIZE_VERSION&#125;if (!isProduction) &#123; // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused i18next.use(LastUsed);&#125;export const i18nextPromise = i18next // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: !isProduction, fallbackLng: &#x27;en&#x27;, saveMissing: !isProduction, backend: locizeOptions, locizeLastUsed: locizeOptions &#125;)export default function (app) &#123; app.use(I18NextVue, &#123; i18next &#125;) return app&#125; Now, during development, you&#39;ll continue to save missing keys and make use of lastused feature. =&gt; npm run serve And in the production environment, saveMissing and lastused are disabled, and also the API key is not exposed. =&gt; npm run build Caching: Merging versions: 🧑‍💻 The complete code can be found here. Check also the code integration part in this YouTube video. There&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18next, Vue.js localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: Vue Localization - Internationalize with i18next\ndescription: Vue Localization made easy with this ✅ step-by-step guide using i18next.\n\ndate: 2022-05-16\ntags:\n  - i18next\n  - vue\n  - i18next-vue\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: i18next-vue/vue-localization.jpg\nredirect_from:\n- /vue-i18next\n\nlabel: i18next-vue\nlang: en\n---\n\n![Vue Localization made easy with this step-by-step guide using i18next ✅](vue-localization.jpg \"Vue Localization example\")\n\nSince [Vue.js](https://vuejs.org/) is an approachable, performant and versatile framework for building web user interfaces, it also needs a best-in-class internationalization solution.\nYou may know [vue-i18n](../give-vue-i18n-more-superpowers/), but for those who already know [i18next](https://www.i18next.com) a Vue.js adapted version of i18next would be more appropriate.\n\nIn this tutorial, we'll make use of the [i18next-vue](https://github.com/i18next/i18next-vue) module.\n\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n      - [How to get the current language?](#current-language)\n    - [Interpolation and Pluralization](#interpolation-pluralization)\n    - [Formatting](#formatting)\n    - [Context](#context)\n    - [Separate translations from code](#separate)\n    - [Better translation management](#better-translation-management)\n      - [For sure!](#for-sure)\n      - [How does this look like?](#how-look)\n      - [save missing translations](#save-missing)\n      - [👀 but there's more...](#more)\n      - [📦 Let's prepare for production 🚀](#production)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\nWhen it comes to Vue localization, one of the most popular is [i18next](https://www.i18next.com) with its Vue extension [i18next-vue](https://i18next.github.io/i18next-vue/), and for good reasons:\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology ([React](../react-i18next/), [Angular](../angular-i18next/), Vue, ...).*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any [i18n format](../i18n-formats-javascript/), ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic Vue.js, before jumping to [i18next-vue](https://i18next.github.io/i18next-vue/).\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own Vue project or create a new one, i.e. with [the vue create cli command](https://cli.vuejs.org/guide/creating-a-project.html#vue-create).\n\n`npx @vue/cli create vue-starter-project`\n\n![learn vue logo](app_0.jpg \"locize © inweso GmbH\")\n\nWe are going to adapt the app to detect the language according to the user’s preference.\nAnd we will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [i18next](https://www.i18next.com)\n- [i18next-vue](https://github.com/i18next/i18next-vue)\n- [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector)\n\n`npm install i18next i18next-vue i18next-browser-languagedetector`\n\nLet's prepare an `i18n.js` file:\n```javascript\nimport i18next from 'i18next'\nimport I18NextVue from 'i18next-vue'\nimport LanguageDetector from 'i18next-browser-languagedetector'\n\ni18next\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    resources: {\n      en: {\n        translation: {\n          // here we will place our translations...\n        }\n      }\n    }\n  });\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\nLet's import that file in our `main.js` file:\n\n```javascript\nimport { createApp } from 'vue'\nimport i18n from './i18n'\nimport App from './App.vue'\n\ni18n(createApp(App)).mount('#app')\n```\n\nNow let's try to move some hard-coded text out to the translations.\n\nFor the first text, we just use a simple `welcome` key to directly invoke the `$t` function. The `$t` is more or less the same as [`i18next.t`](https://www.i18next.com/overview/api#t).\n\nFor the second text, we will use the [`v-html` directive](https://vuejs.org/guide/essentials/template-syntax.html#raw-html) to directly output real HTML.\n\n>**Security Warning**<br />Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use `v-html` on trusted content and never on user-provided content.\n\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t('welcome') }}</h1>\n    <p v-html=\"$t('descr')\"></p>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase'\n}\n</script>\n```\n\nThe texts are now part of the translation resources:\n\n```javascript\nimport i18next from 'i18next'\nimport I18NextVue from 'i18next-vue'\nimport LanguageDetector from 'i18next-browser-languagedetector'\n\ni18next\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    resources: {\n      en: {\n        translation: {\n          welcome: 'Welcome to Your Vue.js App',\n          descr: 'For a guide and recipes on how to configure / customize '\n            + 'this project,<br>check out the '\n            + '<a href=\"https://cli.vuejs.org\" target=\"_blank\" '\n            + 'rel=\"noopener\">vue-cli documentation</a>.'\n        }\n      }\n    }\n  });\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nNow let's define a language switcher:\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t('welcome') }}</h1>\n    <p v-html=\"$t('descr')\"></p>\n    <hr />\n    <div>\n      <div v-if=\"languages\">\n        <span v-for=\"(lng, index) in Object.keys(languages)\" :key=\"lng\">\n          <a v-if=\"$i18next.resolvedLanguage !== lng\" v-on:click=\"$i18next.changeLanguage(lng)\">\n            {{ languages[lng].nativeName }}\n          </a>\n          <strong v-if=\"$i18next.resolvedLanguage === lng\">\n            {{ languages[lng].nativeName }}\n          </strong>\n          <span v-if=\"index < (Object.keys(languages).length - 1)\">&nbsp;|&nbsp;</span>\n        </span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase',\n  data () {\n    return {\n      languages: {\n        en: { nativeName: 'English' },\n        de: { nativeName: 'Deutsch' }\n      }\n    }\n  }\n}\n</script>\n```\n\nAnd also add some translations for the new language:\n\n```javascript\nimport i18next from 'i18next'\nimport I18NextVue from 'i18next-vue'\nimport LanguageDetector from 'i18next-browser-languagedetector'\n\ni18next\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    resources: {\n      en: {\n        translation: {\n          welcome: 'Welcome to Your Vue.js App',\n          descr: 'For a guide and recipes on how to configure / customize '\n            + 'this project,<br>check out the '\n            + '<a href=\"https://cli.vuejs.org\" target=\"_blank\" '\n            + 'rel=\"noopener\">vue-cli documentation</a>.'\n        }\n      },\n      de: {\n        translation: {\n          welcome: 'Willkommen zu Deiner Vue.js App',\n          descr: 'Eine Anleitung und Rezepte zum Konfigurieren/Anpassen '\n            + 'dieses Projekts findest du<br>in der '\n            + '<a href=\"https://cli.vuejs.org\" target=\"_blank\" '\n            + 'rel=\"noopener\">vue-cli-Dokumentation</a>.'\n        }\n      }\n    }\n  });\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\n![vue language switcher](app_1.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\nThanks to [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) now it tries to detect the browser language and automatically use that language if you've provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as the preferred language.\n\n#### How to get the current language? <a name=\"current-language\"></a>\n\nSince i18next v21 there is [`i18next.resolvedLanguage`](https://www.i18next.com/overview/api#resolvedlanguage).\nIt is set to the current resolved language and it can be used as the primary used language, for example in a language switcher.\n\nIf your detected language for example is `en-US` and you provided translations only for `en` *(fallbackLng)* instead `i18next.resolvedLanguage` will return `en`.\n\n##### i18next.language vs. i18next.languages vs. i18next.resolvedLanguage\n\n```javascript\n/* language */\ni18next.language;\n// Is set to the current detected or set language.\n\n/* language */\ni18next.languages;\n// Is set to an array of language codes that will be used to look up the translation value.\n// When the language is set, this array is populated with the new language codes.\n// Unless overridden, this array is populated with less-specific versions of that code for fallback purposes, followed by the list of fallback languages\n\n// initialize with fallback languages\ni18next.init({\n  fallbackLng: [\"es\", \"fr\", \"en-US\", \"dev\"]\n});\n// change the language\ni18next.changeLanguage(\"en-US-xx\");\n// new language and its more generic forms, followed by fallbacks\ni18next.languages; // [\"en-US-xx\", \"en-US\", \"en\", \"es\", \"fr\", \"dev\"]\n// change the language again\ni18next.changeLanguage(\"de-DE\");\n// previous language is not retained\ni18next.languages; // [\"de-DE\", \"de\", \"es\", \"fr\", \"en-US\", \"dev\"]\n\n/* resolvedLanguage */\ni18next.resolvedLanguage;\n// Is set to the current resolved language.\n// It can be used as primary used language,\n// for example in a language switcher.\n```\n\n### Interpolation and Pluralization <a name=\"interpolation-pluralization\"></a>\n\ni18next goes beyond just providing the standard i18n features.\nBut for sure it's able to handle [plurals](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation).\n\nIf you like to see how this works, have a look at [this section in that other blog post](../react-i18next/#interpolation-pluralization).\n\n\n### Formatting <a name=\"formatting\"></a>\n\nAlso, [formatting](https://www.i18next.com/translation-function/formatting) can be done.\n\nIf you like to see how this works, have a look at [this section in that other blog post](../react-i18next/#formatting).\n\n\n### Context <a name=\"context\"></a>\n\nWhat about a specific greeting message based on the current daytime? i.e. morning, evening, etc.\nThis is possible thanks to the [context](https://www.i18next.com/translation-function/context) feature of i18next.\n\nIf you like to see how this works, have a look at [this section in that other blog post](../react-i18next/#context).\n\n\n### Separate translations from code <a name=\"separate\"></a>\n\nHaving the translations in our `i18n.js` file works, but is not that suitable to work with, for translators.\nLet's separate the translations from the code and place them in dedicated json files.\n\nBecause this is a web application, [i18next-http-backend](https://github.com/i18next/i18next-http-backend) will help us to do so.\n\n`npm install i18next-http-backend`\n\nMove the translations to the public folder:\n\n![public locales](public_locales.jpg \"locize © inweso GmbH\")\n\nAdapt the `i18n.js` file to use the `i18next-http-backend`:\n\n```javascript\nimport i18next from 'i18next'\nimport I18NextVue from 'i18next-vue'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport Backend from 'i18next-http-backend'\n\ni18next\n  // i18next-http-backend\n  // loads translations from your server\n  // https://github.com/i18next/i18next-http-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en'\n  });\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\nNow the translations are loaded asynchronously.\nIf you have slow network connectivity, you may notice until the translations are loaded only the i18n keys are shown.\n\nTo prevent this, we make use of the new [Suspense](https://vuejs.org/guide/built-ins/suspense.html) functionality of Vue.js.\n\nFirst, let's adapt the `i18n.js` file, by exporting the i18next init promise:\n```javascript\nimport i18next from 'i18next'\nimport I18NextVue from 'i18next-vue'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport Backend from 'i18next-http-backend'\n\nexport const\n  i18nextPromise = i18next\n  // i18next-http-backend\n  // loads translations from your server\n  // https://github.com/i18next/i18next-http-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en'\n  });\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\n...and use that promise in the `App.vue`:\n```javascript\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <TranslationShowCase />\n</template>\n\n<script>\nimport TranslationShowCase from './components/TranslationShowCase.vue'\nimport { i18nextPromise } from './i18n.js'\n\nexport default {\n  name: 'App',\n  components: {\n    TranslationShowCase\n  },\n  // used in combination with Suspense.\n  // useful when translations are not in-memory...\n  async setup() {\n    await i18nextPromise\n    return {}\n  }\n}\n</script>\n```\n\nLet's create a new file: i.e. `Suspenser.vue`:\n\n```javascript\n<template>\n  <Suspense>\n    <template #default>\n      <App />\n    </template>\n    <template #fallback>\n      <div>\n        <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n        <h1>Loading...</h1>\n      </div>\n    </template>\n  </Suspense>\n</template>\n\n<script>\nimport App from './App.vue'\n\nexport default {\n  name: 'Suspenser',\n  components: {\n    App\n  }\n}\n</script>\n```\n\nAnd use that in your `main.js` file:\n\n```javascript\nimport { createApp } from 'vue'\nimport i18n from './i18n'\nimport App from './Suspenser.vue'\n\ni18n(createApp(App)).mount('#app')\n```\n\nNow, as long as your translations get loaded you'll see the fallback template:\n![](app_2.jpg \"locize © inweso GmbH\")\n\nNow your app looks still the same, but your translations are separated.\nIf you want to support a new language, you just create a new folder and a new translation json file.\nThis gives you the possibility to send the translations to some translators.\nOr if you're working with a translation management system you can just [synchronize the files with a cli](https://github.com/locize/react-tutorial#use-the-locize-cli).\n\n\n### Better translation management <a name=\"better-translation-management\"></a>\n\nBy sending the translations to some translators or translator agencies you have more control and a direct contact with them. But this also means more work for you.\nThis is a traditional way. But be aware sending files around creates always an overhead.\n\n> Does a better option exist?\n\n#### For sure! <a name=\"for-sure\"></a>\n\ni18next helps to get the application translated, and this is great - but there is more to it.\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- How do you deploy translation changes without deploying your complete application?\n- and a lot more...\n\n**Looking for something like this❓**\n\n- [Easy to integrate](https://docs.locize.com/integration/instrumenting-your-code#i-18-next)\n- Continuous deployment? [Continuous localization](https://locize.com/how-it-works.html#continouslocalization)!\n- Manage the translation files with ease\n- [Order professional translations](https://docs.locize.com/guides-tips-and-tricks/working-with-translators)\n- Analytics & Statistics\n- [Profit from our content delivery network (CDN)](https://docs.locize.com/whats-inside/cdn-content-delivery-network)\n- [Versioning of your translations](https://docs.locize.com/more/versioning)\n- [Automatic and On-Demand Machine Translation](https://docs.locize.com/whats-inside/auto-machine-translation)\n- [Riskfree: Take your data with you](https://docs.locize.com/more/general-questions/how-is-locize-different-from-the-alternatives#service-lock-in)\n- [Transparent and fair pricing](https://locize.com/pricing.html)\n- and a lot more...\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\n#### What does this look like? <a name=\"how-look\"></a>\n\nFirst, you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by using the [cli](https://github.com/locize/react-tutorial#use-the-locize-cli) or by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations).\n\nDone so, we're going to replace [i18next-http-backend](https://github.com/i18next/i18next-http-backend) with [i18next-locize-backend](https://github.com/locize/i18next-locize-backend).\n\n`npm install i18next-locize-backend`\n\nAfter having imported the translations to locize, delete the locales folder.\n\nAdapt the `i18n.js` file to use the `i18next-locize-backend` and make sure you copy the project-id and api-key from within your locize project:\n\n```javascript\nimport I18NextVue from 'i18next-vue'\nimport i18next from 'i18next'\nimport Backend from 'i18next-locize-backend'\nimport LanguageDetector from 'i18next-browser-languagedetector'\n\nconst locizeOptions = {\n  projectId: '94c21299-0cf5-4ad3-92eb-91f36fc3f20f',\n  apiKey: 'bc8586d9-fceb-489c-86ac-2985393ed955', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\nexport const\n  i18nextPromise = i18next\n                    // i18next-locize-backend\n                    // loads translations from your project, saves new keys to it (saveMissing: true)\n                    // https://github.com/locize/i18next-locize-backend\n                    .use(Backend)\n                    // detect user language\n                    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n                    .use(LanguageDetector)\n                    // init i18next\n                    // for all options read: https://www.i18next.com/overview/configuration-options\n                    .init({\n                      debug: true,\n                      fallbackLng: 'en',\n                      backend: locizeOptions\n                    })\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\n[i18next-locize-backend](https://github.com/locize/i18next-locize-backend) offers functionality to retrieve the available languages directly from locize, let's use it:\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t('welcome') }}</h1>\n    <p v-html=\"$t('descr')\"></p>\n    <i>{{ $t('new.key', 'this will be added automatically') }}</i>\n    <hr />\n    <div>\n      <div v-if=\"languages\">\n        <span v-for=\"(lng, index) in Object.keys(languages)\" :key=\"lng\">\n          <a v-if=\"$i18next.resolvedLanguage !== lng\" v-on:click=\"$i18next.changeLanguage(lng)\">\n            {{ languages[lng].nativeName }}\n          </a>\n          <strong v-if=\"$i18next.resolvedLanguage === lng\">\n            {{ languages[lng].nativeName }}\n          </strong>\n          <span v-if=\"index < (Object.keys(languages).length - 1)\">&nbsp;|&nbsp;</span>\n        </span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport i18next from 'i18next'\n\nexport default {\n  name: 'TranslationShowCase',\n  data () {\n    return {\n      languages: []\n    }\n  },\n  async mounted () {\n    this.languages = await i18next.services.backendConnector.backend.getLanguages()\n  }\n}\n</script>\n```\n\n#### save missing translations <a name=\"save-missing\"></a>\n\nThanks to the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys get added to locize automatically, while developing the app.\n\nJust pass `saveMissing: true` in the i18next options:\n\n```javascript\nimport I18NextVue from 'i18next-vue'\nimport i18next from 'i18next'\nimport Backend from 'i18next-locize-backend'\nimport LanguageDetector from 'i18next-browser-languagedetector'\n\nconst locizeOptions = {\n  projectId: '94c21299-0cf5-4ad3-92eb-91f36fc3f20f',\n  apiKey: 'bc8586d9-fceb-489c-86ac-2985393ed955', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\nexport const\n  i18nextPromise = i18next\n                    // i18next-locize-backend\n                    // loads translations from your project, saves new keys to it (saveMissing: true)\n                    // https://github.com/locize/i18next-locize-backend\n                    .use(Backend)\n                    // detect user language\n                    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n                    .use(LanguageDetector)\n                    // init i18next\n                    // for all options read: https://www.i18next.com/overview/configuration-options\n                    .init({\n                      debug: true,\n                      fallbackLng: 'en',\n                      backend: locizeOptions,\n                      saveMissing: true\n                    })\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<i>{{ $t('new.key', 'this will be added automatically') }}</i>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation) and the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation.\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see what the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n`npm install locize-lastused locize`\n\nuse them in `i18n.js`:\n\n```javascript\nimport I18NextVue from 'i18next-vue'\nimport i18next from 'i18next'\nimport Backend from 'i18next-locize-backend'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport LastUsed from 'locize-lastused'\nimport { locizePlugin } from 'locize'\n\nconst locizeOptions = {\n  projectId: '94c21299-0cf5-4ad3-92eb-91f36fc3f20f',\n  apiKey: 'bc8586d9-fceb-489c-86ac-2985393ed955', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\nexport const\n  i18nextPromise = i18next\n                    // locize-lastused\n                    // sets a timestamp of last access on every translation segment on locize\n                    // -> safely remove the ones not being touched for weeks/months\n                    // https://github.com/locize/locize-lastused\n                    .use(LastUsed)\n                    // locize-editor\n                    // InContext Editor of locize\n                    .use(locizePlugin)\n                    // i18next-locize-backend\n                    // loads translations from your project, saves new keys to it (saveMissing: true)\n                    // https://github.com/locize/i18next-locize-backend\n                    .use(Backend)\n                    // detect user language\n                    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n                    .use(LanguageDetector)\n                    // init i18next\n                    // for all options read: https://www.i18next.com/overview/configuration-options\n                    .init({\n                      debug: true,\n                      fallbackLng: 'en',\n                      saveMissing: true,\n                      backend: locizeOptions,\n                      locizeLastUsed: locizeOptions\n                    })\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![missing key auto](missing_key_auto_mt.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![i18next last used](last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![i18next incontext](in_context.jpg \"locize © inweso GmbH\")\n\n\n#### 📦 Let's prepare for production 🚀 <a name=\"production\"></a>\n\nNow, we prepare the app for [going to production](https://docs.locize.com/guides-tips-and-tricks/going-production).\n\nFirst, in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via [API](https://docs.locize.com/integration/api#publish-version) or via [CLI](https://github.com/locize/locize-cli#publish-version).\nLastly, [enable Cache-Control max-age​](https://docs.locize.com/more/caching) for that production version.\n\nLet's make use of the environment feature...\n\nLets' create a default environment file and one for development and one for production:\n\n`.env`:\n```\nVUE_APP_LOCIZE_PROJECTID=94c21299-0cf5-4ad3-92eb-91f36fc3f20f\n```\n\n`.env.development`:\n```\nVUE_APP_LOCIZE_VERSION=latest\nVUE_APP_LOCIZE_APIKEY=bc8586d9-fceb-489c-86ac-2985393ed955\n```\n\n`.env.production`:\n```\nVUE_APP_LOCIZE_VERSION=production\n```\n\nNow let's adapt the `i18n.js` file:\n\n```javascript\nimport I18NextVue from 'i18next-vue'\nimport i18next from 'i18next'\nimport Backend from 'i18next-locize-backend'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport LastUsed from 'locize-lastused'\nimport { locizePlugin } from 'locize'\n\nconst isProduction = process.env.NODE_ENV === 'production'\n\nconst locizeOptions = {\n  projectId: process.env.VUE_APP_LOCIZE_PROJECTID,\n  apiKey: process.env.VUE_APP_LOCIZE_APIKEY, // YOU should not expose your apps API key to production!!!\n  version: process.env.VUE_APP_LOCIZE_VERSION\n}\n\nif (!isProduction) {\n  // locize-lastused\n  // sets a timestamp of last access on every translation segment on locize\n  // -> safely remove the ones not being touched for weeks/months\n  // https://github.com/locize/locize-lastused\n  i18next.use(LastUsed);\n}\n\nexport const\n  i18nextPromise = i18next\n                    // locize-editor\n                    // InContext Editor of locize\n                    .use(locizePlugin)\n                    // i18next-locize-backend\n                    // loads translations from your project, saves new keys to it (saveMissing: true)\n                    // https://github.com/locize/i18next-locize-backend\n                    .use(Backend)\n                    // detect user language\n                    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n                    .use(LanguageDetector)\n                    // init i18next\n                    // for all options read: https://www.i18next.com/overview/configuration-options\n                    .init({\n                      debug: !isProduction,\n                      fallbackLng: 'en',\n                      saveMissing: !isProduction,\n                      backend: locizeOptions,\n                      locizeLastUsed: locizeOptions\n                    })\n\nexport default function (app) {\n  app.use(I18NextVue, { i18next })\n  return app\n}\n```\n\nNow, during development, you'll continue to save missing keys and make use of `lastused` feature. => `npm run serve`\n\nAnd in the production environment, `saveMissing` and `lastused` are disabled, and also the API key is not exposed. => `npm run build`\n\n\n[Caching](https://docs.locize.com/more/caching):\n\n![i18next caching](caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/locize-i18next-vue-example).*\n\n*Check also the [code integration part](https://www.youtube.com/watch?v=ds-yEEYP1Ks&t=423s) in this [YouTube video](https://www.youtube.com/watch?v=ds-yEEYP1Ks).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [i18next](https://www.i18next.com), [Vue.js localization](https://i18next.github.io/i18next-vue/) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"vue","slug":"vue","permalink":"https://locize.com/blog/tags/vue/"},{"name":"i18next-vue","slug":"i18next-vue","permalink":"https://locize.com/blog/tags/i18next-vue/"}]},{"title":"How to grow your online business by magnitudes","slug":"grow-online-business","date":"un22fin22","updated":"un55fin55","comments":true,"path":"grow-online-business/","link":"","permalink":"https://locize.com/blog/grow-online-business/","excerpt":"","text":"There are a lot of tips out there that tells you how to best grow your online business. You may have heard about: develop a unique brand deliver high-quality content be mobile-friendly integrate social media diversify your operation take advantage of free marketing tools network with complementary businesses optimize your SEO strategy build an online community etc.. But most ignore an important topic that has a lot of potential. It may seem obvious, but the topic is localization. Usually, an online business starts in a particular geographic region or is not at all bound to a region and offers everything in English. So basically it starts with one language only. Now think about offering your content in other languages? Starting by your website... Do you think this is not relevant? Ok, then take this article for example. According to it 40% of consumers have said that they will never purchase from a website that wasn’t in their native language. While 75% have said that they would be more likely to use a business again if their aftersales care was in their native language. Effective localization will ensure that your product is not only meeting the requirements of your chosen demographics, but also helping you to reach new audiences. With nearly five billion smartphone users in the world, the localization of apps and websites ensures that your product can be enjoyed by customers no matter where they might be located. So basically, you will not add or change any feature. You just take what you have and offer it in a couple more different languages. To give you an idea, here the top 10 most spoken languages in the world: Chinese — 1.3 Billion Native Speakers Spanish — 471 Million Native Speakers English — 370 Million Native Speakers Hindi — 342 Million Native Speakers Arabic — 315 Million Native Speakers Portuguese — 232 Million Native Speakers Bengali — 229 Million Native Speakers Russian — 154 Million Native Speakers Japanese — 126 Million Native Speakers Lahnda (Western Punjabi) — 118 Million Native Speakers When we count the top 10 most spoken languages according to the total number of people who speak them (whether or not the language is their mother tongue), it looks slightly different: English — 1.348 billion total speakers Mandarin Chinese — 1.120 billion total speakers Hindi — 600 million total speakers Spanish — 543 million total speakers Standard Arabic — 274 million total speakers Bengali — 268 million total speakers French — 267 million total speakers Russian — 258 million total speakers Portuguese — 258 million total speakers Urdu — 230 million total speakers A little mind experiment: What would happen if you would offer your website and product also in Chinese, Hindi and Spanish, beside English? You would target an additional audience of 2.266 billion speakers. This makes a potential growth of 268%! If you think that it would now make sense to offer your offering in other languages, then take a look at these other articles: Localization strategy - How to treat customers What is localization - definition &amp; examples Globalization vs. Localization - What is the difference These are the website internationalization best practices App localization Guide - localize mobile apps The key pieces to localize your software project","raw":"---\ntitle: How to grow your online business by magnitudes\ndescription: A simple secret that helps you to grow your online business.\n\ndate: 2022-05-03\ntags:\n  - localization\n  - marketing\n  - international strategy\n  - transnational strategy\n  - global localization\n\nthumbnail: grow-online-business/grow-online-business.jpeg\n---\n\n![](grow-online-business.jpeg \"How to grow your online business by magnitudes\")\n\n\nThere are a lot of tips out there that tells you how to best grow your online business.\n\nYou may have heard about:\n- develop a unique brand\n- deliver high-quality content\n- be mobile-friendly\n- integrate social media\n- diversify your operation\n- take advantage of free marketing tools\n- network with complementary businesses\n- optimize your SEO strategy\n- build an online community\n- etc..\n\n>But most ignore an important topic that has a lot of potential.\n\nIt may seem obvious, but the topic is **[localization](../localization/)**.\n\nUsually, an online business starts in a particular geographic region or is not at all bound to a region and offers everything in English.\n<br />\nSo basically it starts with one language only.\n\nNow think about offering your content in other languages? Starting by your [website](../website-internationalization-best-practices/)...\n<br />\n**Do you think this is not relevant?**\n<br />\nOk, then take [this article](https://insights.csa-research.com/reportaction/305013126/Marketing) for example. According to it 40% of consumers have said that they will never purchase from a website that wasn’t in their native language. While 75% have said that they would be more likely to use a business again if their aftersales care was in their native language.\n\nEffective [localization](../localization/) will ensure that your product is not only meeting the requirements of your chosen demographics, but also helping you to reach new audiences.\n\nWith nearly [five billion smartphone users](https://www.statista.com/statistics/274774/forecast-of-mobile-phone-users-worldwide/) in the world, the [localization of apps](../what-is-mobile-app-localization/) and [websites](../website-internationalization-best-practices/) ensures that your product can be enjoyed by customers no matter where they might be located.\n\nSo basically, you will not add or change any feature. You just take what you have and offer it in a couple more different languages.\n\nTo give you an idea, here the top 10 most spoken languages in the world:\n1. Chinese — 1.3 Billion Native Speakers\n2. Spanish — 471 Million Native Speakers\n3. English — 370 Million Native Speakers\n4. Hindi — 342 Million Native Speakers\n5. Arabic — 315 Million Native Speakers\n6. Portuguese — 232 Million Native Speakers\n7. Bengali — 229 Million Native Speakers\n8. Russian — 154 Million Native Speakers\n9. Japanese — 126 Million Native Speakers\n10. Lahnda (Western Punjabi) — 118 Million Native Speakers\n\n\nWhen we count the top 10 most spoken languages according to the total number of people who speak them (whether or not the language is their mother tongue), it looks slightly different:\n1. English — 1.348 billion total speakers\n2. Mandarin Chinese — 1.120 billion total speakers\n3. Hindi — 600 million total speakers\n4. Spanish — 543 million total speakers\n5. Standard Arabic — 274 million total speakers\n6. Bengali — 268 million total speakers\n7. French — 267 million total speakers\n8. Russian — 258 million total speakers\n9. Portuguese — 258 million total speakers\n10. Urdu — 230 million total speakers\n\n**A little mind experiment:** *What would happen if you would offer your website and product also in Chinese, Hindi and Spanish, beside English?*\n\nYou would target an additional audience of 2.266 billion speakers.\nThis makes a potential growth of **268%**!\n\n\nIf you think that it would now make sense to offer your offering in other languages, then take a look at these other articles:\n\n[**Localization strategy - How to treat customers**](../localization-strategy/)\n[![](../localization-strategy/localization-strategy.webp \"Localization strategy - How to treat customers\")](../localization-strategy/)\n\n[**What is localization - definition & examples**](../localization/)\n[![](../localization/localization.webp \"What is localization - definition & examples\")](../localization/)\n\n[**Globalization vs. Localization - What is the difference**](../globalization-vs-localization/)\n[![](../globalization-vs-localization/globalization-vs-localization.webp \"Globalization vs. Localization - What is the difference\")](../globalization-vs-localization/)\n\n[**These are the website internationalization best practices**](../website-internationalization-best-practices/)\n[![](../website-internationalization-best-practices/website-internationalization-best-practices.webp \"These are the website internationalization best practices\")](../website-internationalization-best-practices/)\n\n[**App localization Guide - localize mobile apps**](../what-is-mobile-app-localization/)\n[![](../what-is-mobile-app-localization/what-is-mobile-app-localization.webp \"App localization Guide - localize mobile apps\")](../what-is-mobile-app-localization/)\n\n[**The key pieces to localize your software project**](../i18n-l10n-t9n-tms/)\n[![](../i18n-l10n-t9n-tms/puzzle.png \"The key pieces to localize your software project\")](../i18n-l10n-t9n-tms/)\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"},{"name":"marketing","slug":"marketing","permalink":"https://locize.com/blog/tags/marketing/"},{"name":"transnational strategy","slug":"transnational-strategy","permalink":"https://locize.com/blog/tags/transnational-strategy/"}]},{"title":"Beam your Svelte internationalization up to a new level❕ (a svelte-i18n guide)","slug":"svelte-i18n","date":"un22fin22","updated":"un66fin66","comments":true,"path":"svelte-i18n/","link":"","permalink":"https://locize.com/blog/svelte-i18n/","excerpt":"","text":"It’s joyful to work with Svelte. The design is elegant and the robust first-party additions which can be coupled with, make building browser apps a pleasure. The most famous i18n plugin for the progressive JavaScript framework Svelte is probably svelte-i18n. Christian Kaisermann, thank you for this great i18n plugin! In this tutorial, we will add additional superpowers to svelte-i18n 😉 TOC So how does a basic svelte-i18n setup look like? Let&#39;s get into it... Is it possible to make a svelte-18n setup even better? Prerequisites Getting started Language Switcher Where are the additional superpowers? How does this look like? save missing translations in context editing 👀 but there&#39;s more... 🎉🥳 Congratulations 🎊🎁 So how does a basic svelte-i18n setup look like? Let&#39;s get into it...Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic Svelte, before jumping to svelte-i18n. Getting started Take your own Svelte project or create a new one. Let&#39;s install the svelte-i18n dependency: npm install svelte-i18n Create a i18n.js file: 12345678910111213141516171819202122232425import &#123; addMessages, init, getLocaleFromNavigator &#125; from &#x27;svelte-i18n&#x27;;const fallbackLocale = &#x27;en&#x27;;const lngs = [fallbackLocale, &#x27;de&#x27;];addMessages(&#x27;en&#x27;, &#123; welcome: &#x27;Welcome to Your Svelte App&#x27;&#125;);addMessages(&#x27;de&#x27;, &#123; welcome: &#x27;Willkommen zu deiner Svelte-App&#x27;&#125;);let initialLocale;const detectedLocale = getLocaleFromNavigator(); // the locale could be region specific, i.e. de-CHif (lngs.indexOf(detectedLocale) &gt; -1) initialLocale = detectedLocale;if (!initialLocale &amp;&amp; detectedLocale.indexOf(&#x27;-&#x27;) &gt; 0) &#123; const foundLng = lngs.find((l) =&gt; detectedLocale.indexOf(l + &#x27;-&#x27;) === 0); if (foundLng) initialLocale = foundLng;&#125;if (!initialLocale) initialLocale = fallbackLocale;init(&#123; fallbackLocale, initialLocale&#125;); Import the i18n.js file, in your main.js file: 12345678910import App from &#x27;./App.svelte&#x27;;import &#x27;./i18n&#x27;;const app = new App(&#123; target: document.body, props: &#123;&#125;&#125;);export default app; Now let&#39;s try to use our first internationalized text. In your template import _ from svelte-i18n and use it like this: 12345678&lt;script&gt; import &#123; _ &#125; from &#x27;svelte-i18n&#x27;;&lt;/script&gt;&lt;main&gt; &lt;img alt=&quot;svelte logo&quot; src=&quot;img/svelte-logo.png&quot; /&gt; &lt;h1&gt;&#123;$_(&#x27;welcome&#x27;)&#125;&lt;/h1&gt;&lt;/main&gt; Nice! Now let&#39;s add another text element... 123456789&lt;script&gt; import &#123; _ &#125; from &#x27;svelte-i18n&#x27;;&lt;/script&gt;&lt;main&gt; &lt;img alt=&quot;svelte logo&quot; src=&quot;img/svelte-logo.png&quot; /&gt; &lt;h1&gt;&#123;$_(&#x27;welcome&#x27;)&#125;&lt;/h1&gt; &lt;p&gt;&#123;@html $_(&#x27;descr&#x27;, &#123; values: &#123; link: `&lt;a href=&quot;https://svelte.dev/tutorial&quot; target=&quot;_blank&quot;&gt;$&#123;$_(&#x27;doc&#x27;)&#125;&lt;/a&gt;` &#125; &#125;)&#125;&lt;/p&gt;&lt;/main&gt; And the corresponding translations: 12345678910addMessages(&#x27;en&#x27;, &#123; welcome: &#x27;Welcome to Your Svelte App&#x27;, descr: &#x27;Visit the &#123;link&#125; to learn how to build Svelte apps.&#x27;, doc: &#x27;Svelte tutorial&#x27;&#125;);addMessages(&#x27;de&#x27;, &#123; welcome: &#x27;Willkommen zu deiner Svelte-App&#x27;, descr: &#x27;Besuchen Sie den &#123;link&#125;, um zu erfahren, wie Sie Svelte-Apps erstellen.&#x27;, doc: &#x27;Svelte Tutorial&#x27;&#125;); Now, depending on your browser language you should see something like this: Language Switcher Now we will create a language switcher to make the content change between different languages. 1234567891011121314&lt;script&gt; import &#123; _, locale, locales &#125; from &#x27;svelte-i18n&#x27;;&lt;/script&gt;&lt;main&gt; &lt;img alt=&quot;svelte logo&quot; src=&quot;img/svelte-logo.png&quot; /&gt; &lt;h1&gt;&#123;$_(&#x27;welcome&#x27;)&#125;&lt;/h1&gt; &lt;p&gt;&#123;@html $_(&#x27;descr&#x27;, &#123; values: &#123; link: `&lt;a href=&quot;https://svelte.dev/tutorial&quot; target=&quot;_blank&quot;&gt;$&#123;$_(&#x27;doc&#x27;)&#125;&lt;/a&gt;` &#125; &#125;)&#125;&lt;/p&gt; &lt;select bind:value=&#123;$locale&#125;&gt; &#123;#each $locales as locale&#125; &lt;option value=&#123;locale&#125;&gt;&#123;locale&#125;&lt;/option&gt; &#123;/each&#125; &lt;/select&gt;&lt;/main&gt; And we will store the current chosen language in the localStorage: 123456789101112131415161718192021222324252627282930313233import &#123; addMessages, init, getLocaleFromNavigator, locale &#125; from &#x27;svelte-i18n&#x27;;const fallbackLocale = &#x27;en&#x27;;const lngs = [fallbackLocale, &#x27;de&#x27;];addMessages(&#x27;en&#x27;, &#123; welcome: &#x27;Welcome to Your Svelte App&#x27;, descr: &#x27;Visit the &#123;link&#125; to learn how to build Svelte apps.&#x27;, doc: &#x27;Svelte tutorial&#x27;&#125;);addMessages(&#x27;de&#x27;, &#123; welcome: &#x27;Willkommen zu deiner Svelte-App&#x27;, descr: &#x27;Besuchen Sie den &#123;link&#125;, um zu erfahren, wie Sie Svelte-Apps erstellen.&#x27;, doc: &#x27;Svelte Tutorial&#x27;&#125;);locale.subscribe((lng) =&gt; &#123; if (lng) localStorage.setItem(&#x27;svelte-i18n-locale&#x27;, lng);&#125;);let initialLocale;const detectedLocale = localStorage.getItem(&#x27;svelte-i18n-locale&#x27;) || getLocaleFromNavigator(); // the locale could be region specific, i.e. de-CHif (lngs.indexOf(detectedLocale) &gt; -1) initialLocale = detectedLocale;if (!initialLocale &amp;&amp; detectedLocale.indexOf(&#x27;-&#x27;) &gt; 0) &#123; const foundLng = lngs.find((l) =&gt; detectedLocale.indexOf(l + &#x27;-&#x27;) === 0); if (foundLng) initialLocale = foundLng;&#125;if (!initialLocale) initialLocale = fallbackLocale;init(&#123; fallbackLocale, initialLocale&#125;); 🥳 Awesome, you&#39;ve just created your first language switcher! Where are the additional superpowers? Let&#39;s meet locizer... locizer is a lightweight module to access data from your locize project and use that inside your application. What is locize? How does this look like? First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by importing the individual json files or via API or by using the CLI. Having the translations in your code file works, but is not that suitable to work with, for translators. Using locize separates the translations from the code. Having imported all translations should look like this: Done so, we&#39;re going to install locizer. npm install locizer Let&#39;s adapt the i18n.js file: 12345678910111213141516171819202122232425262728293031323334353637import &#123; register, init, getLocaleFromNavigator, locale &#125; from &#x27;svelte-i18n&#x27;;import locizer from &#x27;locizer&#x27;;const fallbackLocale = &#x27;en&#x27;;const lngs = [fallbackLocale, &#x27;de&#x27;];const namespace = &#x27;messages&#x27;; // your namespace name added in locizelocizer.init(&#123; projectId: &#x27;your-locize-project-id&#x27;&#125;);lngs.forEach((l) =&gt; &#123; register(l, () =&gt; new Promise((resolve, reject) =&gt; &#123; locizer.load(namespace, l, (err, ns) =&gt; &#123; if (err) return reject(err); resolve(ns); &#125;); &#125;));&#125;)locale.subscribe((lng) =&gt; &#123; if (lng) localStorage.setItem(&#x27;svelte-i18n-locale&#x27;, lng);&#125;);let initialLocale;const detectedLocale = localStorage.getItem(&#x27;svelte-i18n-locale&#x27;) || getLocaleFromNavigator();if (lngs.indexOf(detectedLocale) &gt; -1) initialLocale = detectedLocale;if (!initialLocale &amp;&amp; detectedLocale.indexOf(&#x27;-&#x27;) &gt; 0) &#123; const foundLng = lngs.find((l) =&gt; detectedLocale.indexOf(l + &#x27;-&#x27;) === 0); if (foundLng) initialLocale = foundLng;&#125;if (!initialLocale) initialLocale = fallbackLocale;init(&#123; fallbackLocale, initialLocale&#125;); Since the translations are now loaded asynchronous, we may also want to show a loading message until the translations are ready: 1234567891011121314151617181920&lt;script&gt; import &#123; isLoading, _, locale, locales &#125; from &#x27;svelte-i18n&#x27;;&lt;/script&gt;&lt;main&gt; &lt;img alt=&quot;svelte logo&quot; src=&quot;img/svelte-logo.png&quot; /&gt; &#123;#if $isLoading&#125; &lt;p&gt; loading translations... &lt;/p&gt; &#123;:else&#125; &lt;h1&gt;&#123;$_(&#x27;welcome&#x27;)&#125;&lt;/h1&gt; &lt;p&gt;&#123;@html $_(&#x27;descr&#x27;, &#123; values: &#123; link: `&lt;a href=&quot;https://svelte.dev/tutorial&quot; target=&quot;_blank&quot;&gt;$&#123;$_(&#x27;doc&#x27;)&#125;&lt;/a&gt;` &#125; &#125;)&#125;&lt;/p&gt; &lt;select bind:value=&#123;$locale&#125;&gt; &#123;#each $locales as locale&#125; &lt;option value=&#123;locale&#125;&gt;&#123;locale&#125;&lt;/option&gt; &#123;/each&#125; &lt;/select&gt; &#123;/if&#125;&lt;/main&gt; Now your translations are fetched directly from locize CDN. 🙀 This means you can fix translations without having to change your code or redeploy your app. 🤩 save missing translations I wish newly added keys in the code, would automatically be saved to locize. Your wish is my command! Extend the i18n.js file with the locize api-key and the handleMissingMessage function: 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; register, init, getLocaleFromNavigator, locale &#125; from &#x27;svelte-i18n&#x27;;import locizer from &#x27;locizer&#x27;;const fallbackLocale = &#x27;en&#x27;;const lngs = [fallbackLocale, &#x27;de&#x27;];const namespace = &#x27;messages&#x27;;const apiKey = &#x27;my-api-key&#x27;; // do not expose your API-Key in productionlocizer.init(&#123; projectId: &#x27;your-locize-project-id&#x27;, apiKey&#125;);lngs.forEach((l) =&gt; &#123; register(l, () =&gt; new Promise((resolve, reject) =&gt; &#123; locizer.load(namespace, l, (err, ns) =&gt; &#123; if (err) return reject(err); resolve(ns); &#125;); &#125;));&#125;)locale.subscribe((lng) =&gt; &#123; if (lng) localStorage.setItem(&#x27;svelte-i18n-locale&#x27;, lng);&#125;);let initialLocale;const detectedLocale = localStorage.getItem(&#x27;svelte-i18n-locale&#x27;) || getLocaleFromNavigator();if (lngs.indexOf(detectedLocale) &gt; -1) initialLocale = detectedLocale;if (!initialLocale &amp;&amp; detectedLocale.indexOf(&#x27;-&#x27;) &gt; 0) &#123; const foundLng = lngs.find((l) =&gt; detectedLocale.indexOf(l + &#x27;-&#x27;) === 0); if (foundLng) initialLocale = foundLng;&#125;if (!initialLocale) initialLocale = fallbackLocale;init(&#123; fallbackLocale, initialLocale, handleMissingMessage: apiKey ? (&#123; locale, id, defaultValue &#125;) =&gt; &#123; if (locale !== locizer.referenceLng) return; locizer.add(namespace, id, defaultValue); &#125; : undefined&#125;); Now, if you add a new key in your templates, &lt;h2&gt;&#123;$_(&#39;howAreYou&#39;, &#123; default: &#39;How are you?&#39; &#125;)&#125;&lt;/h2&gt;: 123456789101112131415161718192021&lt;script&gt; import &#123; isLoading, _, locale, locales &#125; from &#x27;svelte-i18n&#x27;;&lt;/script&gt;&lt;main&gt; &lt;img alt=&quot;svelte logo&quot; src=&quot;img/svelte-logo.png&quot; /&gt; &#123;#if $isLoading&#125; &lt;p&gt; loading translations... &lt;/p&gt; &#123;:else&#125; &lt;h1&gt;&#123;$_(&#x27;welcome&#x27;)&#125;&lt;/h1&gt; &lt;h2&gt;&#123;$_(&#x27;howAreYou&#x27;, &#123; default: &#x27;How are you?&#x27; &#125;)&#125;&lt;/h2&gt; &lt;p&gt;&#123;@html $_(&#x27;descr&#x27;, &#123; values: &#123; link: `&lt;a href=&quot;https://svelte.dev/tutorial&quot; target=&quot;_blank&quot;&gt;$&#123;$_(&#x27;doc&#x27;)&#125;&lt;/a&gt;` &#125; &#125;)&#125;&lt;/p&gt; &lt;select bind:value=&#123;$locale&#125;&gt; &#123;#each $locales as locale&#125; &lt;option value=&#123;locale&#125;&gt;&#123;locale&#125;&lt;/option&gt; &#123;/each&#125; &lt;/select&gt; &#123;/if&#125;&lt;/main&gt; It gets automatically saved to locize: Lastly, with the help of the auto-machinetranslation workflow, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation: Check out this video to see how the automatic machine translation workflow looks like! in context editing There&#39;s another cool think we can do... Let&#39;s install locize: npm install locize 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; register, init, getLocaleFromNavigator, locale &#125; from &#x27;svelte-i18n&#x27;;import locizer from &#x27;locizer&#x27;;import &#123; addLocizeSavedHandler &#125; from &#x27;locize&#x27;;const fallbackLocale = &#x27;en&#x27;;const lngs = [fallbackLocale, &#x27;de&#x27;];const namespace = &#x27;messages&#x27;;const apiKey = &#x27;my-api-key&#x27;; // do not expose your API-Key in productionlocizer.init(&#123; projectId: &#x27;your-locize-project-id&#x27;, apiKey&#125;);lngs.forEach((l) =&gt; &#123; register(l, () =&gt; new Promise((resolve, reject) =&gt; &#123; locizer.load(namespace, l, (err, ns) =&gt; &#123; if (err) return reject(err); resolve(ns); &#125;); &#125;));&#125;)locale.subscribe((lng) =&gt; &#123; if (lng) localStorage.setItem(&#x27;svelte-i18n-locale&#x27;, lng);&#125;);let initialLocale;const detectedLocale = localStorage.getItem(&#x27;svelte-i18n-locale&#x27;) || getLocaleFromNavigator();if (lngs.indexOf(detectedLocale) &gt; -1) initialLocale = detectedLocale;if (!initialLocale &amp;&amp; detectedLocale.indexOf(&#x27;-&#x27;) &gt; 0) &#123; const foundLng = lngs.find((l) =&gt; detectedLocale.indexOf(l + &#x27;-&#x27;) === 0); if (foundLng) initialLocale = foundLng;&#125;if (!initialLocale) initialLocale = fallbackLocale;init(&#123; fallbackLocale, initialLocale, handleMissingMessage: apiKey ? (&#123; locale, id, defaultValue &#125;) =&gt; &#123; if (locale !== locizer.referenceLng) return; locizer.add(namespace, id, defaultValue); &#125; : undefined&#125;);addLocizeSavedHandler(() =&gt; location.reload()); Now open the locize InContext Editor and be amazed: 👀 but there&#39;s more... Caching: Merging versions: 🧑‍💻 The code can be found here. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about Svelte localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try locize. 👍","raw":"---\ntitle: Beam your Svelte internationalization up to a new level❕ (a svelte-i18n guide)\ndescription: Simple Svelte localization made easy with this ✅step-by-step guide using svelte-i18n.\n\ndate: 2022-04-05\ntags:\n  - svelte\n  - svelte-i18n\n  - i18n\n  - l10n\n  - locize\n  - localization\n  - internationalization\n  - translation\nthumbnail: svelte-i18n/svelte-i18n.jpg\n\nlabel: svelte-i18n\nlang: en\n---\n\n![](svelte-i18n.jpg \"locize © inweso GmbH\")\n\nIt’s joyful to work with [Svelte](https://svelte.dev). The design is elegant and the robust first-party additions which can be coupled with, make building browser apps a pleasure.\n\nThe most famous i18n plugin for the progressive JavaScript framework [Svelte](https://svelte.dev) is probably [svelte-i18n](https://github.com/kaisermann/svelte-i18n).\n\n>[Christian Kaisermann](https://kaisermann.me), thank you for this great i18n plugin!\n\nIn this tutorial, we will add additional superpowers to [svelte-i18n](https://github.com/kaisermann/svelte-i18n) 😉\n\n![](svelte-i18n-stats.jpg \"locize © inweso GmbH\")\n\n## TOC\n  * [So how does a basic svelte-i18n setup look like? Let's get into it...](#start)\n  * [Is it possible to make a svelte-18n setup even better?](#svelte-i18n-better)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [Where are the additional superpowers?](#superpowers)\n    - [How does this look like?](#how-look)\n    - [save missing translations](#save-missing)\n    - [in context editing](#in-context)\n    - [👀 but there's more...](#more)\n    - [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n## So how does a basic svelte-i18n setup look like? <a name=\"start\"></a>\n## Let's get into it...\n\n## Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic Svelte, before jumping to [svelte-i18n](https://github.com/kaisermann/svelte-i18n).\n\n## Getting started <a name=\"getting-started\"></a>\n\nTake your own Svelte project or create a [new one](https://svelte.dev/blog/the-easiest-way-to-get-started).\n\nLet's install the svelte-i18n dependency:\n\n`npm install svelte-i18n`\n\nCreate a `i18n.js` file:\n\n```javascript\nimport { addMessages, init, getLocaleFromNavigator } from 'svelte-i18n';\n\nconst fallbackLocale = 'en';\nconst lngs = [fallbackLocale, 'de'];\n\naddMessages('en', {\n  welcome: 'Welcome to Your Svelte App'\n});\naddMessages('de', {\n  welcome: 'Willkommen zu deiner Svelte-App'\n});\n\nlet initialLocale;\nconst detectedLocale = getLocaleFromNavigator(); // the locale could be region specific, i.e. de-CH\nif (lngs.indexOf(detectedLocale) > -1) initialLocale = detectedLocale;\nif (!initialLocale && detectedLocale.indexOf('-') > 0) {\n  const foundLng = lngs.find((l) => detectedLocale.indexOf(l + '-') === 0);\n  if (foundLng) initialLocale = foundLng;\n}\nif (!initialLocale) initialLocale = fallbackLocale;\n\ninit({\n  fallbackLocale,\n  initialLocale\n});\n```\n\nImport the `i18n.js` file, in your `main.js` file:\n\n```javascript\nimport App from './App.svelte';\n\nimport './i18n';\n\nconst app = new App({\n  target: document.body,\n  props: {}\n});\n\nexport default app;\n```\n\nNow let's try to use our first internationalized text.\nIn your template import `_` from `svelte-i18n` and use it like this:\n\n```javascript\n<script>\n  import { _ } from 'svelte-i18n';\n</script>\n\n<main>\n  <img alt=\"svelte logo\" src=\"img/svelte-logo.png\" />\n  <h1>{$_('welcome')}</h1>\n</main>\n```\n\nNice! Now let's add another text element...\n\n```javascript\n<script>\n  import { _ } from 'svelte-i18n';\n</script>\n\n<main>\n  <img alt=\"svelte logo\" src=\"img/svelte-logo.png\" />\n  <h1>{$_('welcome')}</h1>\n  <p>{@html $_('descr', { values: { link: `<a href=\"https://svelte.dev/tutorial\" target=\"_blank\">${$_('doc')}</a>` } })}</p>\n</main>\n```\n\nAnd the corresponding translations:\n\n```javascript\naddMessages('en', {\n  welcome: 'Welcome to Your Svelte App',\n  descr: 'Visit the {link} to learn how to build Svelte apps.',\n  doc: 'Svelte tutorial'\n});\naddMessages('de', {\n  welcome: 'Willkommen zu deiner Svelte-App',\n  descr: 'Besuchen Sie den {link}, um zu erfahren, wie Sie Svelte-Apps erstellen.',\n  doc: 'Svelte Tutorial'\n});\n```\n\nNow, depending on your browser language you should see something like this:\n\n![](app_0.jpg \"locize © inweso GmbH\")\n\n\n## Language Switcher <a name=\"language-switcher\"></a>\n\nNow we will create a language switcher to make the content change between different languages.\n\n```javascript\n<script>\n  import { _, locale, locales } from 'svelte-i18n';\n</script>\n\n<main>\n  <img alt=\"svelte logo\" src=\"img/svelte-logo.png\" />\n  <h1>{$_('welcome')}</h1>\n  <p>{@html $_('descr', { values: { link: `<a href=\"https://svelte.dev/tutorial\" target=\"_blank\">${$_('doc')}</a>` } })}</p>\n  <select bind:value={$locale}>\n    {#each $locales as locale}\n      <option value={locale}>{locale}</option>\n    {/each}\n  </select>\n</main>\n```\n\nAnd we will store the current chosen language in the localStorage:\n\n```javascript\nimport { addMessages, init, getLocaleFromNavigator, locale } from 'svelte-i18n';\n\nconst fallbackLocale = 'en';\nconst lngs = [fallbackLocale, 'de'];\n\naddMessages('en', {\n  welcome: 'Welcome to Your Svelte App',\n  descr: 'Visit the {link} to learn how to build Svelte apps.',\n  doc: 'Svelte tutorial'\n});\naddMessages('de', {\n  welcome: 'Willkommen zu deiner Svelte-App',\n  descr: 'Besuchen Sie den {link}, um zu erfahren, wie Sie Svelte-Apps erstellen.',\n  doc: 'Svelte Tutorial'\n});\n\nlocale.subscribe((lng) => {\n  if (lng) localStorage.setItem('svelte-i18n-locale', lng);\n});\n\nlet initialLocale;\nconst detectedLocale = localStorage.getItem('svelte-i18n-locale') || getLocaleFromNavigator(); // the locale could be region specific, i.e. de-CH\nif (lngs.indexOf(detectedLocale) > -1) initialLocale = detectedLocale;\nif (!initialLocale && detectedLocale.indexOf('-') > 0) {\n  const foundLng = lngs.find((l) => detectedLocale.indexOf(l + '-') === 0);\n  if (foundLng) initialLocale = foundLng;\n}\nif (!initialLocale) initialLocale = fallbackLocale;\n\ninit({\n  fallbackLocale,\n  initialLocale\n});\n```\n\n![](app_1.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\n## Where are the additional superpowers? <a name=\"superpowers\"></a>\n\nLet's meet [locizer](https://github.com/locize/locizer)...\n\n[locizer](https://github.com/locize/locizer) is a lightweight module to access data from your [locize](https://www.locize.com) project and use that inside your application.\n\n> [What is locize?](../react-i18next/#for-sure)\n\n### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations) or by using the [CLI](https://github.com/locize/locize-cli).\n\nHaving the translations in your code file works, but is not that suitable to work with, for translators.\nUsing locize separates the translations from the code.\n\nHaving imported all translations should look like this:\n![](locize_imported.jpg \"locize © inweso GmbH\")\n\nDone so, we're going to install [locizer](https://github.com/locize/locizer).\n\n`npm install locizer`\n\nLet's adapt the `i18n.js` file:\n\n```javascript\nimport { register, init, getLocaleFromNavigator, locale } from 'svelte-i18n';\nimport locizer from 'locizer';\n\nconst fallbackLocale = 'en';\nconst lngs = [fallbackLocale, 'de'];\nconst namespace = 'messages'; // your namespace name added in locize\n\nlocizer.init({\n  projectId: 'your-locize-project-id'\n});\n\nlngs.forEach((l) => {\n  register(l, () => new Promise((resolve, reject) => {\n    locizer.load(namespace, l, (err, ns) => {\n      if (err) return reject(err);\n      resolve(ns);\n    });\n  }));\n})\n\nlocale.subscribe((lng) => {\n  if (lng) localStorage.setItem('svelte-i18n-locale', lng);\n});\n\nlet initialLocale;\nconst detectedLocale = localStorage.getItem('svelte-i18n-locale') || getLocaleFromNavigator();\nif (lngs.indexOf(detectedLocale) > -1) initialLocale = detectedLocale;\nif (!initialLocale && detectedLocale.indexOf('-') > 0) {\n  const foundLng = lngs.find((l) => detectedLocale.indexOf(l + '-') === 0);\n  if (foundLng) initialLocale = foundLng;\n}\nif (!initialLocale) initialLocale = fallbackLocale;\n\ninit({\n  fallbackLocale,\n  initialLocale\n});\n```\n\nSince the translations are now loaded asynchronous, we may also want to show a loading message until the translations are ready:\n\n```javascript\n<script>\n  import { isLoading, _, locale, locales } from 'svelte-i18n';\n</script>\n\n<main>\n  <img alt=\"svelte logo\" src=\"img/svelte-logo.png\" />\n  {#if $isLoading}\n    <p>\n      loading translations...\n    </p>\n  {:else}\n    <h1>{$_('welcome')}</h1>\n    <p>{@html $_('descr', { values: { link: `<a href=\"https://svelte.dev/tutorial\" target=\"_blank\">${$_('doc')}</a>` } })}</p>\n    <select bind:value={$locale}>\n      {#each $locales as locale}\n        <option value={locale}>{locale}</option>\n      {/each}\n    </select>\n  {/if}\n</main>\n```\n\nNow your translations are fetched directly from [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\n<br />\n🙀 This means you can fix translations without having to change your code or redeploy your app. 🤩\n\n### save missing translations <a name=\"save-missing\"></a>\n\n>I wish newly added keys in the code, would automatically be saved to locize.\n\n**Your wish is my command!**\n\nExtend the `i18n.js` file with the locize api-key and the `handleMissingMessage` function:\n\n```javascript\nimport { register, init, getLocaleFromNavigator, locale } from 'svelte-i18n';\nimport locizer from 'locizer';\n\nconst fallbackLocale = 'en';\nconst lngs = [fallbackLocale, 'de'];\nconst namespace = 'messages';\nconst apiKey = 'my-api-key'; // do not expose your API-Key in production\n\nlocizer.init({\n  projectId: 'your-locize-project-id',\n  apiKey\n});\n\nlngs.forEach((l) => {\n  register(l, () => new Promise((resolve, reject) => {\n    locizer.load(namespace, l, (err, ns) => {\n      if (err) return reject(err);\n      resolve(ns);\n    });\n  }));\n})\n\nlocale.subscribe((lng) => {\n  if (lng) localStorage.setItem('svelte-i18n-locale', lng);\n});\n\nlet initialLocale;\nconst detectedLocale = localStorage.getItem('svelte-i18n-locale') || getLocaleFromNavigator();\nif (lngs.indexOf(detectedLocale) > -1) initialLocale = detectedLocale;\nif (!initialLocale && detectedLocale.indexOf('-') > 0) {\n  const foundLng = lngs.find((l) => detectedLocale.indexOf(l + '-') === 0);\n  if (foundLng) initialLocale = foundLng;\n}\nif (!initialLocale) initialLocale = fallbackLocale;\n\ninit({\n  fallbackLocale,\n  initialLocale,\n  handleMissingMessage: apiKey ? ({ locale, id, defaultValue }) => {\n    if (locale !== locizer.referenceLng) return;\n    locizer.add(namespace, id, defaultValue);\n  } : undefined\n});\n```\n\nNow, if you add a new key in your templates, `<h2>{$_('howAreYou', { default: 'How are you?' })}</h2>`:\n\n```javascript\n<script>\n  import { isLoading, _, locale, locales } from 'svelte-i18n';\n</script>\n\n<main>\n  <img alt=\"svelte logo\" src=\"img/svelte-logo.png\" />\n  {#if $isLoading}\n    <p>\n      loading translations...\n    </p>\n  {:else}\n    <h1>{$_('welcome')}</h1>\n    <h2>{$_('howAreYou', { default: 'How are you?' })}</h2>\n    <p>{@html $_('descr', { values: { link: `<a href=\"https://svelte.dev/tutorial\" target=\"_blank\">${$_('doc')}</a>` } })}</p>\n    <select bind:value={$locale}>\n      {#each $locales as locale}\n        <option value={locale}>{locale}</option>\n      {/each}\n    </select>\n  {/if}\n</main>\n```\n\nIt gets automatically saved to locize:\n![](locize_missing.jpg \"locize © inweso GmbH\")\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation:\n![](locize_autotranslate.jpg \"locize © inweso GmbH\")\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see how the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n\n### in context editing <a name=\"in-context\"></a>\n\nThere's another cool think we can do...\n<br />\n\nLet's install [locize](https://github.com/locize/locize):\n\n`npm install locize`\n\n```javascript\nimport { register, init, getLocaleFromNavigator, locale } from 'svelte-i18n';\nimport locizer from 'locizer';\nimport { addLocizeSavedHandler } from 'locize';\n\nconst fallbackLocale = 'en';\nconst lngs = [fallbackLocale, 'de'];\nconst namespace = 'messages';\nconst apiKey = 'my-api-key'; // do not expose your API-Key in production\n\nlocizer.init({\n  projectId: 'your-locize-project-id',\n  apiKey\n});\n\nlngs.forEach((l) => {\n  register(l, () => new Promise((resolve, reject) => {\n    locizer.load(namespace, l, (err, ns) => {\n      if (err) return reject(err);\n      resolve(ns);\n    });\n  }));\n})\n\nlocale.subscribe((lng) => {\n  if (lng) localStorage.setItem('svelte-i18n-locale', lng);\n});\n\nlet initialLocale;\nconst detectedLocale = localStorage.getItem('svelte-i18n-locale') || getLocaleFromNavigator();\nif (lngs.indexOf(detectedLocale) > -1) initialLocale = detectedLocale;\nif (!initialLocale && detectedLocale.indexOf('-') > 0) {\n  const foundLng = lngs.find((l) => detectedLocale.indexOf(l + '-') === 0);\n  if (foundLng) initialLocale = foundLng;\n}\nif (!initialLocale) initialLocale = fallbackLocale;\n\ninit({\n  fallbackLocale,\n  initialLocale,\n  handleMissingMessage: apiKey ? ({ locale, id, defaultValue }) => {\n    if (locale !== locizer.referenceLng) return;\n    locizer.add(namespace, id, defaultValue);\n  } : undefined\n});\n\naddLocizeSavedHandler(() => location.reload());\n```\n\nNow open the locize [InContext Editor](https://docs.locize.com/more/incontext-editor) and be amazed:\n\n![i18n incontext editor](in_context.jpg \"locize © inweso GmbH\")\n\n\n### 👀 but there's more... <a name=\"more\"></a>\n\n[Caching](https://docs.locize.com/more/caching):\n\n![](../react-i18next/caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![](../react-i18next/overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The code can be found [here](https://github.com/locize/locizer/tree/master/example/svelte).*\n\n\n# 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [Svelte localization](https://github.com/kaisermann/svelte-i18n) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth to try [locize](https://locize.com).\n\n\n# 👍","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"svelte","slug":"svelte","permalink":"https://locize.com/blog/tags/svelte/"},{"name":"svelte-i18n","slug":"svelte-i18n","permalink":"https://locize.com/blog/tags/svelte-i18n/"}]},{"title":"All side optimized Next.js translations (a next-i18next guide)","slug":"next-i18next","date":"un00fin00","updated":"un55fin55","comments":true,"path":"next-i18next/","link":"","permalink":"https://locize.com/blog/next-i18next/","excerpt":"","text":"Writing Next.js code blurs the lines between client side and server side. The code is written once and depending on your needs it is then executed as SSG (static-site generation), SSR (server-side rendering) or CSR (client-side rendering), etc. So also the internationalization, right? How to optimize Next.js apps to best work with translations on server side and on client side with next-i18next?If you&#39;re using Next.js 13 with app directory, have a look at this blog post. Let&#39;s take the example of next-i18next. While next-i18next uses i18next and react-i18next under the hood, users of next-i18next simply need to include their translation content as JSON files and don&#39;t have to worry about much else. By default, there is one next-i18next configuration that loads the translations from the local directory structure and renders the pages on server side. This is ok, it works and is optimized for SEO etc. but there is more we could do. What if we could power up the seo optimized website with always up-to-date translations without the need to redeploy your app? We will discuss 2 different setups: One with an active backend and another one completely statically generated. The basic target is always the same: We want everything to be SEO optimized in all languages and serve always the newest translations to our users. Example with a backend server Having a backend server does not mean you are forced to run your own server. It can also be a PaaS or serverless solution, like Vercel or Netlify, etc. Ok, let&#39;s start with the default: You followed the normal next-i18next setup guide and now your translations are organized more or less as such: 1234567.└── public └── locales ├── en | └── common.json └── de └── common.json Now let&#39;s connect to an awesome translation management system and manage your translations outside of your code. Let&#39;s synchronize the translation files with locize. This can be done on-demand or on the CI-Server or before deploying the app. What to do to reach this step: in locize: signup at https://locize.app/register and login in locize: create a new project in locize: add all your additional languages (this can also be done via API) install the locize-cli (npm i locize-cli) Use the locize-cliUse the locize sync command to synchronize your local repository (public/locales) with what is published on locize. Alternatively, you can also use the locize download command to always download the published locize translations to your local repository (public/locales) before bundling your app. But you were talking about having always up-to-date translations without the need to redeploy your app? Yes, let&#39;s adapt for that:We will use the i18next-locize-backend plugin, but only on client side. Together with some other i18next dependencies: i18next-locize-backend i18next-chained-backend i18next-localstorage-backend npm install i18next-locize-backend i18next-chained-backend i18next-localstorage-backend And we adapt the next-i18next.config.js file: 12345678910111213141516171819202122232425// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const ChainedBackend= require(&#x27;i18next-chained-backend&#x27;).defaultconst LocalStorageBackend = require(&#x27;i18next-localstorage-backend&#x27;).defaultconst isBrowser = typeof window !== &#x27;undefined&#x27;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;, &#x27;it&#x27;], &#125;, backend: &#123; backendOptions: [&#123; expirationTime: 60 * 60 * 1000 // 1 hour &#125;, &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, version: &#x27;latest&#x27; &#125;], backends: isBrowser ? [LocalStorageBackend, LocizeBackend] : [], &#125;, serializeConfig: false, use: isBrowser ? [ChainedBackend] : []&#125; Removing the serverSideTranslation to getStaticProps or getServerSideProps (depending on your case) in the page-level components would work, but would not correctly render the server side html. But the client side would be fine. 123456789//// Without the getStaticProps or getServerSideProps function,// the translsations are loaded via configured i18next backend.//// export const getStaticProps = async (&#123; locale &#125;) =&gt; &#123;// return &#123;// props: await serverSideTranslations(locale, [&#x27;common&#x27;, &#x27;footer&#x27;])// &#125;// &#125; This can be optimized by keeping the getServerSideProps or getStaticProps function and making use of the reloadResources functionality of i18next. 123456789101112131415161718192021222324252627282930313233const HomePage = () =&gt; &#123; const &#123; t, i18n &#125; = useTranslation([&#x27;common&#x27;, &#x27;footer&#x27;], &#123; bindI18n: &#x27;languageChanged loaded&#x27; &#125;) // bindI18n: loaded is needed because of the reloadResources call // if all pages use the reloadResources mechanism, the bindI18n option can also be defined in next-i18next.config.js useEffect(() =&gt; &#123; i18n.reloadResources(i18n.resolvedLanguage, [&#x27;common&#x27;, &#x27;footer&#x27;]) &#125;, []) return ( &lt;&gt; &lt;main&gt; &lt;Header heading=&#123;t(&#x27;h1&#x27;)&#125; title=&#123;t(&#x27;title&#x27;)&#125; /&gt; &lt;Link href=&#x27;/&#x27;&gt; &lt;button type=&#x27;button&#x27; &gt; &#123;t(&#x27;back-to-home&#x27;)&#125; &lt;/button&gt; &lt;/Link&gt; &lt;/main&gt; &lt;Footer /&gt; &lt;/&gt; )&#125;export const getStaticProps = async (&#123; locale &#125;) =&gt; (&#123; props: &#123; ...await serverSideTranslations(locale, [&#x27;common&#x27;, &#x27;footer&#x27;]), &#125;,&#125;)export default HomePage This way the ready check is also not necessary, because the translations served directly by the server are used. And as soon the translations are reloaded, new translations are shown. That&#39;s it! Let&#39;s check the result:The HTML returned from the server looks correctly translated. So this is well optimized for search engines. And on client side, the up-to-date translations are directly fetched from the locize CDN. 🙀 This means you can fix translations without having to change your code or redeploy your app. 🤩 🧑‍💻 The code can be found here. Additional hint:If you&#39;ve configured caching for your locize version, you may not need the i18next-localstorage-backend and i18next-chained-backend plugin. 123456789101112131415161718// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const isBrowser = typeof window !== &#x27;undefined&#x27;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;, &#x27;it&#x27;], &#125;, backend: isBrowser ? &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, version: &#x27;production&#x27; &#125; : undefined, serializeConfig: false, use: isBrowser ? [LocizeBackend] : []&#125; Static Website example With this example, we just need a static webserver, like GitHub Pages or similar. It&#39;s pretty much the same as with above example, but there are some little things we need to additionally consider. To work with static-site generation (SSG) we need to use the next export command, but... Error: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment This happens if you&#39;re using the internationalized routing feature and are trying to generate a static HTML export by executing next export. Well, this features requires a Node.js server, or dynamic logic that cannot be computed during the build process, that&#39;s why it is unsupported. There is a dedicated article with a solution to that Next.js problem. Follow that guide first! Done so? Then let&#39;s continue here:It&#39;s the same next-i18next.config.js config like in the previous example: 12345678910111213141516171819202122232425262728// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const ChainedBackend= require(&#x27;i18next-chained-backend&#x27;).defaultconst LocalStorageBackend = require(&#x27;i18next-localstorage-backend&#x27;).default// If you&#x27;ve configured caching for your locize version, you may not need the i18next-localstorage-backend and i18next-chained-backend plugin.// https://docs.locize.com/more/cachingconst isBrowser = typeof window !== &#x27;undefined&#x27;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;, &#x27;it&#x27;], &#125;, backend: &#123; backendOptions: [&#123; expirationTime: 60 * 60 * 1000 // 1 hour &#125;, &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, version: &#x27;latest&#x27; &#125;], backends: isBrowser ? [LocalStorageBackend, LocizeBackend] : [], &#125;, serializeConfig: false, use: isBrowser ? [ChainedBackend] : []&#125; Extend the makeStaticProps function with options (emptyI18nStoreStore): 123456789101112export function makeStaticProps(ns = [], opt = &#123;&#125;) &#123; return async function getStaticProps(ctx) &#123; const props = await getI18nProps(ctx, ns) if (opt.emptyI18nStoreStore) &#123; // let the client fetch the translations props._nextI18Next.initialI18nStore = null &#125; return &#123; props &#125; &#125;&#125; ...and use it accordingly: 12const getStaticProps = makeStaticProps([&#x27;common&#x27;, &#x27;footer&#x27;], &#123; emptyI18nStoreStore: true &#125;)export &#123; getStaticPaths, getStaticProps &#125; That&#39;s it! Let&#39;s check the result:The generated static HTML looks correctly translated. So this is well optimized for search engines. And on client side, the up-to-date translations are directly fetched from the locize CDN. 🙀 This means you can fix translations without having to change your code or redeploy your app. And without owning an active server. 🤩 🧑‍💻 The code can be found here. Continuous LocalizationSince we&#39;re now &quot;connected&quot; to as smart translation management system, we can try to make use of its full potential. save missing translations I wish newly added keys in the code, would automatically be saved to locize. Your wish is my command! Extend the next-i18next config with the locize api-key and set saveMissing: true: 1234567891011121314151617181920// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const isBrowser = typeof window !== &#x27;undefined&#x27;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;], &#125;, backend: &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, apiKey: &#x27;14bbe1fa-6ffc-40f5-9226-7462aa4a042f&#x27;, version: &#x27;latest&#x27; &#125;, serializeConfig: false, use: isBrowser ? [LocizeBackend] : [], saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend&#125; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;div&gt;&#123;t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;)&#125;&lt;/div&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see how the automatic machine translation workflow looks like! npm install locize-lastused locize use them like this: 1234567891011121314151617181920212223// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const isBrowser = typeof window !== &#x27;undefined&#x27;const locizeOptions = &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, apiKey: &#x27;14bbe1fa-6ffc-40f5-9226-7462aa4a042f&#x27;, version: &#x27;latest&#x27;&#125;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;], &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, serializeConfig: false, use: isBrowser ? [LocizeBackend, require(&#x27;locize&#x27;).locizePlugin, require(&#x27;locize-lastused/cjs&#x27;)] : [], // do not use locize-lastused on production saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend&#125; Automatic machine translation: Last used translations filter: InContext Editor: 📦 Let&#39;s prepare for production 🚀 Now, we prepare the app for going to production. First in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via API or via CLI. Lastly, enable Cache-Control max-age​ for that production version. Let&#39;s adapt the next-i18next.config.js file once again: 1234567891011121314151617181920212223// next-i18next.config.jsconst LocizeBackend = require(&#x27;i18next-locize-backend/cjs&#x27;)const isBrowser = typeof window !== &#x27;undefined&#x27;const locizeOptions = &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, apiKey: &#x27;14bbe1fa-6ffc-40f5-9226-7462aa4a042f&#x27;, version: &#x27;latest&#x27;&#125;module.exports = &#123; // debug: true, i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;], &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, serializeConfig: false, use: isBrowser ? [LocizeBackend, require(&#x27;locize&#x27;).locizePlugin, require(&#x27;locize-lastused/cjs&#x27;)] : [], // do not use locize-lastused on production saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend&#125; Now, during development, you&#39;ll continue to save missing keys and to make use of lastused feature. =&gt; npm run dev And in production environment, saveMissing and lastused are disabled. =&gt; npm run build &amp;&amp; npm start Caching: Merging versions: 🧑‍💻 The complete code can be found here. Check also the code integration part in this YouTube video. There&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 Awesome! Thanks to next-i18next, i18next, react-i18next and locize your continuous localization workflow is ready to go. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: All side optimized Next.js translations (a next-i18next guide)\ndescription: Optimize your Next.js app to best work with translations on server side and on client side with next-i18next.\n\ndate: 2022-04-03\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - next-i18next\n  - next\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - translation\nthumbnail: next-i18next/next-i18next.jpg\n\nlabel: next-i18next\nlang: en\n---\n\n![](next-i18next.jpg \"locize © inweso GmbH\")\n\nWriting [Next.js](https://nextjs.org) code blurs the lines between client side and server side.\n<br />\nThe code is written once and depending on your needs it is then executed as SSG (static-site generation), SSR (server-side rendering) or CSR (client-side rendering), etc.\n\n>So also the internationalization, right?\n\n## How to optimize Next.js apps to best work with translations on server side and on client side with next-i18next?\n\n*If you're using Next.js 13 with app directory, have a look at [this blog post](../next-13-app-dir-i18n/).*\n\nLet's take the example of [next-i18next](https://github.com/i18next/next-i18next).\nWhile next-i18next uses [i18next](https://www.i18next.com) and [react-i18next](https://react.i18next.com) under the hood, users of next-i18next simply need to include their translation content as JSON files and don't have to worry about much else.\n\nBy default, there is one [next-i18next configuration](https://github.com/i18next/next-i18next#next-i18nextconfigjs) that loads the translations from the local directory structure and renders the pages on server side.\n<br />\nThis is ok, it works and is optimized for SEO etc. but there is more we could do.\n\nWhat if we could power up the seo optimized website with always up-to-date translations without the need to redeploy your app?\n\nWe will discuss 2 different setups: [One with an active backend](#ssr) and another [one completely statically generated](#ssg).\n\nThe basic target is always the same: We want everything to be SEO optimized in all languages and serve always the newest translations to our users.\n\n## Example with a backend server <a name=\"ssr\"></a>\n\n![](next-build.jpg)\n\nHaving a backend server does not mean you are forced to run your own server. It can also be a PaaS or serverless solution, like [Vercel](https://vercel.com/) or [Netlify](https://www.netlify.com/), etc.\n\nOk, let's start with the default:\n<br />\nYou followed the normal [next-i18next setup guide](https://github.com/i18next/next-i18next#setup) and now your translations are organized more or less as such:\n\n```\n.\n└── public\n    └── locales\n        ├── en\n        |   └── common.json\n        └── de\n            └── common.json\n```\n\nNow let's connect to an awesome translation management system and manage your translations outside of your code.\n\nLet's synchronize the translation files with [locize](https://locize.com).\nThis can be done on-demand or on the CI-Server or before deploying the app.\n\n### What to do to reach this step:\n1. in locize: signup at https://locize.app/register and [login](https://docs.locize.com/integration/getting-started/create-a-user-account)\n2. in locize: [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n3. in locize: add all your additional languages (this can also be done via [API](https://docs.locize.com/integration/api#add-new-language))\n4. install the [locize-cli](https://github.com/locize/locize-cli) (`npm i locize-cli`)\n\n### Use the [locize-cli](https://github.com/locize/locize-cli)\nUse the `locize sync` command to synchronize your local repository (`public/locales`) with what is published on locize.\n\nAlternatively, you can also use the `locize download` command to always download the published locize translations to your local repository (`public/locales`) before bundling your app.\n\n> But you were talking about having always up-to-date translations without the need to redeploy your app?\n\n### Yes, let's adapt for that:\n\nWe will use the [i18next-locize-backend plugin](https://github.com/locize/i18next-locize-backend), but only on client side.\n\nTogether with some other i18next dependencies:\n\n- [i18next-locize-backend](https://github.com/locize/i18next-locize-backend)\n- [i18next-chained-backend](https://github.com/i18next/i18next-chained-backend)\n- [i18next-localstorage-backend](https://github.com/i18next/i18next-localstorage-backend)\n\n`npm install i18next-locize-backend i18next-chained-backend i18next-localstorage-backend`\n\nAnd we adapt the `next-i18next.config.js` file:\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\nconst ChainedBackend= require('i18next-chained-backend').default\nconst LocalStorageBackend = require('i18next-localstorage-backend').default\n\nconst isBrowser = typeof window !== 'undefined'\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de', 'it'],\n  },\n  backend: {\n    backendOptions: [{\n      expirationTime: 60 * 60 * 1000 // 1 hour\n    }, {\n      projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n      version: 'latest'\n    }],\n    backends: isBrowser ? [LocalStorageBackend, LocizeBackend] : [],\n  },\n  serializeConfig: false,\n  use: isBrowser ? [ChainedBackend] : []\n}\n```\n\nRemoving the `serverSideTranslation` to [`getStaticProps`](https://nextjs.org/docs/basic-features/data-fetching/get-static-props) or [`getServerSideProps`](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props) (depending on your case) in the page-level components would work, but would not correctly render the server side html. But the client side would be fine.\n\n```javascript\n//\n// Without the getStaticProps or getServerSideProps function,\n// the translsations are loaded via configured i18next backend.\n//\n// export const getStaticProps = async ({ locale }) => {\n//   return {\n//     props: await serverSideTranslations(locale, ['common', 'footer'])\n//   }\n// }\n```\n\nThis can be optimized by keeping the `getServerSideProps` or `getStaticProps` function and making use of the [`reloadResources`](https://www.i18next.com/overview/api#reloadresources) functionality of i18next.\n\n```javascript\nconst HomePage = () => {\n\n  const { t, i18n } = useTranslation(['common', 'footer'], { bindI18n: 'languageChanged loaded' })\n  // bindI18n: loaded is needed because of the reloadResources call\n  // if all pages use the reloadResources mechanism, the bindI18n option can also be defined in next-i18next.config.js\n  useEffect(() => {\n    i18n.reloadResources(i18n.resolvedLanguage, ['common', 'footer'])\n  }, [])\n\n  return (\n    <>\n      <main>\n        <Header heading={t('h1')} title={t('title')} />\n        <Link href='/'>\n          <button\n            type='button'\n          >\n            {t('back-to-home')}\n          </button>\n        </Link>\n      </main>\n      <Footer />\n    </>\n  )\n}\n\nexport const getStaticProps = async ({ locale }) => ({\n  props: {\n    ...await serverSideTranslations(locale, ['common', 'footer']),\n  },\n})\n\nexport default HomePage\n```\n\nThis way the ready check is also not necessary, because the translations served directly by the server are used. And as soon the translations are reloaded, new translations are shown.\n\n### That's it! Let's check the result:\n\nThe HTML returned from the server looks correctly translated. So this is well optimized for search engines.\n![](ssr-translations.jpg)\n\nAnd on client side, the up-to-date translations are directly fetched from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\n![](client-loading.jpg)\n\n🙀 This means you can fix translations without having to change your code or redeploy your app. 🤩\n\n*🧑‍💻 The code can be found [here](https://github.com/locize/next-i18next-locize).*\n\n\n#### Additional hint:\n\nIf you've configured [caching](https://docs.locize.com/more/caching) for your locize version, you may not need the [i18next-localstorage-backend](https://github.com/i18next/i18next-localstorage-backend) and [i18next-chained-backend](https://github.com/i18next/i18next-chained-backend) plugin.\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\n\nconst isBrowser = typeof window !== 'undefined'\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de', 'it'],\n  },\n  backend: isBrowser ? {\n    projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n    version: 'production'\n  } : undefined,\n  serializeConfig: false,\n  use: isBrowser ? [LocizeBackend] : []\n}\n```\n\n\n## Static Website example <a name=\"ssg\"></a>\n\n![](next-export.jpg)\n\nWith this example, we just need a static webserver, like [GitHub Pages](https://pages.github.com/) or similar.\n\nIt's pretty much the same as with [above example](#ssr), but there are some little things we need to additionally consider.\n\nTo work with static-site generation (SSG) we need to use the `next export` command, but...\n\n>Error: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment\n\nThis happens if you're using the [internationalized routing](https://nextjs.org/docs/advanced-features/i18n-routing) feature and are trying to generate a [static HTML export](https://nextjs.org/docs/advanced-features/static-html-export) by executing `next export`.\nWell, this features requires a Node.js server, or dynamic logic that cannot be computed during the build process, that's why it is [unsupported](https://nextjs.org/docs/advanced-features/static-html-export#unsupported-features).\n\nThere is a [dedicated article](../next-i18n-static/) with a solution to that Next.js problem. [Follow that guide first!](../next-i18n-static/)\n[![](../next-i18n-static/title.jpg)](../next-i18n-static/)\n\n### Done so? Then let's continue here:\n\nIt's the same `next-i18next.config.js` config like in the [previous example](#ssr):\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\nconst ChainedBackend= require('i18next-chained-backend').default\nconst LocalStorageBackend = require('i18next-localstorage-backend').default\n\n// If you've configured caching for your locize version, you may not need the i18next-localstorage-backend and i18next-chained-backend plugin.\n// https://docs.locize.com/more/caching\n\nconst isBrowser = typeof window !== 'undefined'\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de', 'it'],\n  },\n  backend: {\n    backendOptions: [{\n      expirationTime: 60 * 60 * 1000 // 1 hour\n    }, {\n      projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n      version: 'latest'\n    }],\n    backends: isBrowser ? [LocalStorageBackend, LocizeBackend] : [],\n  },\n  serializeConfig: false,\n  use: isBrowser ? [ChainedBackend] : []\n}\n```\n\nExtend the `makeStaticProps` function with options (`emptyI18nStoreStore`):\n\n```javascript\nexport function makeStaticProps(ns = [], opt = {}) {\n  return async function getStaticProps(ctx) {\n    const props = await getI18nProps(ctx, ns)\n    if (opt.emptyI18nStoreStore) {\n      // let the client fetch the translations\n      props._nextI18Next.initialI18nStore = null\n    }\n    return {\n      props\n    }\n  }\n}\n```\n\n...and use it accordingly:\n\n```javascript\nconst getStaticProps = makeStaticProps(['common', 'footer'], { emptyI18nStoreStore: true })\nexport { getStaticPaths, getStaticProps }\n```\n\n### That's it! Let's check the result:\n\nThe generated static HTML looks correctly translated. So this is well optimized for search engines.\n![](ssg-translations.jpg)\n\nAnd on client side, the up-to-date translations are directly fetched from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\n![](client-loading.jpg)\n\n🙀 This means you can fix translations without having to change your code or redeploy your app. And without owning an active server. 🤩\n\n*🧑‍💻 The code can be found [here](https://github.com/i18next/next-language-detector/tree/main/examples/client-loading).*\n\n\n## Continuous Localization\n\nSince we're now \"connected\" to as smart [translation management system](https://lociize.com), we can try to make use of its full potential.\n\n### save missing translations <a name=\"save-missing\"></a>\n\n>I wish newly added keys in the code, would automatically be saved to locize.\n\n**Your wish is my command!**\n\nExtend the next-i18next config with the locize api-key and set `saveMissing: true`:\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\n\nconst isBrowser = typeof window !== 'undefined'\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de'],\n  },\n  backend: {\n    projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n    apiKey: '14bbe1fa-6ffc-40f5-9226-7462aa4a042f',\n    version: 'latest'\n  },\n  serializeConfig: false,\n  use: isBrowser ? [LocizeBackend] : [],\n  saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend\n}\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<div>{t('new.key', 'this will be added automatically')}</div>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation) and the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation.\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see how the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n`npm install locize-lastused locize`\n\nuse them like this:\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst locizeOptions = {\n  projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n  apiKey: '14bbe1fa-6ffc-40f5-9226-7462aa4a042f',\n  version: 'latest'\n}\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de'],\n  },\n  backend: locizeOptions,\n  locizeLastUsed: locizeOptions,\n  serializeConfig: false,\n  use: isBrowser ? [LocizeBackend, require('locize').locizePlugin, require('locize-lastused/cjs')] : [], // do not use locize-lastused on production\n  saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend\n}\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![missing key auto](missing_key_auto_mt.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![i18next last used](last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![i18next incontext](in_context.jpg \"locize © inweso GmbH\")\n\n#### 📦 Let's prepare for production 🚀 <a name=\"production\"></a>\n\nNow, we prepare the app for [going to production](https://docs.locize.com/guides-tips-and-tricks/going-production).\n\nFirst in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via [API](https://docs.locize.com/integration/api#publish-version) or via [CLI](https://github.com/locize/locize-cli#publish-version).\nLastly, [enable Cache-Control max-age​](https://docs.locize.com/more/caching) for that production version.\n\nLet's adapt the `next-i18next.config.js` file once again:\n\n```javascript\n// next-i18next.config.js\nconst LocizeBackend = require('i18next-locize-backend/cjs')\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst locizeOptions = {\n  projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n  apiKey: '14bbe1fa-6ffc-40f5-9226-7462aa4a042f',\n  version: 'latest'\n}\n\nmodule.exports = {\n  // debug: true,\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de'],\n  },\n  backend: locizeOptions,\n  locizeLastUsed: locizeOptions,\n  serializeConfig: false,\n  use: isBrowser ? [LocizeBackend, require('locize').locizePlugin, require('locize-lastused/cjs')] : [], // do not use locize-lastused on production\n  saveMissing: true // do not set saveMissing to true for production and also not when using the chained backend\n}\n```\n\nNow, during development, you'll continue to save missing keys and to make use of lastused feature. => `npm run dev`\n\nAnd in production environment, saveMissing and lastused are disabled. => `npm run build && npm start`\n\n\n[Caching](https://docs.locize.com/more/caching):\n\n![i18next caching](caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/next-i18next-locize).*\n\n*Check also the [code integration part](https://www.youtube.com/watch?v=ds-yEEYP1Ks&t=423s) in this [YouTube video](https://www.youtube.com/watch?v=ds-yEEYP1Ks).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nAwesome! Thanks to [next-i18next](https://github.com/i18next/next-i18next), [i18next](https://www.i18next.com), [react-i18next](https://react.i18next.com) and [locize](https://locize.com) your continuous localization workflow is ready to go.\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"next","slug":"next","permalink":"https://locize.com/blog/tags/next/"},{"name":"next-i18next","slug":"next-i18next","permalink":"https://locize.com/blog/tags/next-i18next/"}]},{"title":"How to internationalize a Remix application (Part 2)","slug":"remix-i18next","date":"un44fin44","updated":"un44fin44","comments":true,"path":"remix-i18next/","link":"","permalink":"https://locize.com/blog/remix-i18next/","excerpt":"","text":"In the previous blog post we learned on a simple way how we can instrumented our Remix app to be ready for localization by using remix-i18next. In this blog post we will try to unleash the full power of i18next and focus on a continuous localization workflow. TOC Better translation management For sure! How does this look like? save missing translations 👀 but there&#39;s more... 📦 Let&#39;s prepare for production 🚀 🎉🥳 Congratulations 🎊🎁 Better translation management In the previous blog post there was a voluntary part. This already was the first step. By sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you. This is a traditional way. But be aware sending files around creates always an overhead. Does a better option exist? For sure! i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? How do you deploy translation changes without deploying your complete application? and a lot more... Looking for something like this❓ Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Profit from our content delivery network (CDN) Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... How does this look like? First, if not already done, you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by using the cli or by importing the individual json files or via API. Done so, we&#39;re going change the way the translations are loaded on server side and on client side. Currently the translations are downloaded from locize via CLI and are then served on server side in the public/locales folder. Thanks to remix-i18next then the translations are downloaded by the client. We now would like the client side to directly consume the translations provided by the locize CDN. Instead on server side we&#39;ll continue to &quot;bundle&quot; the translations first. See downloadLocales script in package.json. We&#39;re doing so to prevent an elevated amount of downloads generated on server side. Read this for more information about this topic about serverless environments. We have to install i18next-locize-backend. npm install i18next-locize-backend Adapt the entry.client.jsx file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import &#123; hydrate &#125; from &#x27;react-dom&#x27;import &#123; RemixBrowser &#125; from &#x27;@remix-run/react&#x27;import i18next from &#x27;i18next&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import &#123; getInitialNamespaces &#125; from &#x27;remix-i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LastUsed from &#x27;locize-lastused&#x27;import &#123; locizePlugin &#125; from &#x27;locize&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;const locizeOptions = &#123; projectId: &#x27;f6d74b76-9677-4a0d-b400-86e1507397ab&#x27;, apiKey: &#x27;1c2bbc21-027d-4f41-995a-e8beb451cdef&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;// initialize i18next using initReactI18next and configuring itif (!i18next.isInitialized) &#123; // prevent i18next to be initialized multiple times i18next // pass the i18n instance to react-i18next. .use(initReactI18next) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; ...i18nextOptions, // This function detects the namespaces your routes rendered while SSR use // and pass them here to load the translations ns: getInitialNamespaces(), detection: &#123; // Here only enable htmlTag detection, we&#x27;ll detect the language only // server-side with remix-i18next, by using the `&lt;html lang&gt;` attribute // we can communicate to the client the language detected server-side order: [&#x27;htmlTag&#x27;], // Because we only use htmlTag, there&#x27;s no reason to cache the language // on the browser, so we disable it caches: [], &#125;, backend: locizeOptions &#125;) .then(() =&gt; &#123; // then hydrate your app return hydrate( &lt;I18nextProvider i18n=&#123;i18next&#125;&gt; &lt;RemixBrowser /&gt; &lt;/I18nextProvider&gt;, document ) &#125;)&#125; The entry.server.jsx file, the root.jsx and the i18nextOptions.js file should still look the same: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;import &#123; RemixServer &#125; from &#x27;remix&#x27;import &#123; createInstance &#125; from &#x27;i18next&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import Backend from &#x27;i18next-fs-backend&#x27;import &#123; resolve &#125; from &#x27;node:path&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;import i18n from &#x27;./i18n.server&#x27;export default async function handleRequest( request, statusCode, headers, context) &#123; // First, we create a new instance of i18next so every request will have a // completely unique instance and not share any state const instance = createInstance() // Then we could detect locale from the request const lng = await i18n.getLocale(request) // And here we detect what namespaces the routes about to render want to use const ns = i18n.getRouteNamespaces(context) // First, we create a new instance of i18next so every request will have a // completely unique instance and not share any state. await instance .use(initReactI18next) // Tell our instance to use react-i18next .use(Backend) // Setup our backend.init(&#123; .init(&#123; ...i18nextOptions, // use the same configuration as in your client side. lng, // The locale we detected above ns, // The namespaces the routes about to render want to use backend: &#123; loadPath: resolve(&#x27;./public/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;), &#125; &#125;) // Then you can render your app wrapped in the I18nextProvider as in the // entry.client file const markup = renderToString( &lt;I18nextProvider i18n=&#123;instance&#125;&gt; &lt;RemixServer context=&#123;context&#125; url=&#123;request.url&#125; /&gt; &lt;/I18nextProvider&gt; ); headers.set(&quot;Content-Type&quot;, &quot;text/html&quot;); return new Response(&quot;&lt;!DOCTYPE html&gt;&quot; + markup, &#123; status: statusCode, headers: headers, &#125;)&#125; 1234567export default &#123; debug: process.env.NODE_ENV !== &#x27;production&#x27;, fallbackLng: &#x27;en&#x27;, supportedLngs: [&#x27;en&#x27;, &#x27;de&#x27;], defaultNS: &#x27;common&#x27;, react: &#123; useSuspense: false &#125;&#125; In the root.jsx file we need to call useRemixI18Next only on server side: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import &#123; Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData&#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useChangeLanguage &#125; from &#x27;remix-i18next&#x27;import remixI18n from &#x27;./i18n.server&#x27;import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;import styles from &#x27;./styles/index.css&#x27;import &#123; i18nCookie &#125; from &#x27;./cookie&#x27;export const loader = async (&#123; request &#125;) =&gt; &#123; const locale = await remixI18n.getLocale(request) const t = await remixI18n.getFixedT(request, &#x27;common&#x27;) const title = t(&#x27;headTitle&#x27;) return json(&#123; locale, title &#125;, &#123; headers: &#123;&quot;Set-Cookie&quot;: await i18nCookie.serialize(locale)&#125; &#125;)&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;common&#x27;]&#125;;export function meta(&#123; data &#125;) &#123; return &#123; title: data.title &#125;&#125;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;export default function App() &#123; const &#123; i18n &#125; = useTranslation() const &#123; locale &#125; = useLoaderData() // This hook will change the i18n instance language to the current locale // detected by the loader, this way, when we do something to change the // language, this locale will change and i18next will load the correct // translation files useChangeLanguage(locale) return ( &lt;html lang=&#123;i18n.resolvedLanguage&#125;&gt; &lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;Meta /&gt; &lt;Links /&gt; &lt;/head&gt; &lt;body&gt; &lt;Outlet /&gt; &lt;ScrollRestoration /&gt; &lt;Scripts /&gt; &lt;LiveReload /&gt; &lt;/body&gt; &lt;/html&gt; )&#125; That&#39;s it: The app looks more or less the same, but on client side the translations are fetched directly from the locize CDN. This means if you change translations in locize they will be available to your Remix app, without having to change or redeploy your app. Only to have the newest translations on server side (i.e. for SEO optimizations) a new npm run downloadLocales and rebuild is needed. save missing translations Thanks to the use of the saveMissing functionality, new keys gets added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; hydrate &#125; from &#x27;react-dom&#x27;import &#123; RemixBrowser &#125; from &#x27;@remix-run/react&#x27;import i18next from &#x27;i18next&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import &#123; getInitialNamespaces &#125; from &#x27;remix-i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;const locizeOptions = &#123; projectId: &#x27;f6d74b76-9677-4a0d-b400-86e1507397ab&#x27;, apiKey: &#x27;1c2bbc21-027d-4f41-995a-e8beb451cdef&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;// initialize i18next using initReactI18next and configuring itif (!i18next.isInitialized) &#123; // prevent i18next to be initialized multiple times i18next // pass the i18n instance to react-i18next. .use(initReactI18next) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; ...i18nextOptions, // This function detects the namespaces your routes rendered while SSR use // and pass them here to load the translations ns: getInitialNamespaces(), detection: &#123; // Here only enable htmlTag detection, we&#x27;ll detect the language only // server-side with remix-i18next, by using the `&lt;html lang&gt;` attribute // we can communicate to the client the language detected server-side order: [&#x27;htmlTag&#x27;], // Because we only use htmlTag, there&#x27;s no reason to cache the language // on the browser, so we disable it caches: [], &#125;, backend: locizeOptions, saveMissing: true &#125;) .then(() =&gt; &#123; // then hydrate your app return hydrate( &lt;I18nextProvider i18n=&#123;i18next&#125;&gt; &lt;RemixBrowser /&gt; &lt;/I18nextProvider&gt;, document ) &#125;)&#125; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;div&gt;&#123;t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;)&#125;&lt;/div&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see how the automatic machine translation workflow looks like! npm install locize-lastused locize use them like this: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#123; hydrate &#125; from &#x27;react-dom&#x27;import &#123; RemixBrowser &#125; from &#x27;@remix-run/react&#x27;import i18next from &#x27;i18next&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import &#123; getInitialNamespaces &#125; from &#x27;remix-i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LastUsed from &#x27;locize-lastused&#x27;import &#123; locizePlugin &#125; from &#x27;locize&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;const locizeOptions = &#123; projectId: &#x27;f6d74b76-9677-4a0d-b400-86e1507397ab&#x27;, apiKey: &#x27;1c2bbc21-027d-4f41-995a-e8beb451cdef&#x27;, // YOU should not expose your apps API key to production!!! version: &#x27;latest&#x27;&#125;// initialize i18next using initReactI18next and configuring itif (!i18next.isInitialized) &#123; // prevent i18next to be initialized multiple times i18next // pass the i18n instance to react-i18next. .use(initReactI18next) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused .use(LastUsed) // locize-editor // InContext Editor of locize .use(locizePlugin) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; ...i18nextOptions, // This function detects the namespaces your routes rendered while SSR use // and pass them here to load the translations ns: getInitialNamespaces(), detection: &#123; // Here only enable htmlTag detection, we&#x27;ll detect the language only // server-side with remix-i18next, by using the `&lt;html lang&gt;` attribute // we can communicate to the client the language detected server-side order: [&#x27;htmlTag&#x27;], // Because we only use htmlTag, there&#x27;s no reason to cache the language // on the browser, so we disable it caches: [], &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: true &#125;) .then(() =&gt; &#123; // then hydrate your app return hydrate( &lt;I18nextProvider i18n=&#123;i18next&#125;&gt; &lt;RemixBrowser /&gt; &lt;/I18nextProvider&gt;, document ) &#125;)&#125; Automatic machine translation: Last used translations filter: InContext Editor: 📦 Let&#39;s prepare for production 🚀 Now, we prepare the app for going to production. First in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via API or via CLI. Lastly, enable Cache-Control max-age​ for that production version. Let&#39;s adapt the entry.client.jsx file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; hydrate &#125; from &#x27;react-dom&#x27;import &#123; RemixBrowser &#125; from &#x27;@remix-run/react&#x27;import i18next from &#x27;i18next&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import &#123; getInitialNamespaces &#125; from &#x27;remix-i18next&#x27;import Backend from &#x27;i18next-locize-backend&#x27;import LastUsed from &#x27;locize-lastused&#x27;import &#123; locizePlugin &#125; from &#x27;locize&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;const isProduction = process.env.NODE_ENV === &#x27;production&#x27;const locizeOptions = &#123; projectId: &#x27;f6d74b76-9677-4a0d-b400-86e1507397ab&#x27;, apiKey: !isProduction ? &#x27;1c2bbc21-027d-4f41-995a-e8beb451cdef&#x27; : undefined, // YOU should not expose your apps API key to production!!! version: isProduction ? &#x27;production&#x27; : &#x27;latest&#x27;&#125;if (!isProduction) &#123; // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused i18next.use(LastUsed)&#125;// initialize i18next using initReactI18next and configuring itif (!i18next.isInitialized) &#123; // prevent i18next to be initialized multiple times i18next // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; ...i18nextOptions, // This function detects the namespaces your routes rendered while SSR use // and pass them here to load the translations ns: getInitialNamespaces(), detection: &#123; // Here only enable htmlTag detection, we&#x27;ll detect the language only // server-side with remix-i18next, by using the `&lt;html lang&gt;` attribute // we can communicate to the client the language detected server-side order: [&#x27;htmlTag&#x27;], // Because we only use htmlTag, there&#x27;s no reason to cache the language // on the browser, so we disable it caches: [], &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: !isProduction // you should not use saveMissing in production &#125;) .then(() =&gt; &#123; // then hydrate your app return hydrate( &lt;I18nextProvider i18n=&#123;i18next&#125;&gt; &lt;RemixBrowser /&gt; &lt;/I18nextProvider&gt;, document ) &#125;)&#125; Now, during development, you&#39;ll continue to save missing keys and to make use of lastused feature. =&gt; npm run dev And in production environment, saveMissing and lastused are disabled. =&gt; npm run build &amp;&amp; npm start Caching: Merging versions: 🧑‍💻 The complete code can be found here. Check also the code integration part in this YouTube video. There&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 Awesome! Thanks to remix-i18next, i18next, react-i18next and locize your continuous localization workflow is ready to go. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: How to internationalize a Remix application (Part 2)\ndescription: Remix localization made easy focusing on continuous localization.\n\ndate: 2022-03-03\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - remix-i18next\n  - remix\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: remix-i18next/remix-localization.jpg\n\nlabel: remix-i18next\nlang: en\n---\n\n![remix localization](remix-localization.jpg \"Remix Localization example\")\n\nIn the [previous blog post](../remix-i18n/) we learned on a simple way how we can instrumented our [Remix](https://remix.run) app to be ready for localization by using [remix-i18next](https://github.com/sergiodxa/remix-i18next).\n<br />\nIn this blog post we will try to unleash the full power of [i18next](https://www.i18next.com) and focus on a continuous localization workflow.\n\n### TOC\n  * [Better translation management](#better-translation-management)\n    - [For sure!](#for-sure)\n    - [How does this look like?](#how-look)\n    - [save missing translations](#save-missing)\n    - [👀 but there's more...](#more)\n    - [📦 Let's prepare for production 🚀](#production)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n\n## Better translation management <a name=\"better-translation-management\"></a>\n\nIn the previous blog post there was a [voluntary part](../remix-i18n/#voluntary). This already was the first step.\n\nBy sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you.\nThis is a traditional way. But be aware sending files around creates always an overhead.\n\n> Does a better option exist?\n\n#### For sure! <a name=\"for-sure\"></a>\n\n[i18next](https://www.i18next.com) helps to get the application translated, and this is great - but there is more to it.\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- How do you deploy translation changes without deploying your complete application?\n- and a lot more...\n\n**Looking for something like this❓**\n\n- [Easy to integrate](https://docs.locize.com/integration/instrumenting-your-code#i-18-next)\n- Continuous deployment? [Continuous localization](https://locize.com/how-it-works.html#continouslocalization)!\n- Manage the translation files with ease\n- [Order professional translations](https://docs.locize.com/guides-tips-and-tricks/working-with-translators)\n- Analytics & Statistics\n- [Profit from our content delivery network (CDN)](https://docs.locize.com/whats-inside/cdn-content-delivery-network)\n- [Versioning of your translations](https://docs.locize.com/more/versioning)\n- [Automatic and On-Demand Machine Translation](https://docs.locize.com/whats-inside/auto-machine-translation)\n- [Riskfree: Take your data with you](https://docs.locize.com/more/general-questions/how-is-locize-different-from-the-alternatives#service-lock-in)\n- [Transparent and fair pricing](https://locize.com/pricing.html)\n- and a lot more...\n\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst, if not already done, you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by using the [cli](https://github.com/locize/react-tutorial#use-the-locize-cli) or by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations).\n\nDone so, we're going change the way the translations are loaded on server side and on client side.\n\nCurrently the translations are downloaded from locize via CLI and are then served on server side in the `public/locales` folder. Thanks to remix-i18next then the translations are downloaded by the client.\n\nWe now would like the client side to directly consume the translations provided by the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\nInstead on server side we'll continue to \"bundle\" the translations first.\nSee [downloadLocales script in package.json](https://github.com/locize/locize-remix-i18next-example/blob/main/package.json#L34).\nWe're doing so to prevent an elevated amount of downloads generated on server side. [Read this](https://github.com/locize/i18next-locize-backend#important-advice-for-serverless-environments---aws-lambda-google-cloud-functions-azure-functions-etc) for more information about this topic about serverless environments.\n\nWe have to install [i18next-locize-backend](https://github.com/locize/i18next-locize-backend).\n\n`npm install i18next-locize-backend`\n\nAdapt the `entry.client.jsx` file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project.\n```javascript\nimport { hydrate } from 'react-dom'\nimport { RemixBrowser } from '@remix-run/react'\nimport i18next from 'i18next'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport { getInitialNamespaces } from 'remix-i18next'\nimport Backend from 'i18next-locize-backend'\nimport LastUsed from 'locize-lastused'\nimport { locizePlugin } from 'locize'\nimport i18nextOptions from './i18nextOptions'\n\nconst locizeOptions = {\n  projectId: 'f6d74b76-9677-4a0d-b400-86e1507397ab',\n  apiKey: '1c2bbc21-027d-4f41-995a-e8beb451cdef', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\n// initialize i18next using initReactI18next and configuring it\nif (!i18next.isInitialized) { // prevent i18next to be initialized multiple times\n  i18next\n    // pass the i18n instance to react-i18next.\n    .use(initReactI18next)\n    // i18next-locize-backend\n    // loads translations from your project, saves new keys to it (saveMissing: true)\n    // https://github.com/locize/i18next-locize-backend\n    .use(Backend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(LanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      ...i18nextOptions,\n      // This function detects the namespaces your routes rendered while SSR use\n      // and pass them here to load the translations\n      ns: getInitialNamespaces(),\n      detection: {\n        // Here only enable htmlTag detection, we'll detect the language only\n        // server-side with remix-i18next, by using the `<html lang>` attribute\n        // we can communicate to the client the language detected server-side\n        order: ['htmlTag'],\n        // Because we only use htmlTag, there's no reason to cache the language\n        // on the browser, so we disable it\n        caches: [],\n      },\n      backend: locizeOptions\n    })\n    .then(() => {\n      // then hydrate your app\n      return hydrate(\n        <I18nextProvider i18n={i18next}>\n          <RemixBrowser />\n        </I18nextProvider>,\n        document\n      )\n    })\n}\n```\n\nThe `entry.server.jsx` file, the `root.jsx` and the `i18nextOptions.js` file should still look the same:\n\n```javascript\nimport { renderToString } from 'react-dom/server'\nimport { RemixServer } from 'remix'\nimport { createInstance } from 'i18next'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport Backend from 'i18next-fs-backend'\nimport { resolve } from 'node:path'\nimport i18nextOptions from './i18nextOptions'\nimport i18n from './i18n.server'\n\nexport default async function handleRequest(\n  request,\n  statusCode,\n  headers,\n  context\n) {\n  // First, we create a new instance of i18next so every request will have a\n  // completely unique instance and not share any state\n  const instance = createInstance()\n\n  // Then we could detect locale from the request\n  const lng = await i18n.getLocale(request)\n  // And here we detect what namespaces the routes about to render want to use\n  const ns = i18n.getRouteNamespaces(context)\n\n  // First, we create a new instance of i18next so every request will have a\n  // completely unique instance and not share any state.\n  await instance\n    .use(initReactI18next) // Tell our instance to use react-i18next\n    .use(Backend) // Setup our backend.init({\n    .init({\n      ...i18nextOptions, // use the same configuration as in your client side.\n      lng, // The locale we detected above\n      ns, // The namespaces the routes about to render want to use\n      backend: {\n        loadPath: resolve('./public/locales/{{lng}}/{{ns}}.json'),\n      }\n    })\n\n  // Then you can render your app wrapped in the I18nextProvider as in the\n  // entry.client file\n  const markup = renderToString(\n    <I18nextProvider i18n={instance}>\n      <RemixServer context={context} url={request.url} />\n    </I18nextProvider>\n  );\n\n  headers.set(\"Content-Type\", \"text/html\");\n\n  return new Response(\"<!DOCTYPE html>\" + markup, {\n    status: statusCode,\n    headers: headers,\n  })\n}\n```\n\n```javascript\nexport default {\n  debug: process.env.NODE_ENV !== 'production',\n  fallbackLng: 'en',\n  supportedLngs: ['en', 'de'],\n  defaultNS: 'common',\n  react: { useSuspense: false }\n}\n```\n\nIn the `root.jsx` file we need to call `useRemixI18Next` only on server side:\n\n```javascript\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData\n} from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useChangeLanguage } from 'remix-i18next'\nimport remixI18n from './i18n.server'\nimport { useTranslation } from 'react-i18next'\nimport styles from './styles/index.css'\nimport { i18nCookie } from './cookie'\n\nexport const loader = async ({ request }) => {\n  const locale = await remixI18n.getLocale(request)\n  const t = await remixI18n.getFixedT(request, 'common')\n  const title = t('headTitle')\n  return json({ locale, title }, {\n    headers: {\"Set-Cookie\": await i18nCookie.serialize(locale)}\n  })\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['common']\n};\n\nexport function meta({ data }) {\n  return { title: data.title }\n}\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nexport default function App() {\n  const { i18n } = useTranslation()\n  const { locale } = useLoaderData()\n  \n  // This hook will change the i18n instance language to the current locale\n  // detected by the loader, this way, when we do something to change the\n  // language, this locale will change and i18next will load the correct\n  // translation files\n  useChangeLanguage(locale)\n\n  return (\n    <html lang={i18n.resolvedLanguage}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Outlet />\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n```\n\nThat's it:\n\n![](app.jpg)\n\nThe app looks more or less the same, but on client side the translations are fetched directly from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network).\nThis means if you change translations in locize they will be available to your Remix app, without having to change or redeploy your app.\n*Only to have the newest translations on server side (i.e. for SEO optimizations) a new `npm run downloadLocales` and rebuild is needed.*\n\n\n#### save missing translations <a name=\"save-missing\"></a>\n\nThanks to the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys gets added to locize automatically, while developing the app.\n\nJust pass `saveMissing: true` in the i18next options:\n\n```javascript\nimport { hydrate } from 'react-dom'\nimport { RemixBrowser } from '@remix-run/react'\nimport i18next from 'i18next'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport { getInitialNamespaces } from 'remix-i18next'\nimport Backend from 'i18next-locize-backend'\nimport i18nextOptions from './i18nextOptions'\n\nconst locizeOptions = {\n  projectId: 'f6d74b76-9677-4a0d-b400-86e1507397ab',\n  apiKey: '1c2bbc21-027d-4f41-995a-e8beb451cdef', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\n// initialize i18next using initReactI18next and configuring it\nif (!i18next.isInitialized) { // prevent i18next to be initialized multiple times\n  i18next\n    // pass the i18n instance to react-i18next.\n    .use(initReactI18next)\n    // i18next-locize-backend\n    // loads translations from your project, saves new keys to it (saveMissing: true)\n    // https://github.com/locize/i18next-locize-backend\n    .use(Backend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(LanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      ...i18nextOptions,\n      // This function detects the namespaces your routes rendered while SSR use\n      // and pass them here to load the translations\n      ns: getInitialNamespaces(),\n      detection: {\n        // Here only enable htmlTag detection, we'll detect the language only\n        // server-side with remix-i18next, by using the `<html lang>` attribute\n        // we can communicate to the client the language detected server-side\n        order: ['htmlTag'],\n        // Because we only use htmlTag, there's no reason to cache the language\n        // on the browser, so we disable it\n        caches: [],\n      },\n      backend: locizeOptions,\n      saveMissing: true\n    })\n    .then(() => {\n      // then hydrate your app\n      return hydrate(\n        <I18nextProvider i18n={i18next}>\n          <RemixBrowser />\n        </I18nextProvider>,\n        document\n      )\n    })\n}\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<div>{t('new.key', 'this will be added automatically')}</div>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation) and the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation.\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see how the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n`npm install locize-lastused locize`\n\nuse them like this:\n\n```javascript\nimport { hydrate } from 'react-dom'\nimport { RemixBrowser } from '@remix-run/react'\nimport i18next from 'i18next'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport { getInitialNamespaces } from 'remix-i18next'\nimport Backend from 'i18next-locize-backend'\nimport LastUsed from 'locize-lastused'\nimport { locizePlugin } from 'locize'\nimport i18nextOptions from './i18nextOptions'\n\nconst locizeOptions = {\n  projectId: 'f6d74b76-9677-4a0d-b400-86e1507397ab',\n  apiKey: '1c2bbc21-027d-4f41-995a-e8beb451cdef', // YOU should not expose your apps API key to production!!!\n  version: 'latest'\n}\n\n// initialize i18next using initReactI18next and configuring it\nif (!i18next.isInitialized) { // prevent i18next to be initialized multiple times\n  i18next\n    // pass the i18n instance to react-i18next.\n    .use(initReactI18next)\n    // i18next-locize-backend\n    // loads translations from your project, saves new keys to it (saveMissing: true)\n    // https://github.com/locize/i18next-locize-backend\n    .use(Backend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(LanguageDetector)\n    // locize-lastused\n    // sets a timestamp of last access on every translation segment on locize\n    // -> safely remove the ones not being touched for weeks/months\n    // https://github.com/locize/locize-lastused\n    .use(LastUsed)\n    // locize-editor\n    // InContext Editor of locize\n    .use(locizePlugin)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      ...i18nextOptions,\n      // This function detects the namespaces your routes rendered while SSR use\n      // and pass them here to load the translations\n      ns: getInitialNamespaces(),\n      detection: {\n        // Here only enable htmlTag detection, we'll detect the language only\n        // server-side with remix-i18next, by using the `<html lang>` attribute\n        // we can communicate to the client the language detected server-side\n        order: ['htmlTag'],\n        // Because we only use htmlTag, there's no reason to cache the language\n        // on the browser, so we disable it\n        caches: [],\n      },\n      backend: locizeOptions,\n      locizeLastUsed: locizeOptions,\n      saveMissing: true\n    })\n    .then(() => {\n      // then hydrate your app\n      return hydrate(\n        <I18nextProvider i18n={i18next}>\n          <RemixBrowser />\n        </I18nextProvider>,\n        document\n      )\n    })\n}\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![missing key auto](missing_key_auto_mt.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![i18next last used](last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![i18next incontext](in_context.jpg \"locize © inweso GmbH\")\n\n\n#### 📦 Let's prepare for production 🚀 <a name=\"production\"></a>\n\nNow, we prepare the app for [going to production](https://docs.locize.com/guides-tips-and-tricks/going-production).\n\nFirst in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via [API](https://docs.locize.com/integration/api#publish-version) or via [CLI](https://github.com/locize/locize-cli#publish-version).\nLastly, [enable Cache-Control max-age​](https://docs.locize.com/more/caching) for that production version.\n\nLet's adapt the `entry.client.jsx` file:\n\n```javascript\nimport { hydrate } from 'react-dom'\nimport { RemixBrowser } from '@remix-run/react'\nimport i18next from 'i18next'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport { getInitialNamespaces } from 'remix-i18next'\nimport Backend from 'i18next-locize-backend'\nimport LastUsed from 'locize-lastused'\nimport { locizePlugin } from 'locize'\nimport i18nextOptions from './i18nextOptions'\n\nconst isProduction = process.env.NODE_ENV === 'production'\n\nconst locizeOptions = {\n  projectId: 'f6d74b76-9677-4a0d-b400-86e1507397ab',\n  apiKey: !isProduction ? '1c2bbc21-027d-4f41-995a-e8beb451cdef' : undefined, // YOU should not expose your apps API key to production!!!\n  version: isProduction ? 'production' : 'latest'\n}\n\nif (!isProduction) {\n  // locize-lastused\n  // sets a timestamp of last access on every translation segment on locize\n  // -> safely remove the ones not being touched for weeks/months\n  // https://github.com/locize/locize-lastused\n  i18next.use(LastUsed)\n}\n\n// initialize i18next using initReactI18next and configuring it\nif (!i18next.isInitialized) { // prevent i18next to be initialized multiple times\n  i18next\n    // locize-editor\n    // InContext Editor of locize\n    .use(locizePlugin)\n    // i18next-locize-backend\n    // loads translations from your project, saves new keys to it (saveMissing: true)\n    // https://github.com/locize/i18next-locize-backend\n    .use(Backend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(LanguageDetector)\n    // pass the i18n instance to react-i18next.\n    .use(initReactI18next)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      ...i18nextOptions,\n      // This function detects the namespaces your routes rendered while SSR use\n      // and pass them here to load the translations\n      ns: getInitialNamespaces(),\n      detection: {\n        // Here only enable htmlTag detection, we'll detect the language only\n        // server-side with remix-i18next, by using the `<html lang>` attribute\n        // we can communicate to the client the language detected server-side\n        order: ['htmlTag'],\n        // Because we only use htmlTag, there's no reason to cache the language\n        // on the browser, so we disable it\n        caches: [],\n      },\n      backend: locizeOptions,\n      locizeLastUsed: locizeOptions,\n      saveMissing: !isProduction // you should not use saveMissing in production\n    })\n    .then(() => {\n      // then hydrate your app\n      return hydrate(\n        <I18nextProvider i18n={i18next}>\n          <RemixBrowser />\n        </I18nextProvider>,\n        document\n      )\n    })\n}\n```\n\nNow, during development, you'll continue to save missing keys and to make use of lastused feature. => `npm run dev`\n\nAnd in production environment, saveMissing and lastused are disabled. => `npm run build && npm start`\n\n\n[Caching](https://docs.locize.com/more/caching):\n\n![i18next caching](caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/locize-remix-i18next-example).*\n\n*Check also the [code integration part](https://www.youtube.com/watch?v=ds-yEEYP1Ks&t=423s) in this [YouTube video](https://www.youtube.com/watch?v=ds-yEEYP1Ks).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nAwesome! Thanks to [remix-i18next](https://github.com/sergiodxa/remix-i18next), [i18next](https://www.i18next.com), [react-i18next](https://react.i18next.com) and [locize](https://locize.com) your continuous localization workflow is ready to go.\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"remix-i18next","slug":"remix-i18next","permalink":"https://locize.com/blog/tags/remix-i18next/"},{"name":"remix","slug":"remix","permalink":"https://locize.com/blog/tags/remix/"}]},{"title":"How to internationalize a Remix application (Part 1)","slug":"remix-i18n","date":"un33fin33","updated":"un66fin66","comments":true,"path":"remix-i18n/","link":"","permalink":"https://locize.com/blog/remix-i18n/","excerpt":"","text":"Let&#39;s talk about internationalization (i18n) for Remix... When it comes to JavaScript localization, one of the most popular frameworks is i18next and one of the most famous Remix module for i18next is remix-i18next. It was created in October 2021 by Sergio Xalambrí. There is also a second part of this blog post, that focuses more on a continuous localization workflow. TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher The voluntary part 🎉🥳 Congratulations 🎊🎁 Part 2 So first of all: &quot;Why i18next?&quot; i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it... Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic React and Remix, before jumping to remix-i18next. Getting started Take your own Remix project or use this example app here. 1234git clone -b start git@github.com:locize/locize-remix-i18next-example.gitcd locize-remix-i18next-examplenpm inpm run dev We are going to adapt the app to detect the language according to the user’s preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: remix-i18next i18next react-i18next i18next-browser-languagedetector i18next-fs-backend i18next-http-backend npm install remix-i18next i18next react-i18next i18next-browser-languagedetector i18next-fs-backend i18next-http-backend Create a i18nextOptions.js file and add the following code: 1234567export default &#123; debug: process.env.NODE_ENV !== &#x27;production&#x27;, fallbackLng: &#x27;en&#x27;, supportedLngs: [&#x27;en&#x27;, &#x27;de&#x27;], defaultNS: &#x27;common&#x27;, react: &#123; useSuspense: false &#125;&#125; And a i18n.server.js file and add the following code: 1234567891011121314151617181920212223import &#123; RemixI18Next &#125; from &#x27;remix-i18next&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;import Backend from &#x27;i18next-fs-backend&#x27;import &#123; resolve &#125; from &#x27;node:path&#x27;export default new RemixI18Next(&#123; detection: &#123; // This is the list of languages your application supports supportedLanguages: i18nextOptions.supportedLngs, // This is the language you want to use in case the user language is not // listed above fallbackLanguage: i18nextOptions.fallbackLng, &#125;, // This is the configuration for i18next used when translating messages server // side only i18next: &#123; backend: &#123; loadPath: resolve(&#x27;./public/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125;, &#125;, // The backend you want to use to load the translations // Tip: You could pass `resources` to the `i18next` configuration and avoid // a backend here backend: Backend,&#125;) Prepare some folders like this: Now in your entry.client.jsx adapt the code like this: 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; hydrate &#125; from &#x27;react-dom&#x27;import &#123; RemixBrowser &#125; from &#x27;@remix-run/react&#x27;import i18next from &#x27;i18next&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;import Backend from &#x27;i18next-http-backend&#x27;import &#123; getInitialNamespaces &#125; from &#x27;remix-i18next&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;// initialize i18next using initReactI18next and configuring itif (!i18next.isInitialized) // prevent i18next to be initialized multiple times i18next .use(initReactI18next) // Tell i18next to use the react-i18next plugin .use(LanguageDetector) // Setup a client-side language detector .use(Backend) // Setup your backend .init(&#123; ...i18nextOptions, backend: &#123; loadPath: &#x27;/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27; &#125;, // This function detects the namespaces your routes rendered while SSR use // and pass them here to load the translations ns: getInitialNamespaces(), detection: &#123; // Here only enable htmlTag detection, we&#x27;ll detect the language only // server-side with remix-i18next, by using the `&lt;html lang&gt;` attribute // we can communicate to the client the language detected server-side order: [&#x27;htmlTag&#x27;], // Because we only use htmlTag, there&#x27;s no reason to cache the language // on the browser, so we disable it caches: [], &#125; &#125;) .then(() =&gt; &#123; // then hydrate your app wrapped in the I18nextProvider return hydrate( &lt;I18nextProvider i18n=&#123;i18next&#125;&gt; &lt;RemixBrowser /&gt; &lt;/I18nextProvider&gt;, document ) &#125;) And in your entry.server.jsx adapt the code like this: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;import &#123; RemixServer &#125; from &#x27;remix&#x27;import &#123; createInstance &#125; from &#x27;i18next&#x27;import &#123; I18nextProvider, initReactI18next &#125; from &#x27;react-i18next&#x27;import Backend from &#x27;i18next-fs-backend&#x27;import &#123; resolve &#125; from &#x27;node:path&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;import i18n from &#x27;./i18n.server&#x27;export default async function handleRequest( request, statusCode, headers, context) &#123; // First, we create a new instance of i18next so every request will have a // completely unique instance and not share any state const instance = createInstance() // Then we could detect locale from the request const lng = await i18n.getLocale(request) // And here we detect what namespaces the routes about to render want to use const ns = i18n.getRouteNamespaces(context) // First, we create a new instance of i18next so every request will have a // completely unique instance and not share any state. await instance .use(initReactI18next) // Tell our instance to use react-i18next .use(Backend) // Setup our backend.init(&#123; .init(&#123; ...i18nextOptions, // use the same configuration as in your client side. lng, // The locale we detected above ns, // The namespaces the routes about to render want to use backend: &#123; loadPath: resolve(&quot;./public/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&quot;), &#125; &#125;) // Then you can render your app wrapped in the I18nextProvider as in the // entry.client file const markup = renderToString( &lt;I18nextProvider i18n=&#123;instance&#125;&gt; &lt;RemixServer context=&#123;context&#125; url=&#123;request.url&#125; /&gt; &lt;/I18nextProvider&gt; ); headers.set(&quot;Content-Type&quot;, &quot;text/html&quot;); return new Response(&quot;&lt;!DOCTYPE html&gt;&quot; + markup, &#123; status: statusCode, headers: headers, &#125;)&#125; The last important piece is the root.jsx file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData&#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useChangeLanguage &#125; from &#x27;remix-i18next&#x27;import remixI18n from &#x27;./i18n.server&#x27;import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;import styles from &#x27;./styles/index.css&#x27;export const loader = async (&#123; request &#125;) =&gt; &#123; const locale = await remixI18n.getLocale(request) const t = await remixI18n.getFixedT(request, &#x27;common&#x27;) const title = t(&#x27;headTitle&#x27;) return json(&#123; locale, title &#125;)&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;common&#x27;]&#125;;export function meta(&#123; data &#125;) &#123; return &#123; title: data.title &#125;&#125;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;export default function App() &#123; const &#123; i18n &#125; = useTranslation() const &#123; locale &#125; = useLoaderData() // This hook will change the i18n instance language to the current locale // detected by the loader, this way, when we do something to change the // language, this locale will change and i18next will load the correct // translation files useChangeLanguage(locale) return ( &lt;html lang=&#123;i18n.language&#125;&gt; &lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;Meta /&gt; &lt;Links /&gt; &lt;/head&gt; &lt;body&gt; &lt;Outlet /&gt; &lt;ScrollRestoration /&gt; &lt;Scripts /&gt; &lt;LiveReload /&gt; &lt;/body&gt; &lt;/html&gt; )&#125; We&#39;re ready to start to use the t function. In your pages files, you can now use react-i18next to access the t function: 123456789101112131415161718import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;index&#x27;]&#125;;export default function Index() &#123; const &#123; t, ready, i18n &#125; = useTranslation(&#x27;index&#x27;) if (!ready) return &lt;Loading /&gt; // i18next may not be ready when changing route with &lt;Link&gt; return ( &lt;&gt; &lt;div&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/div&gt; &lt;/&gt; )&#125; Add the keys to your translations, i.e. public/locales/en/index.json: 123&#123; &quot;title&quot;: &quot;Welcome to Remix&quot;&#125; You can do this for all your pages and components: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; Link, useLoaderData &#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useTranslation, withTranslation, Trans &#125; from &#x27;react-i18next&#x27;import &#123; Component &#125; from &#x27;react&#x27;import logo from &#x27;../logo.svg&#x27;import styles from &#x27;../styles/app.css&#x27;import Loading from &#x27;../components/Loading&#x27;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;class LegacyWelcomeClass extends Component &#123; render() &#123; const &#123; t &#125; = this.props return &lt;h2&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h2&gt; &#125;&#125;const Welcome = withTranslation(&#x27;index&#x27;)(LegacyWelcomeClass)// Component using the Trans componentfunction MyComponent(&#123; t &#125;) &#123; return ( &lt;Trans t=&#123;t&#125; i18nKey=&quot;description.part1&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; )&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;index&#x27;]&#125;;export default function Index() &#123; const &#123; t, ready, i18n &#125; = useTranslation(&#x27;index&#x27;) if (!ready) return &lt;Loading /&gt; // i18next may not be ready when changing route with &lt;Link&gt; return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;Welcome /&gt; &lt;/div&gt; &lt;div className=&quot;App-intro&quot;&gt; &lt;MyComponent t=&#123;t&#125; /&gt; &lt;/div&gt; &lt;div&gt;&#123;t(&#x27;description.part2&#x27;)&#125;&lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;Link to=&quot;/second&quot;&gt;&#123;t(&#x27;goto.second&#x27;)&#125;&lt;/Link&gt; &lt;/div&gt; &lt;/div&gt; )&#125; This looks like the normal react-i18next usage. Due to we&#39;re not using Suspense here, just make sure you check the ready flag before calling the t function. The translations will get lazy loaded as soon as you navigate on client side to another page. We can also translate stuff like the page title. Since remix-i18next can translate text inside loaders or actions, we can do this for example in our root.jsx: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData&#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useChangeLanguage &#125; from &#x27;remix-i18next&#x27;import remixI18n from &#x27;./i18n.server&#x27;import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;import styles from &#x27;./styles/index.css&#x27;export const loader = async (&#123; request &#125;) =&gt; &#123; const locale = await remixI18n.getLocale(request) const t = await remixI18n.getFixedT(request, &#x27;common&#x27;) const title = t(&#x27;headTitle&#x27;) return json(&#123; locale, title &#125;)&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;common&#x27;]&#125;;export function meta(&#123; data &#125;) &#123; return &#123; title: data.title &#125;&#125;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;export default function App() &#123; const &#123; i18n &#125; = useTranslation() const &#123; locale &#125; = useLoaderData() // This hook will change the i18n instance language to the current locale // detected by the loader, this way, when we do something to change the // language, this locale will change and i18next will load the correct // translation files useChangeLanguage(locale) return ( &lt;html lang=&#123;i18n.resolvedLanguage&#125;&gt; &lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;Meta /&gt; &lt;Links /&gt; &lt;/head&gt; &lt;body&gt; &lt;Outlet /&gt; &lt;ScrollRestoration /&gt; &lt;Scripts /&gt; &lt;LiveReload /&gt; &lt;/body&gt; &lt;/html&gt; )&#125; Add the keys to your translations, i.e. public/locales/en/common.json: 123&#123; &quot;headTitle&quot;: &quot;New Remix App&quot;&#125; Language Switcher remix-i18next by default will detect the current language in this order: the lng search parameter a cookie (if you pass one) the session (if you pass the sessionStorage) the Accept-Language header the fallback language you configured We additionally like to offer the possibility to change the language via some sort of language switcher. So let&#39;s add a section in our index.js file: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import &#123; Link, useLoaderData &#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useTranslation, withTranslation, Trans &#125; from &#x27;react-i18next&#x27;import &#123; Component &#125; from &#x27;react&#x27;import logo from &#x27;../logo.svg&#x27;import styles from &#x27;../styles/app.css&#x27;import Loading from &#x27;../components/Loading&#x27;export const loader = async (&#123; request &#125;) =&gt; &#123; return json(&#123; lngs: &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125; &#125; &#125;)&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;index&#x27;]&#125;;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;class LegacyWelcomeClass extends Component &#123; render() &#123; const &#123; t &#125; = this.props return &lt;h2&gt;&#123;t(&#x27;title&#x27;)&#125;&lt;/h2&gt; &#125;&#125;const Welcome = withTranslation(&#x27;index&#x27;)(LegacyWelcomeClass)// Component using the Trans componentfunction MyComponent(&#123; t &#125;) &#123; return ( &lt;Trans t=&#123;t&#125; i18nKey=&quot;description.part1&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; )&#125;export default function Index() &#123; const &#123; lngs &#125; = useLoaderData() const &#123; t, ready, i18n &#125; = useTranslation(&#x27;index&#x27;) if (!ready) return &lt;Loading /&gt; // i18next may not be ready when changing route with &lt;Link&gt; return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;Welcome /&gt; &lt;/div&gt; &lt;div className=&quot;App-intro&quot;&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;Link key=&#123;lng&#125; style=&#123;&#123; marginRight: 5, fontWeight: i18n.resolvedLanguage === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; to=&#123;`/?lng=$&#123;lng&#125;`&#125; &gt; &#123;lngs[lng].nativeName&#125; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;MyComponent t=&#123;t&#125; /&gt; &lt;/div&gt; &lt;div&gt;&#123;t(&#x27;description.part2&#x27;)&#125;&lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;Link to=&quot;/second&quot;&gt;&#123;t(&#x27;goto.second&#x27;)&#125;&lt;/Link&gt; &lt;/div&gt; &lt;/div&gt; )&#125; To persist the current locale, we will save it in a cookie. Just create a new cookie.js file: 123456import &#123; createCookie &#125; from &#x27;remix&#x27;export let i18nCookie = createCookie(&#x27;i18n&#x27;, &#123; sameSite: &#x27;lax&#x27;, path: &#x27;/&#x27;,&#125;) And use it like this in i18n.server.js: 1234567891011121314151617181920212223242526import &#123; RemixI18Next &#125; from &#x27;remix-i18next&#x27;import i18nextOptions from &#x27;./i18nextOptions&#x27;import Backend from &#x27;i18next-fs-backend&#x27;import &#123; resolve &#125; from &#x27;node:path&#x27;import &#123; i18nCookie &#125; from &#x27;./cookie&#x27;export default new RemixI18Next(&#123; detection: &#123; // persist language selection in cookie cookie: i18nCookie, // This is the list of languages your application supports supportedLanguages: i18nextOptions.supportedLngs, // This is the language you want to use in case the user language is not // listed above fallbackLanguage: i18nextOptions.fallbackLng, &#125;, // This is the configuration for i18next used when translating messages server // side only i18next: &#123; backend: &#123; loadPath: resolve(&#x27;./public/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125;, &#125;, // The backend you want to use to load the translations // Tip: You could pass `resources` to the `i18next` configuration and avoid // a backend here backend: Backend,&#125;) and also in root.jsx: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import &#123; Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData&#125; from &#x27;@remix-run/react&#x27;import &#123; json &#125; from &#x27;@remix-run/node&#x27;import &#123; useChangeLanguage &#125; from &#x27;remix-i18next&#x27;import remixI18n from &#x27;./i18n.server&#x27;import &#123; useTranslation &#125; from &#x27;react-i18next&#x27;import styles from &#x27;./styles/index.css&#x27;import &#123; i18nCookie &#125; from &#x27;./cookie&#x27;export const loader = async (&#123; request &#125;) =&gt; &#123; const locale = await remixI18n.getLocale(request) const t = await remixI18n.getFixedT(request, &#x27;common&#x27;) const title = t(&#x27;headTitle&#x27;) return json(&#123; locale, title &#125;, &#123; headers: &#123;&quot;Set-Cookie&quot;: await i18nCookie.serialize(locale)&#125; &#125;)&#125;export const handle = &#123; // In the handle export, we could add a i18n key with namespaces our route // will need to load. This key can be a single string or an array of strings. i18n: [&#x27;common&#x27;]&#125;;export function meta(&#123; data &#125;) &#123; return &#123; title: data.title &#125;&#125;export const links = () =&gt; &#123; return [&#123; rel: &#x27;stylesheet&#x27;, href: styles &#125;]&#125;export default function App() &#123; const &#123; i18n &#125; = useTranslation() const &#123; locale &#125; = useLoaderData() // This hook will change the i18n instance language to the current locale // detected by the loader, this way, when we do something to change the // language, this locale will change and i18next will load the correct // translation files useChangeLanguage(locale) return ( &lt;html lang=&#123;i18n.language&#125;&gt; &lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;Meta /&gt; &lt;Links /&gt; &lt;/head&gt; &lt;body&gt; &lt;Outlet /&gt; &lt;ScrollRestoration /&gt; &lt;Scripts /&gt; &lt;LiveReload /&gt; &lt;/body&gt; &lt;/html&gt; )&#125; So this means we&#39;re using the lng search parameter to change the language. And persist the current detected language in the cookie. 🥳 Awesome, the app is internationalized and we&#39;ve just created our first language switcher! 🧑‍💻 The complete code can be found here. The voluntary part Connect to an awesome translation management system and manage your translations outside of your code. Let&#39;s synchronize the translation files with locize. This can be done on-demand or on the CI-Server or before deploying the app. What to do to reach this step: in locize: signup at https://locize.app/register and login in locize: create a new project in locize: add all your additional languages (this can also be done via API) install the locize-cli (npm i locize-cli) Use the locize-cliUse the locize sync command to synchronize your local repository (public/locales) with what is published on locize. Alternatively, you can also use the locize download command to always download the published locize translations to your local repository (public/locales) before bundling your app. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18n in Remix, remix-i18next, i18next and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. There&#39;s also an i18next crash course video. 👍If you like to know how to unleash the full power of i18next, check out &quot;Part 2&quot;!","raw":"---\ntitle: How to internationalize a Remix application (Part 1)\ndescription: Simple Remix localization made easy with this ✅step-by-step guide using i18next.\n\ndate: 2022-03-02\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - remix-i18next\n  - remix\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: remix-i18n/remix-localization.jpg\n\nlabel: remix-i18n\nlang: en\n---\n\n![remix localization](remix-localization.jpg \"Remix Localization example\")\n\nLet's talk about internationalization (i18n) for [Remix](https://remix.run)...\n\nWhen it comes to JavaScript localization, one of the most popular frameworks is [i18next](https://www.i18next.com) and one of the most famous Remix module for i18next is [remix-i18next](https://github.com/sergiodxa/remix-i18next).\nIt was created in October 2021 by [Sergio Xalambrí](https://github.com/sergiodxa).\n\n***There is also a [second part of this blog post](../remix-i18next/), that focuses more on a continuous localization workflow.***\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [The voluntary part](#voluntary)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n  * [Part 2](../remix-i18next/)\n\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology ([React](../react-i18next/), [Angular](../angular-i18next/), [Vue](../i18next-vue/), ...).*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic [React](https://reactjs.org) and [Remix](https://remix.run), before jumping to [remix-i18next](https://github.com/sergiodxa/remix-i18next).\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own Remix project or use this example app [here](https://github.com/locize/locize-remix-i18next-example/tree/start).\n\n```sh\ngit clone -b start git@github.com:locize/locize-remix-i18next-example.git\ncd locize-remix-i18next-example\nnpm i\nnpm run dev\n```\n\nWe are going to adapt the app to detect the language according to the user’s preference.\nAnd we will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [remix-i18next](https://github.com/sergiodxa/remix-i18next)\n- [i18next](https://www.i18next.com)\n- [react-i18next](https://react.i18next.com)\n- [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector)\n- [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend)\n- [i18next-http-backend](https://github.com/i18next/i18next-http-backend)\n\n`npm install remix-i18next i18next react-i18next i18next-browser-languagedetector i18next-fs-backend i18next-http-backend`\n\nCreate a `i18nextOptions.js` file and add the following code:\n```javascript\nexport default {\n  debug: process.env.NODE_ENV !== 'production',\n  fallbackLng: 'en',\n  supportedLngs: ['en', 'de'],\n  defaultNS: 'common',\n  react: { useSuspense: false }\n}\n```\n\nAnd a `i18n.server.js` file and add the following code:\n```javascript\nimport { RemixI18Next } from 'remix-i18next'\nimport i18nextOptions from './i18nextOptions'\nimport Backend from 'i18next-fs-backend'\nimport { resolve } from 'node:path'\n\nexport default new RemixI18Next({\n  detection: {\n    // This is the list of languages your application supports\n    supportedLanguages: i18nextOptions.supportedLngs,\n    // This is the language you want to use in case the user language is not\n    // listed above\n    fallbackLanguage: i18nextOptions.fallbackLng,\n  },\n  // This is the configuration for i18next used when translating messages server\n  // side only\n  i18next: {\n    backend: { loadPath: resolve('./public/locales/{{lng}}/{{ns}}.json') },\n  },\n  // The backend you want to use to load the translations\n  // Tip: You could pass `resources` to the `i18next` configuration and avoid\n  // a backend here\n  backend: Backend,\n})\n```\n\nPrepare some folders like this:\n![](folder.jpg)\n\nNow in your `entry.client.jsx` adapt the code like this:\n```javascript\nimport { hydrate } from 'react-dom'\nimport { RemixBrowser } from '@remix-run/react'\nimport i18next from 'i18next'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport LanguageDetector from 'i18next-browser-languagedetector'\nimport Backend from 'i18next-http-backend'\nimport { getInitialNamespaces } from 'remix-i18next'\nimport i18nextOptions from './i18nextOptions'\n\n// initialize i18next using initReactI18next and configuring it\nif (!i18next.isInitialized) // prevent i18next to be initialized multiple times\n  i18next\n    .use(initReactI18next) // Tell i18next to use the react-i18next plugin\n    .use(LanguageDetector) // Setup a client-side language detector\n    .use(Backend) // Setup your backend\n    .init({\n      ...i18nextOptions,\n      backend: { loadPath: '/locales/{{lng}}/{{ns}}.json' },\n      // This function detects the namespaces your routes rendered while SSR use\n      // and pass them here to load the translations\n      ns: getInitialNamespaces(),\n      detection: {\n        // Here only enable htmlTag detection, we'll detect the language only\n        // server-side with remix-i18next, by using the `<html lang>` attribute\n        // we can communicate to the client the language detected server-side\n        order: ['htmlTag'],\n        // Because we only use htmlTag, there's no reason to cache the language\n        // on the browser, so we disable it\n        caches: [],\n      }\n    })\n    .then(() => {\n      // then hydrate your app wrapped in the I18nextProvider\n      return hydrate(\n        <I18nextProvider i18n={i18next}>\n          <RemixBrowser />\n        </I18nextProvider>,\n        document\n      )\n    })\n```\n\nAnd in your `entry.server.jsx` adapt the code like this:\n```javascript\nimport { renderToString } from 'react-dom/server'\nimport { RemixServer } from 'remix'\nimport { createInstance } from 'i18next'\nimport { I18nextProvider, initReactI18next } from 'react-i18next'\nimport Backend from 'i18next-fs-backend'\nimport { resolve } from 'node:path'\nimport i18nextOptions from './i18nextOptions'\nimport i18n from './i18n.server'\n\nexport default async function handleRequest(\n  request,\n  statusCode,\n  headers,\n  context\n) {\n  // First, we create a new instance of i18next so every request will have a\n  // completely unique instance and not share any state\n  const instance = createInstance()\n\n  // Then we could detect locale from the request\n  const lng = await i18n.getLocale(request)\n  // And here we detect what namespaces the routes about to render want to use\n  const ns = i18n.getRouteNamespaces(context)\n\n  // First, we create a new instance of i18next so every request will have a\n  // completely unique instance and not share any state.\n  await instance\n    .use(initReactI18next) // Tell our instance to use react-i18next\n    .use(Backend) // Setup our backend.init({\n    .init({\n      ...i18nextOptions, // use the same configuration as in your client side.\n      lng, // The locale we detected above\n      ns, // The namespaces the routes about to render want to use\n      backend: {\n        loadPath: resolve(\"./public/locales/{{lng}}/{{ns}}.json\"),\n      }\n    })\n\n  // Then you can render your app wrapped in the I18nextProvider as in the\n  // entry.client file\n  const markup = renderToString(\n    <I18nextProvider i18n={instance}>\n      <RemixServer context={context} url={request.url} />\n    </I18nextProvider>\n  );\n\n  headers.set(\"Content-Type\", \"text/html\");\n\n  return new Response(\"<!DOCTYPE html>\" + markup, {\n    status: statusCode,\n    headers: headers,\n  })\n}\n```\n\nThe last important piece is the `root.jsx` file:\n```javascript\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData\n} from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useChangeLanguage } from 'remix-i18next'\nimport remixI18n from './i18n.server'\nimport { useTranslation } from 'react-i18next'\nimport styles from './styles/index.css'\n\nexport const loader = async ({ request }) => {\n  const locale = await remixI18n.getLocale(request)\n  const t = await remixI18n.getFixedT(request, 'common')\n  const title = t('headTitle')\n  return json({ locale, title })\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['common']\n};\n\nexport function meta({ data }) {\n  return { title: data.title }\n}\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nexport default function App() {\n  const { i18n } = useTranslation()\n  const { locale } = useLoaderData()\n  \n  // This hook will change the i18n instance language to the current locale\n  // detected by the loader, this way, when we do something to change the\n  // language, this locale will change and i18next will load the correct\n  // translation files\n  useChangeLanguage(locale)\n\n  return (\n    <html lang={i18n.language}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Outlet />\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n```\n\nWe're ready to start to use the `t` function.\n<br />\nIn your pages files, you can now use react-i18next to access the `t` function:\n\n```javascript\nimport { useTranslation } from 'react-i18next'\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['index']\n};\n\nexport default function Index() {\n  const { t, ready, i18n } = useTranslation('index')\n  if (!ready) return <Loading /> // i18next may not be ready when changing route with <Link>\n  \n  return (\n    <>\n      <div>{t('title')}</div>\n    </>\n  )\n}\n```\n\nAdd the keys to your translations, i.e. `public/locales/en/index.json`:\n```json\n{\n  \"title\": \"Welcome to Remix\"\n}\n```\n\nYou can do this for all your pages and components:\n\n```javascript\nimport { Link, useLoaderData } from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useTranslation, withTranslation, Trans } from 'react-i18next'\nimport { Component } from 'react'\nimport logo from '../logo.svg'\nimport styles from '../styles/app.css'\nimport Loading from '../components/Loading'\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nclass LegacyWelcomeClass extends Component {\n  render() {\n    const { t } = this.props\n    return <h2>{t('title')}</h2>\n  }\n}\nconst Welcome = withTranslation('index')(LegacyWelcomeClass)\n\n// Component using the Trans component\nfunction MyComponent({ t }) {\n  return (\n    <Trans t={t} i18nKey=\"description.part1\">\n      To get started, edit <code>src/App.js</code> and save to reload.\n    </Trans>\n  )\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['index']\n};\n\nexport default function Index() {\n  const { t, ready, i18n } = useTranslation('index')\n  if (!ready) return <Loading /> // i18next may not be ready when changing route with <Link>\n\n  return (\n    <div className=\"App\">\n      <div className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <Welcome />\n      </div>\n      <div className=\"App-intro\">\n        <MyComponent t={t} />\n      </div>\n      <div>{t('description.part2')}</div>\n      <hr />\n      <div>\n        <Link to=\"/second\">{t('goto.second')}</Link>\n      </div>\n    </div>\n  )\n}\n```\n\nThis looks like the normal [react-i18next](https://react.i18next.com) usage.\n<br />\nDue to we're not using `Suspense` here, just make sure you check the `ready` flag before calling the `t` function. The translations will get lazy loaded as soon as you navigate on client side to another page.\n\nWe can also translate stuff like the page title.\n<br />\nSince remix-i18next can translate text inside loaders or actions, we can do this for example in our `root.jsx`:\n\n```javascript\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData\n} from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useChangeLanguage } from 'remix-i18next'\nimport remixI18n from './i18n.server'\nimport { useTranslation } from 'react-i18next'\nimport styles from './styles/index.css'\n\nexport const loader = async ({ request }) => {\n  const locale = await remixI18n.getLocale(request)\n  const t = await remixI18n.getFixedT(request, 'common')\n  const title = t('headTitle')\n  return json({ locale, title })\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['common']\n};\n\nexport function meta({ data }) {\n  return { title: data.title }\n}\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nexport default function App() {\n  const { i18n } = useTranslation()\n  const { locale } = useLoaderData()\n  \n  // This hook will change the i18n instance language to the current locale\n  // detected by the loader, this way, when we do something to change the\n  // language, this locale will change and i18next will load the correct\n  // translation files\n  useChangeLanguage(locale)\n\n  return (\n    <html lang={i18n.resolvedLanguage}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Outlet />\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n```\n\nAdd the keys to your translations, i.e. `public/locales/en/common.json`:\n```json\n{\n  \"headTitle\": \"New Remix App\"\n}\n```\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nremix-i18next by default will detect the current language in this order:\n- the lng search parameter\n- a cookie (if you pass one)\n- the session (if you pass the sessionStorage)\n- the Accept-Language header\n- the fallback language you configured\n\nWe additionally like to offer the possibility to change the language via some sort of language switcher.\n\nSo let's add a section in our `index.js` file:\n```javascript\nimport { Link, useLoaderData } from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useTranslation, withTranslation, Trans } from 'react-i18next'\nimport { Component } from 'react'\nimport logo from '../logo.svg'\nimport styles from '../styles/app.css'\nimport Loading from '../components/Loading'\n\nexport const loader = async ({ request }) => {\n  return json({\n    lngs: {\n      en: { nativeName: 'English' },\n      de: { nativeName: 'Deutsch' }\n    }\n  })\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['index']\n};\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nclass LegacyWelcomeClass extends Component {\n  render() {\n    const { t } = this.props\n    return <h2>{t('title')}</h2>\n  }\n}\nconst Welcome = withTranslation('index')(LegacyWelcomeClass)\n\n// Component using the Trans component\nfunction MyComponent({ t }) {\n  return (\n    <Trans t={t} i18nKey=\"description.part1\">\n      To get started, edit <code>src/App.js</code> and save to reload.\n    </Trans>\n  )\n}\n\nexport default function Index() {\n  const { lngs } = useLoaderData()\n  const { t, ready, i18n } = useTranslation('index')\n  if (!ready) return <Loading /> // i18next may not be ready when changing route with <Link>\n\n  return (\n    <div className=\"App\">\n      <div className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <Welcome />\n      </div>\n      <div className=\"App-intro\">\n        <div>\n          {Object.keys(lngs).map((lng) => (\n            <Link\n              key={lng}\n              style={{ marginRight: 5, fontWeight: i18n.resolvedLanguage === lng ? 'bold' : 'normal' }}\n              to={`/?lng=${lng}`}\n            >\n              {lngs[lng].nativeName}\n            </Link>\n          ))}\n        </div>\n        <MyComponent t={t} />\n      </div>\n      <div>{t('description.part2')}</div>\n      <hr />\n      <div>\n        <Link to=\"/second\">{t('goto.second')}</Link>\n      </div>\n    </div>\n  )\n}\n```\n\nTo persist the current locale, we will save it in a cookie.\nJust create a new `cookie.js` file:\n\n```javascript\nimport { createCookie } from 'remix'\n\nexport let i18nCookie = createCookie('i18n', {\n  sameSite: 'lax',\n  path: '/',\n})\n```\n\nAnd use it like this in `i18n.server.js`:\n```javascript\nimport { RemixI18Next } from 'remix-i18next'\nimport i18nextOptions from './i18nextOptions'\nimport Backend from 'i18next-fs-backend'\nimport { resolve } from 'node:path'\nimport { i18nCookie } from './cookie'\n\nexport default new RemixI18Next({\n  detection: {\n    // persist language selection in cookie\n    cookie: i18nCookie,\n    // This is the list of languages your application supports\n    supportedLanguages: i18nextOptions.supportedLngs,\n    // This is the language you want to use in case the user language is not\n    // listed above\n    fallbackLanguage: i18nextOptions.fallbackLng,\n  },\n  // This is the configuration for i18next used when translating messages server\n  // side only\n  i18next: {\n    backend: { loadPath: resolve('./public/locales/{{lng}}/{{ns}}.json') },\n  },\n  // The backend you want to use to load the translations\n  // Tip: You could pass `resources` to the `i18next` configuration and avoid\n  // a backend here\n  backend: Backend,\n})\n```\n\nand also in `root.jsx`:\n\n```javascript\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData\n} from '@remix-run/react'\nimport { json } from '@remix-run/node'\nimport { useChangeLanguage } from 'remix-i18next'\nimport remixI18n from './i18n.server'\nimport { useTranslation } from 'react-i18next'\nimport styles from './styles/index.css'\nimport { i18nCookie } from './cookie'\n\nexport const loader = async ({ request }) => {\n  const locale = await remixI18n.getLocale(request)\n  const t = await remixI18n.getFixedT(request, 'common')\n  const title = t('headTitle')\n  return json({ locale, title }, {\n    headers: {\"Set-Cookie\": await i18nCookie.serialize(locale)}\n  })\n}\n\nexport const handle = {\n  // In the handle export, we could add a i18n key with namespaces our route\n  // will need to load. This key can be a single string or an array of strings.\n  i18n: ['common']\n};\n\nexport function meta({ data }) {\n  return { title: data.title }\n}\n\nexport const links = () => {\n  return [{ rel: 'stylesheet', href: styles }]\n}\n\nexport default function App() {\n  const { i18n } = useTranslation()\n  const { locale } = useLoaderData()\n  \n  // This hook will change the i18n instance language to the current locale\n  // detected by the loader, this way, when we do something to change the\n  // language, this locale will change and i18next will load the correct\n  // translation files\n  useChangeLanguage(locale)\n\n  return (\n    <html lang={i18n.language}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Outlet />\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n```\n\nSo this means we're using the lng search parameter to change the language. And persist the current detected language in the cookie.\n\n![app](app.jpg \"locize © inweso GmbH\")\n![app de](app_de.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, the app is internationalized and we've just created our first language switcher!**\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/locize-remix-i18next-example/tree/local).*\n\n\n### The voluntary part <a name=\"voluntary\"></a>\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\nConnect to an awesome translation management system and manage your translations outside of your code.\n\nLet's synchronize the translation files with [locize](https://locize.com).\nThis can be done on-demand or on the CI-Server or before deploying the app.\n\n### What to do to reach this step:\n1. in locize: signup at https://locize.app/register and [login](https://docs.locize.com/integration/getting-started/create-a-user-account)\n2. in locize: [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n3. in locize: add all your additional languages (this can also be done via [API](https://docs.locize.com/integration/api#add-new-language))\n4. install the [locize-cli](https://github.com/locize/locize-cli) (`npm i locize-cli`)\n\n### Use the [locize-cli](https://github.com/locize/locize-cli)\nUse the `locize sync` command to synchronize your local repository (`public/locales`) with what is published on locize.\n\nAlternatively, you can also use the `locize download` command to always download the published locize translations to your local repository (`public/locales`) before bundling your app.\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about i18n in [Remix](https://remix.run), [remix-i18next](https://github.com/sergiodxa/remix-i18next), [i18next](https://www.i18next.com) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n## 👍\n\n*If you like to know how to unleash the full power of i18next, [check out **\"Part 2\"**](../remix-i18next/)!*\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"remix-i18next","slug":"remix-i18next","permalink":"https://locize.com/blog/tags/remix-i18next/"},{"name":"remix","slug":"remix","permalink":"https://locize.com/blog/tags/remix/"}]},{"title":"The key pieces to localize your software project","slug":"i18n-l10n-t9n-tms","date":"un22fin22","updated":"un00fin00","comments":true,"path":"i18n-l10n-t9n-tms/","link":"","permalink":"https://locize.com/blog/i18n-l10n-t9n-tms/","excerpt":"","text":"When it comes to software localization there are some important parts you have to address. If the term localization (l10n) is new to you, then take a look at this explanation or at this blog post about software localization. i18n - internationalization Where the software code is created, i18n is also to be found. Developers needs to instrumentalize the code to be able to be localized to various languages and regions. There are a lot of questions that should be answered here. More information Here you can read more about i18n and check if your software is ready for localization. To answer the questions about i18n, you will finally probably use a corresponding i18n framework that meets your needs. Advice When it comes to web localization, one of the most popular i18n frameworks is i18next. The biggest mistake one can do is looking on software localization as it’s only based on instrumenting your code and extract texts into resource files so you can translate them later. The requirements are clear: enable the application to be translated later but without time to think more about it. It ends with reaching the release day with an application ready to be published in one language. t9n - translation When the code is ready to be localized, someone needs to translate the content. You can have your translation done by freelancers, agencies or in-house employees. You can also start with some machine translation, but a translator should at least proofread the machine translated texts. Advice Use one of the integrated services to order the translations from a third party. Text translations are just one element in the localization process. You may also think of images, documents that differs not only for different languages, but also for different countries or regions. TMS - Translation Management System After having internationalized the code and knowing how the content is translated, how will these 2 parts interact with each other? What is Translation Management? Translation management is the systematic process and automation that manages translations and other digital assets, eliminating repetitive and laborious manual tasks while enabling progress overview and control, increasing collaboration and delivering greater efficiency. Manually merging translation files?One day (before release) the responsible for localization will knock at the developer&#39;s door and asking for the resource files to be translated. The developer will hand them out and deep in their mind the developer knows there will be some changes in the last days before release and even more changes after release. Some days/weeks later, the translated files will be ready and the developer will copy them to the repository but there are already a lot of changes. Some terms are not used anymore others are new and not yet translated. Might be the time for some tooling to help you manage your translations. Translation Management Systems are a great help. But still there is a gap between development and translation process. Files need to be exported / imported / merged and all while new content get added to be translated. The chaos is inevitable. There are a lot of translation management systems, choose the one that fits your needs. Modern translation management systems focuses on continuous localization. More information Not every continuous localization offered by the various translation management systems is the same. Check out the main differences here. New content in your application should be immediately available in your translation management tool for your translators and newly finished translations should be passed down to the application without a developer needing to add a file to the repository or accepting a PR from the translation management. Because software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously. Your localization and translation process should follow the same pattern as your software development. You should be able to deploy your translation files separated from your software so you can update and manage them independently. And if you do so, you have to make sure you can have more then one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software! Advice locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business. i18n, l10n, TMS - So which are the key pieces to localize your software project? i18next locize Translation services","raw":"---\ntitle: The key pieces to localize your software project\n\ndate: 2022-03-01\ntags:\n  - internationalization\n  - i18n\n  - i18next\n  - localization\n  - l10n\n  - translation management\n  - tms\n  - locize\n\nthumbnail: i18n-l10n-t9n-tms/puzzle.png\n---\n\n![](puzzle.png \"The key pieces to localize your software project\")\n\nWhen it comes to software localization there are some important parts you have to address.\n\nIf the term localization (l10n) is new to you, then take a look at [this explanation](../localization/) or at [this blog post about software localization](../what-is-software-localization/).\n\n\n## i18n - internationalization <a name=\"i18n\"></a>\n\nWhere the software code is created, [i18n](../what-is-i18n/) is also to be found. Developers needs to instrumentalize the code to be able to be localized to various languages and regions.\n\nThere are [a lot of questions](../is-your-software-ready-for-localization/) that should be answered here.\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n  <h3 style=\"color:orange; margin-bottom: 0px;\">More information</h3>\n  <p style=\"color:grey; margin-top: 5px;\"><a href=\"../what-is-i18n/\" title=\"What is i18n?\">Here</a> you can read more about i18n and check if <a href=\"../is-your-software-ready-for-localization/\" title=\"Is your software ready for localization?\">your software is ready for localization</a>.</p>\n</div>\n\nTo answer the questions about i18n, you will finally probably use a corresponding i18n framework that meets your needs.\n\n<div style=\"border-left: 0.5px solid limegreen;padding: 0.5rem 2rem\">\n  <h3 style=\"color:limegreen; margin-bottom: 0px;\">Advice</h3>\n  <p style=\"color:grey; margin-top: 5px;\">When it comes to web localization, one of the most popular i18n frameworks is <a href=\"https://www.i18next.com\" title=\"i18next - The best i18n frameworks for JavaScript\">i18next</a>.\n  <br />\n  <a href=\"https://www.i18next.com\" title=\"i18next - The best i18n frameworks for JavaScript\">\n    <img src=\"i18next-logo.png\" />\n  </a>\n  </p>\n</div>\n\n\nThe biggest mistake one can do is looking on software localization as it’s only based on instrumenting your code and extract texts into resource files so you can translate them later.\n\nThe requirements are clear: enable the application to be translated later but without time to think more about it. It ends with reaching the release day with an application ready to be published in one language.\n\n\n## t9n - translation <a name=\"t9n\"></a>\n\nWhen the code is ready to be localized, someone needs to translate the content.\n\nYou can have your translation done by freelancers, agencies or in-house employees. You can also start with some machine translation, but a translator should at least proofread the machine translated texts.\n\n<div style=\"border-left: 0.5px solid limegreen;padding: 0.5rem 2rem\">\n  <h3 style=\"color:limegreen; margin-bottom: 0px;\">Advice</h3>\n  <p style=\"color:grey; margin-top: 5px;\">Use one of the <a href=\"/services.html#translationservices\" title=\"Integrated professional translation partners\">integrated services</a> to order the translations from a third party.\n  </p>\n</div>\n\nText translations are just one element in the localization process. You may also think of images, documents that differs not only for different languages, but also for different countries or regions.\n\n\n## TMS - Translation Management System <a name=\"tms\"></a>\n\nAfter having internationalized the code and knowing how the content is translated, how will these 2 parts interact with each other?\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n  <h2 style=\"color:orange; margin-bottom: 0px;\">What is Translation Management?</h2>\n  <p style=\"color:grey; margin-top: 5px;\">Translation management is the systematic process and automation that manages translations and other digital assets, eliminating repetitive and laborious manual tasks while enabling progress overview and control, increasing collaboration and delivering greater efficiency.</p>\n</div>\n\n### Manually merging translation files?\n\nOne day (before release) the responsible for localization will knock at the developer's door and asking for the resource files to be translated. The developer will hand them out and deep in their mind the developer knows there will be some changes in the last days before release and even more changes after release.\n\nSome days/weeks later, the translated files will be ready and the developer will copy them to the repository but there are already a lot of changes. Some terms are not used anymore others are new and not yet translated.\n\nMight be the time for some tooling to help you manage your translations.\n\nTranslation Management Systems are a great help. But still there is a gap between development and translation process. Files need to be exported / imported / merged and all while new content get added to be translated. The chaos is inevitable.\n\nThere are a lot of translation management systems, choose the one that fits your needs.\n\nModern translation management systems focuses on [continuous localization](../modern-continuous-localization/).\n\n<div style=\"border-left: 0.5px solid orange;padding: 0.5rem 2rem\">\n  <h3 style=\"color:orange; margin-bottom: 0px;\">More information</h3>\n  <p style=\"color:grey; margin-top: 5px;\">Not every continuous localization offered by the various translation management systems is the same. Check out the main differences <a href=\"../modern-continuous-localization/\" title=\"Continuous Localization vs. Continuous Localization\">here</a>.</p>\n</div>\n\nNew content in your application should be immediately available in your translation management tool for your translators and newly finished translations should be passed down to the application without a developer needing to add a file to the repository or accepting a PR from the translation management.\n\nBecause software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously. Your localization and translation process should follow the same pattern as your software development. You should be able to deploy your translation files separated from your software so you can update and manage them independently. And if you do so, you have to make sure you can have more then one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software!\n\n<div style=\"border-left: 0.5px solid limegreen;padding: 0.5rem 2rem\">\n  <h3 style=\"color:limegreen; margin-bottom: 0px;\">Advice</h3>\n  <p style=\"color:grey; margin-top: 5px;\"><a href=\"https://www.locize.com\" title=\"locize - Bridging the gap between translation and development\">locize</a> removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n  <br />\n  <a href=\"https://www.locize.com\" title=\"locize - Bridging the gap between translation and development\">\n    <img src=\"locize-logo.png\" />\n  </a>\n  </p>\n</div>\n\n\n## i18n, l10n, TMS - So which are the key pieces to localize your software project?\n\n![](puzzle_specific.png \"The key pieces to localize your software project\")\n\n- [i18next](https://www.i18next.com)\n- [locize](https://www.locize.com)\n- [Translation services](https://locize.com/services.html#translationservices)\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation management","slug":"translation-management","permalink":"https://locize.com/blog/tags/translation-management/"},{"name":"tms","slug":"tms","permalink":"https://locize.com/blog/tags/tms/"}]},{"title":"I18N in the Multiverse of Formats","slug":"i18n-formats-javascript","date":"un55fin55","updated":"un66fin66","comments":true,"path":"i18n-formats-javascript/","link":"","permalink":"https://locize.com/blog/i18n-formats-javascript/","excerpt":"","text":"Every night... I dream the same dream. And then... the nightmare begins. I do what I have to do... to protect i18n. With this blog post I open a doorway between universes, and I don&#39;t know who or what will walk through it... What do you know about the i18n format multiverse? Some folks have their theories... they believe it is dangerous. I think they are right... but I want you at least to know that other parallel universes exist and what they look like. ClarificationThere are far more i18n formats than the ones I am listing here. In order not to get lost in the madness of the infinite i18n format universes, I limit myself here to the first eight formats used in the JavaScript ecosystem that I was able to find. To define some sort of sorting, the formats are listed based on their weekly downloads: i18next ICU Message Format vue-i18n i18n-js Polyglot.js Gettext FBT Fluent i18next One of the most popular i18n format is the one used by the i18n framework i18next. It is usually a JSON based format with ability to do plurals (also for languages with multiple plural forms), context, interpolation, formatting, nesting and more. Let&#39;s imagine, we would like to show these text based on how many of which dessert I would like to eat: I would like to eat a cake. I would like to eat 3 muffins. I would like to eat something. So we can choose to eat what and how much to eat. With this format it would look like this: 1234567&#123; &quot;dessert_cake_one&quot;: &quot;I would like to eat a cake.&quot;, &quot;dessert_muffin_one&quot;: &quot;I would like to eat a muffin.&quot;, &quot;dessert_cake_other&quot;: &quot;I would like to eat &#123;&#123;count&#125;&#125; cakes.&quot;, &quot;dessert_muffin_other&quot;: &quot;I would like to eat &#123;&#123;count&#125;&#125; muffins.&quot;, &quot;dessert&quot;: &quot;I would like to eat something.&quot;&#125; And the instrumented code may look like this (may differ, based on your chosen technology): 12345i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;cake&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;muffin&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a muffin.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;cake&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 cakes.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;muffin&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 muffins.&quot;i18next.t(&#x27;dessert&#x27;) // -&gt; &quot;I would like to eat something.&quot; You see the translation key remains the same for each invocation, and the context and count option differs. btw: for a languages with multiple plural forms, the instrumented code keeps as is, but the translation json would be different. This is an &quot;englishified&quot; example for Arabic plural rules (so most people can read it): The plural rule for arabic is like this: plural form example count zero 0 one 1 two 2 few 3-10, 103-110, 1003, … many 11-26, 111, 1011, … other 100-102, 200-202, 300-302, 400-402, 500-502, 600, 1000, 10000, 100000, 1000000, … 123456789101112131415&#123; &quot;dessert_cake_zero&quot;: &quot;I would like to eat no cake.&quot;, &quot;dessert_muffin_zero&quot;: &quot;I would like to eat no muffin.&quot;, &quot;dessert_cake_one&quot;: &quot;I would like to eat a cake.&quot;, &quot;dessert_muffin_one&quot;: &quot;I would like to eat a muffin.&quot;, &quot;dessert_cake_two&quot;: &quot;I would like to eat two cakes.&quot;, &quot;dessert_muffin_two&quot;: &quot;I would like to eat two muffins.&quot;, &quot;dessert_cake_few&quot;: &quot;I would like to eat a few cakes.&quot;, &quot;dessert_muffin_few&quot;: &quot;I would like to eat a few muffins.&quot;, &quot;dessert_cake_many&quot;: &quot;I would like to eat many cakes.&quot;, &quot;dessert_muffin_many&quot;: &quot;I would like to eat many muffins.&quot;, &quot;dessert_cake_other&quot;: &quot;I would like to eat &#123;&#123;count&#125;&#125; cakes.&quot;, &quot;dessert_muffin_other&quot;: &quot;I would like to eat &#123;&#123;count&#125;&#125; muffins.&quot;, &quot;dessert&quot;: &quot;I would like to eat something.&quot;&#125; 123456i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;cake&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;muffin&#x27;, count: 2 &#125;) // -&gt; &quot;I would like to eat two muffins.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;cake&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat a few cakes.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;muffin&#x27;, count: 13 &#125;) // -&gt; &quot;I would like to eat many muffins.&quot;i18next.t(&#x27;dessert&#x27;, &#123; context: &#x27;cake&#x27;, count: 100 &#125;) // -&gt; &quot;I would like to eat 100 cakes.&quot;i18next.t(&#x27;dessert&#x27;) // -&gt; &quot;I would like to eat something.&quot; With nesting we can also reduce the repetitions: 12345678&#123; &quot;eat&quot;: &quot;I would like to eat&quot;, &quot;dessert_cake_one&quot;: &quot;$t(eat) a cake.&quot;, &quot;dessert_muffin_one&quot;: &quot;$t(eat) a muffin.&quot;, &quot;dessert_cake_other&quot;: &quot;$t(eat) &#123;&#123;count&#125;&#125; cakes.&quot;, &quot;dessert_muffin_other&quot;: &quot;$t(eat) &#123;&#123;count&#125;&#125; muffins.&quot;, &quot;dessert&quot;: &quot;$t(eat) something.&quot;&#125; But it may be that the translators like this nesting substitution less. ICU Message Format The second format is the ICU Message Format. There are multiple JavaScript modules implementing the ICU message syntax. One of the most used is intl-messageformat by Format.js. It is used behind the scenes also in react-intl. It is also a key/value based format that could be stored in a JSON or however you like: 123456789101112131415161718import &#123; createIntl &#125; from &#x27;@formatjs/intl&#x27;const intl = createIntl(&#123; locale: &#x27;en&#x27;, messages: &#123; dessert: `I would like to eat &#123;what, select, cake &#123;&#123;count, plural, one &#123;a cake&#125; other &#123;&#123;count&#125; cakes&#125; &#125;&#125; muffin &#123;&#123;count, plural, one &#123;a muffin&#125; other &#123;&#123;count&#125; muffins&#125; &#125;&#125; other &#123;something&#125; &#125;.`, &#125;,&#125;) It also offers plural and select, and the instrumented code may look like this (may differ, based on your chosen technology): Compared to the previous format, this one uses only 1 key to generate all variations. So the value may look a bit more complex. 12345intl.formatMessage(&#123; id: &#x27;dessert&#x27; &#125;, &#123; what: &#x27;cake&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;intl.formatMessage(&#123; id: &#x27;dessert&#x27; &#125;, &#123; what: &#x27;muffin&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a muffin.&quot;intl.formatMessage(&#123; id: &#x27;dessert&#x27; &#125;, &#123; what: &#x27;cake&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 cakes.&quot;intl.formatMessage(&#123; id: &#x27;dessert&#x27; &#125;, &#123; what: &#x27;muffin&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 muffins.&quot;intl.formatMessage(&#123; id: &#x27;dessert&#x27; &#125;, &#123; what: undefined &#125;) // -&gt; &quot;I would like to eat something.&quot; Also here the translation key remains the same for each invocation, and the context and count option differs. vue-i18n The next found format, while exploring the multiverse, is the vue-i18n format. It is used practically only in the vue-i18n framework itself. It is also able to do some interpolation with formatting, pluralization and more. But a context feature is missing. This is how our example would look like: 123456789101112import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;const i18n = createI18n(&#123; fallbackLocale: &#x27;en&#x27;, messages: &#123; en: &#123; dessert_cake: &#x27;I would like to eat a cake. | I would like to eat &#123;count&#125; cakes.&#x27;, dessert_muffin: &#x27;I would like to eat a muffin. | I would like to eat &#123;count&#125; muffins.&#x27;, dessert: &#x27;I would like to eat something.&#x27; &#125; &#125;&#125;) And the corresponding invocation: 12345$t(&#x27;dessert_cake&#x27;, &#123; count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;$t(&#x27;dessert_muffin&#x27;, &#123; count: 1 &#125;) // -&gt; &quot;I would like to eat a muffin.&quot;$t(&#x27;dessert_cake&#x27;, &#123; count: 5 &#125;) // -&gt; &quot;I would like to eat 5 cakes.&quot;$t(&#x27;dessert_muffin&#x27;, &#123; count: 5 &#125;) // -&gt; &quot;I would like to eat 5 muffins.&quot;$t(&#x27;dessert&#x27;) // -&gt; &quot;I would like to eat something.&quot; Compared the the previous formats, this one needs to change the translation key to accomplish a context like feature. i18n-js The origin of this format start Ruby. The i18n-js format is a direct export of translations defined by Ruby on Rails. To export the translations, a Ruby gem can be used, that&#39;s completely disconnected from Rails and that can be used for the solely purpose of exporting the translations, even if your project is written in a different language. For JavaScript there&#39;s a companion JavaScript package. It comes bundled with all base translations made available by rails-i18n. Base translations allow formatting date, numbers, and sentence connectors, among other things. The used JSON based format will look like this: 1234567891011&#123; &quot;dessert_cake&quot;: &#123; &quot;one&quot;: &quot;I would like to eat a cake.&quot;, &quot;other&quot;: &quot;I would like to eat %&#123;count&#125; cakes.&quot; &#125;, &quot;dessert_muffin&quot;: &#123; &quot;one&quot;: &quot;I would like to eat a muffin.&quot;, &quot;other&quot;: &quot;I would like to eat %&#123;count&#125; muffins.&quot; &#125;, &quot;dessert&quot;: &quot;I would like to eat something.&quot;&#125; The pluralization keys are organized nested under the normal translation key. And the corresponding invocation: 12345i18n.t(&#x27;dessert_cake&#x27;, &#123; count: 1 &#125;); // -&gt; &quot;I would like to eat a cake.&quot;i18n.t(&#x27;dessert_muffin&#x27;, &#123; count: 1 &#125;); // -&gt; &quot;I would like to eat a muffin.&quot;i18n.t(&#x27;dessert_cake&#x27;, &#123; count: 5 &#125;); // -&gt; &quot;I would like to eat 5 cakes.&quot;i18n.t(&#x27;dessert_muffin&#x27;, &#123; count: 5 &#125;); // -&gt; &quot;I would like to eat 5 muffins.&quot;i18n.t(&#x27;dessert&#x27;); // -&gt; &quot;I would like to eat something.&quot; Also this format needs to change the translation key to accomplish a context like feature. Polyglot.js This older format provides a solution for interpolation and pluralization, based off of Airbnb’s experience. Polyglot.js adds basic i18n functionality to Airbnb&#39;s Backbone.js and Node.js apps. This format uses only 3 keys, but... 12345&#123; &quot;dessert_cake&quot;: &quot;I would like to eat a cake. |||| I would like to eat %&#123;smart_count&#125; cakes.&quot;, &quot;dessert_muffin&quot;: &quot;I would like to eat a muffin. |||| I would like to eat %&#123;smart_count&#125; muffins.&quot;, &quot;dessert&quot;: &quot;I would like to eat something.&quot;&#125; The plural forms are merged in a single value separated by the delimiter |||| (4 vertical pipe characters). And the corresponding invocation: 12345polyglot.t(&#x27;dessert_cake&#x27;, &#123; smart_count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;polyglot.t(&#x27;dessert_muffin&#x27;, &#123; smart_count: 1 &#125;) // -&gt; &quot;I would like to eat a muffin.&quot;polyglot.t(&#x27;dessert_cake&#x27;, &#123; smart_count: 5 &#125;) // -&gt; &quot;I would like to eat 5 cakes.&quot;polyglot.t(&#x27;dessert_muffin&#x27;, &#123; smart_count: 5 &#125;) // -&gt; &quot;I would like to eat 5 muffins.&quot;polyglot.t(&#x27;dessert&#x27;) // -&gt; &quot;I would like to eat something.&quot; Also this format needs to change the translation key to accomplish a context like feature. Gettext Gettext is a very old translation standard. There are implementations of Gettext in a lot of programming languages. Jed is one of the most used gettext implementations for JavaScript. Jed doesn&#39;t include a Gettext file parser, but several third-party parsers exist that can have their output adapted for Jed. So an original Gettext po format... 12345678910111213141516171819202122232425msgid &quot;&quot;msgstr &quot;&quot;&quot;MIME-Version: 1.0\\n&quot;&quot;Content-Type: text/plain; charset=UTF-8\\n&quot;&quot;Content-Transfer-Encoding: 8bit\\n&quot;&quot;lang: en\\n&quot;&quot;plural_forms: nplurals=2; plural=(n != 1);\\n&quot;#: msgid &quot;dessert&quot;msgstr &quot;I would like to eat something.&quot;#: msgctxt &quot;cake&quot;msgid &quot;dessert&quot;msgid_plural &quot;I would like to eat %d cakes.&quot;msgstr[0] &quot;I would like to eat a cake.&quot;msgstr[1] &quot;I would like to eat %d cakes.&quot;#: msgctxt &quot;muffin&quot;msgid &quot;dessert&quot;msgid_plural &quot;I would like to eat %d muffins.&quot;msgstr[0] &quot;I would like to eat a muffin.&quot;msgstr[1] &quot;I would like to eat %d muffins.&quot; ...would look like this when used in Jed: 123456789101112131415161718192021const i18n = new Jed(&#123; locale_data: &#123; messages: &#123; &quot;&quot;: &#123; domain: &quot;messages&quot;, lang: &quot;en&quot;, plural_forms: &quot;nplurals=2; plural=(n != 1);&quot; &#125;, &quot;cake\\u0004dessert&quot;: [ &quot;I would like to eat a cake.&quot;, &quot;I would like to eat %d cakes.&quot; ], &quot;muffin\\u0004dessert&quot;: [ &quot;I would like to eat a muffin.&quot;, &quot;I would like to eat %d muffins.&quot; ], dessert: [&quot;I would like to eat something.&quot;] &#125; &#125;&#125;) Not very intuitive, but it works. 12345i18n.translate(&#x27;dessert&#x27;).withContext(&#x27;cake&#x27;).fetch() // -&gt; &quot;I would like to eat a cake.&quot;i18n.translate(&#x27;dessert&#x27;).withContext(&#x27;muffin&#x27;).fetch() // -&gt; &quot;I would like to eat a muffin.&quot;i18n.translate(&#x27;dessert&#x27;).withContext(&#x27;cake&#x27;).ifPlural(5).fetch(5) // -&gt; &quot;I would like to eat 5 cakes.&quot;i18n.translate(&#x27;dessert&#x27;).withContext(&#x27;muffin&#x27;).ifPlural(5).fetch(5) // -&gt; &quot;I would like to eat 5 muffins.&quot;i18n.translate(&#x27;dessert&#x27;).fetch() // -&gt; &quot;I would like to eat something.&quot; This format offers, pluralization, interpolation and a context feature, but a strange API in my opinion. FBT Of all the formats encountered in the i18n multiverse, this format is arguably the most distant universe, or should I say: most distant &quot;metaverse&quot; ;-) FBT is invented, used and maintained by Facebook. It is... special. It comes with text extraction and at the center are not the translations but your code. So first you need to instrument your code: 1234567891011121314151617181920212223&lt;fbt desc=&quot;eating cake&quot;&gt; I would like to eat &lt;fbt:plural count=&#123;1&#125; name=&quot;number of cakes&quot; showCount=&quot;ifMany&quot; many=&quot;cakes&quot;&gt; a cake &lt;/fbt:plural&gt;.&lt;/fbt&gt; &lt;!-- &quot;I would like to eat a cake.&quot; --&gt;&lt;fbt desc=&quot;eating muffin&quot;&gt; I would like to eat &lt;fbt:plural count=&#123;5&#125; name=&quot;number of muffins&quot; showCount=&quot;ifMany&quot; many=&quot;muffins&quot;&gt; a muffin &lt;/fbt:plural&gt;.&lt;/fbt&gt; &lt;!-- &quot;I would like to eat 5 muffins.&quot; --&gt;&lt;fbt desc=&quot;eating something&quot;&gt; I would like to eat something.&lt;/fbt&gt; &lt;!-- &quot;I would like to eat something.&quot; --&gt; Run some scripts, and then you can use the prepared translation files: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;fb-locale&quot;: &quot;en&quot;, &quot;translations&quot;: &#123; &quot;bxFNG7FeHhfvzOcxJ4WpXA==&quot;: &#123; &quot;tokens&quot;: [], &quot;translations&quot;: [ &#123; &quot;translation&quot;: &quot;I would like to eat &#123;number of cakes&#125; cakes.&quot;, &quot;variations&quot;: &#123;&#125; &#125; ], &quot;types&quot;: [] &#125;, &quot;1kfdpAZKBoeV6P/6/jU9BQ==&quot;: &#123; &quot;tokens&quot;: [], &quot;translations&quot;: [ &#123; &quot;translation&quot;: &quot;I would like to eat a cake.&quot;, &quot;variations&quot;: &#123;&#125; &#125; ], &quot;types&quot;: [] &#125;, &quot;Yglr/cfclqA86jmKXJXtjg==&quot;: &#123; &quot;tokens&quot;: [], &quot;translations&quot;: [ &#123; &quot;translation&quot;: &quot;I would like to eat &#123;number of muffins&#125; muffins.&quot;, &quot;variations&quot;: &#123;&#125; &#125; ], &quot;types&quot;: [] &#125;, &quot;Ic2KkQ3gBr6AUcgtsH576g==&quot;: &#123; &quot;tokens&quot;: [], &quot;translations&quot;: [ &#123; &quot;translation&quot;: &quot;I would like to eat a muffin.&quot;, &quot;variations&quot;: &#123;&#125; &#125; ], &quot;types&quot;: [] &#125;, &quot;r2YYz0TzAkH0b0TSwFMEAw==&quot;: &#123; &quot;tokens&quot;: [], &quot;translations&quot;: [ &#123; &quot;translation&quot;: &quot;I would like to eat something.&quot;, &quot;variations&quot;: &#123;&#125; &#125; ], &quot;types&quot;: [] &#125; &#125;&#125; Each instrumented code part is mapped with a hash to the translations. Like said... it&#39;s really different than all other formats. Fluent The last format in this multiverse trip is Fluent a Mozilla project. The Fluent format shares a lot of philosophy that drove the design of ICU Message Format. It&#39;s also a key/value based format: 1234567891011121314151617181920212223242526import &#123; FluentBundle, FluentResource &#125; from &quot;@fluent/bundle&quot;;const resource = new FluentResource(`dessert = I would like to eat &#123;$toEat -&gt; [cake] &#123;$count -&gt; [one] a cake *[other] &#123;$count&#125; cakes &#125; [muffin] &#123;$count -&gt; [one] a muffin *[other] &#123;$count&#125; muffins &#125; *[other] something &#125;.`)const bundle = new FluentBundle(&#x27;en&#x27;)bundle.addResource(resource)bundle.formatPattern(bundle.getMessage(&#x27;dessert&#x27;).value, &#123; toEat: &#x27;cake&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a cake.&quot;bundle.formatPattern(bundle.getMessage(&#x27;dessert&#x27;).value, &#123; toEat: &#x27;muffin&#x27;, count: 1 &#125;) // -&gt; &quot;I would like to eat a muffin.&quot;bundle.formatPattern(bundle.getMessage(&#x27;dessert&#x27;).value, &#123; toEat: &#x27;cake&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 cakes.&quot;bundle.formatPattern(bundle.getMessage(&#x27;dessert&#x27;).value, &#123; toEat: &#x27;muffin&#x27;, count: 5 &#125;) // -&gt; &quot;I would like to eat 5 muffins.&quot;bundle.formatPattern(bundle.getMessage(&#x27;dessert&#x27;).value, &#123; toEat: &#x27;&#x27; &#125;) // -&gt; &quot;I would like to eat something.&quot; Like ICU Message Format it uses only 1 key to generate all variations. So the value may look a bit more complex, like a language on its own. Coming back home We looked through the portals of the i18n multiverse and got a few small first impressions about the various formats. Some are very similar and some others are really different. In the end it&#39;s a matter of taste. Which format do you feel comfortable with? The most important thing is that all team members are comfortable with it, and that all tools in the localization process supports that format. So choose your translation management system (TMS) carefully. Looking at the history of the currently most used i18n format, we can see the the creators of i18next are also the founders of a great translation management system. So with choosing locize you directly support the future of i18next. ➡️ i18next + locize = true continuous localization Watch the demo video to learn more:","raw":"---\ntitle: I18N in the Multiverse of Formats\ndescription: A nice overview of the existing i18n formats for JavaScript.\ndate: 2022-02-18\n\ntags:\n  - internationalization\n  - i18n\n  - localization\n  - l10n\n  - i18next\nthumbnail: i18n-formats-javascript/i18n_in_the_multiverse_of_madness.jpg\nredirect_from:\n- /i18n-multiverse\n\nlabel: i18n-formats-javascript\nlang: en\n---\n\n![](i18n_in_the_multiverse_of_madness.jpg \"I18N in the Multiverse of Madness\")\n\n*Every night... I dream the same dream. And then... the nightmare begins.*\n<br />\n*I do what I have to do... to protect i18n.*\n<br />\n*With this blog post I open a doorway between universes, and I don't know who or what will walk through it...*\n\n\n>What do you know about the i18n format multiverse?\n\nSome folks have their theories... they believe it is dangerous.\n<br />\nI think they are right... but I want you at least to know that other parallel universes exist and what they look like.\n\n\n### Clarification\n\nThere are far more i18n formats than the ones I am listing here.\nIn order not to get lost in the madness of the infinite i18n format universes, I limit myself here to the first eight formats used in the JavaScript ecosystem that I was able to find.\n\nTo define some sort of sorting, the formats are listed based on their weekly [downloads](https://www.npmtrends.com/i18next-vs-intl-messageformat-vs-vue-i18n-vs-i18n-js-vs-node-polyglot-vs-jed-vs-fbt-vs-@fluent/bundle):\n![](npmtrends.jpg)\n\n\n* [i18next](#i18next)\n* [ICU Message Format](#icu)\n* [vue-i18n](#vue-i18n)\n* [i18n-js](#i18n-js)\n* [Polyglot.js](#polyglot)\n* [Gettext](#gettext)\n* [FBT](#fbt)\n* [Fluent](#fluent)\n\n\n## i18next <a name=\"i18next\"></a>\n\nOne of the most popular i18n format is the one used by the i18n framework [i18next](https://www.i18next.com).\n<br />\nIt is usually a [JSON based format](https://www.i18next.com/misc/json-format) with ability to do [plurals](https://www.i18next.com/translation-function/plurals) (also for languages with [multiple plural forms](https://www.i18next.com/translation-function/plurals#languages-with-multiple-plurals)), [context](https://www.i18next.com/translation-function/context), [interpolation](https://www.i18next.com/translation-function/interpolation), [formatting](https://www.i18next.com/translation-function/formatting), [nesting](https://www.i18next.com/translation-function/nesting) and more.\n\nLet's imagine, we would like to show these text based on how many of which dessert I would like to eat:\n\n- I would like to eat a cake.\n- I would like to eat 3 muffins.\n- I would like to eat something.\n\nSo we can choose to eat what and how much to eat.\n\nWith this format it would look like this:\n```json\n{\n  \"dessert_cake_one\": \"I would like to eat a cake.\",\n  \"dessert_muffin_one\": \"I would like to eat a muffin.\",\n  \"dessert_cake_other\": \"I would like to eat {{count}} cakes.\",\n  \"dessert_muffin_other\": \"I would like to eat {{count}} muffins.\",\n  \"dessert\": \"I would like to eat something.\"\n}\n```\n\nAnd the instrumented code may look like this *(may differ, based on your chosen technology)*:\n```js\ni18next.t('dessert', { context: 'cake', count: 1 }) // -> \"I would like to eat a cake.\"\ni18next.t('dessert', { context: 'muffin', count: 1 }) // -> \"I would like to eat a muffin.\"\ni18next.t('dessert', { context: 'cake', count: 5 }) // -> \"I would like to eat 5 cakes.\"\ni18next.t('dessert', { context: 'muffin', count: 5 }) // -> \"I would like to eat 5 muffins.\"\ni18next.t('dessert') // -> \"I would like to eat something.\"\n```\n\nYou see the translation key remains the same for each invocation, and the `context` and `count` option differs.\n\nbtw: for a languages with multiple plural forms, the instrumented code keeps as is, but the translation json would be different.\n<br />\nThis is an \"englishified\" example for Arabic plural rules *(so most people can read it)*:\n<br />\n*The [plural rule](https://unicode-org.github.io/cldr-staging/charts/37/supplemental/language_plural_rules.html) for arabic is like this:*\n\n| plural form | example count |\n|---|---|\n| zero | 0 |\n| one | 1 |\n| two | 2 |\n| few | 3-10, 103-110, 1003, … |\n| many | 11-26, 111, 1011, … |\n| other | 100-102, 200-202, 300-302, 400-402, 500-502, 600, 1000, 10000, 100000, 1000000, … |\n\n```json\n{\n  \"dessert_cake_zero\": \"I would like to eat no cake.\",\n  \"dessert_muffin_zero\": \"I would like to eat no muffin.\",\n  \"dessert_cake_one\": \"I would like to eat a cake.\",\n  \"dessert_muffin_one\": \"I would like to eat a muffin.\",\n  \"dessert_cake_two\": \"I would like to eat two cakes.\",\n  \"dessert_muffin_two\": \"I would like to eat two muffins.\",\n  \"dessert_cake_few\": \"I would like to eat a few cakes.\",\n  \"dessert_muffin_few\": \"I would like to eat a few muffins.\",\n  \"dessert_cake_many\": \"I would like to eat many cakes.\",\n  \"dessert_muffin_many\": \"I would like to eat many muffins.\",\n  \"dessert_cake_other\": \"I would like to eat {{count}} cakes.\",\n  \"dessert_muffin_other\": \"I would like to eat {{count}} muffins.\",\n  \"dessert\": \"I would like to eat something.\"\n}\n```\n\n```js\ni18next.t('dessert', { context: 'cake', count: 1 }) // -> \"I would like to eat a cake.\"\ni18next.t('dessert', { context: 'muffin', count: 2 }) // -> \"I would like to eat two muffins.\"\ni18next.t('dessert', { context: 'cake', count: 5 }) // -> \"I would like to eat a few cakes.\"\ni18next.t('dessert', { context: 'muffin', count: 13 }) // -> \"I would like to eat many muffins.\"\ni18next.t('dessert', { context: 'cake', count: 100 }) // -> \"I would like to eat 100 cakes.\"\ni18next.t('dessert') // -> \"I would like to eat something.\"\n```\n\nWith nesting we can also reduce the repetitions:\n```json\n{\n  \"eat\": \"I would like to eat\",\n  \"dessert_cake_one\": \"$t(eat) a cake.\",\n  \"dessert_muffin_one\": \"$t(eat) a muffin.\",\n  \"dessert_cake_other\": \"$t(eat) {{count}} cakes.\",\n  \"dessert_muffin_other\": \"$t(eat) {{count}} muffins.\",\n  \"dessert\": \"$t(eat) something.\"\n}\n```\nBut it may be that the translators like this nesting substitution less.\n\n\n## ICU Message Format <a name=\"icu\"></a>\n\nThe second format is the [ICU Message Format](https://unicode-org.github.io/icu/userguide/format_parse/messages/).\n<br />\nThere are multiple JavaScript modules implementing the ICU message syntax. One of the most used is [intl-messageformat](https://formatjs.io/docs/core-concepts/icu-syntax/) by [Format.js](https://formatjs.io). It is used behind the scenes also in [react-intl](https://formatjs.io/docs/react-intl).\n\nIt is also a key/value based format that could be stored in a JSON or however you like:\n```js\nimport { createIntl } from '@formatjs/intl'\n\nconst intl = createIntl({\n  locale: 'en',\n  messages: {\n    dessert: `I would like to eat {what, select,\n      cake {{count, plural,\n        one {a cake}\n        other {{count} cakes}\n      }}\n      muffin {{count, plural,\n        one {a muffin}\n        other {{count} muffins}\n      }}\n      other {something}\n    }.`,\n  },\n})\n```\n\nIt also offers plural and select, and the instrumented code may look like this *(may differ, based on your chosen technology)*:\n<br />\nCompared to the previous format, this one uses only 1 key to generate all variations. So the value may look a bit more complex.\n\n```js\nintl.formatMessage({ id: 'dessert' }, { what: 'cake', count: 1 }) // -> \"I would like to eat a cake.\"\nintl.formatMessage({ id: 'dessert' }, { what: 'muffin', count: 1 }) // -> \"I would like to eat a muffin.\"\nintl.formatMessage({ id: 'dessert' }, { what: 'cake', count: 5 }) // -> \"I would like to eat 5 cakes.\"\nintl.formatMessage({ id: 'dessert' }, { what: 'muffin', count: 5 }) // -> \"I would like to eat 5 muffins.\"\nintl.formatMessage({ id: 'dessert' }, { what: undefined }) // -> \"I would like to eat something.\"\n```\n\nAlso here the translation key remains the same for each invocation, and the context and count option differs.\n\n\n## vue-i18n <a name=\"vue-i18n\"></a>\n\nThe next found format, while exploring the multiverse, is the [vue-i18n format](https://kazupon.github.io/vue-i18n/guide/messages.html#structure). It is used practically only in the [vue-i18n](https://kazupon.github.io/vue-i18n/) framework itself.\n<br />\nIt is also able to do some [interpolation with formatting](https://kazupon.github.io/vue-i18n/guide/formatting.html#named-formatting), [pluralization](https://kazupon.github.io/vue-i18n/guide/pluralization.html) and more. But a context feature is missing.\n\nThis is how our example would look like:\n\n```js\nimport { createI18n } from 'vue-i18n'\n\nconst i18n = createI18n({\n  fallbackLocale: 'en',\n  messages: {\n    en: {\n      dessert_cake: 'I would like to eat a cake. | I would like to eat {count} cakes.',\n      dessert_muffin: 'I would like to eat a muffin. | I would like to eat {count} muffins.',\n      dessert: 'I would like to eat something.'\n    }\n  }\n})\n```\n\nAnd the corresponding invocation:\n```js\n$t('dessert_cake', { count: 1 }) // -> \"I would like to eat a cake.\"\n$t('dessert_muffin', { count: 1 }) // -> \"I would like to eat a muffin.\"\n$t('dessert_cake', { count: 5 }) // -> \"I would like to eat 5 cakes.\"\n$t('dessert_muffin', { count: 5 }) // -> \"I would like to eat 5 muffins.\"\n$t('dessert') // -> \"I would like to eat something.\"\n```\n\nCompared the the previous formats, this one needs to change the translation key to accomplish a context like feature.\n\n\n## i18n-js <a name=\"i18n-js\"></a>\n\nThe origin of this format start Ruby. The [i18n-js format](https://www.npmjs.com/package/i18n-js) is a direct export of translations defined by [Ruby on Rails](https://guides.rubyonrails.org/i18n.html).\n<br />\nTo export the translations, a [Ruby gem](https://github.com/fnando/i18n-js) can be used, that's completely disconnected from Rails and that can be used for the solely purpose of exporting the translations, even if your project is written in a different language.\n<br />\nFor JavaScript there's a companion JavaScript [package](https://www.npmjs.com/package/i18n-js).\nIt comes bundled with all base translations made available by [rails-i18n](https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale). Base translations allow formatting date, numbers, and sentence connectors, among other things.\n\nThe used JSON based format will look like this:\n\n```json\n{\n  \"dessert_cake\": {\n    \"one\": \"I would like to eat a cake.\",\n    \"other\": \"I would like to eat %{count} cakes.\"\n  },\n  \"dessert_muffin\": {\n    \"one\": \"I would like to eat a muffin.\",\n    \"other\": \"I would like to eat %{count} muffins.\"\n  },\n  \"dessert\": \"I would like to eat something.\"\n}\n```\n\nThe pluralization keys are organized nested under the normal translation key.\n\nAnd the corresponding invocation:\n```js\ni18n.t('dessert_cake', { count: 1 }); // -> \"I would like to eat a cake.\"\ni18n.t('dessert_muffin', { count: 1 }); // -> \"I would like to eat a muffin.\"\ni18n.t('dessert_cake', { count: 5 }); // -> \"I would like to eat 5 cakes.\"\ni18n.t('dessert_muffin', { count: 5 }); // -> \"I would like to eat 5 muffins.\"\ni18n.t('dessert'); // -> \"I would like to eat something.\"\n```\n\nAlso this format needs to change the translation key to accomplish a context like feature.\n\n\n## Polyglot.js <a name=\"polyglot\"></a>\n\nThis older format provides a solution for interpolation and pluralization, based off of [Airbnb](https://www.airbnb.com)’s experience.\n<br />\n[Polyglot.js](https://airbnb.io/polyglot.js/) adds basic i18n functionality to Airbnb's Backbone.js and Node.js apps.\n\nThis format uses only 3 keys, but...\n\n```json\n{\n  \"dessert_cake\": \"I would like to eat a cake. |||| I would like to eat %{smart_count} cakes.\",\n  \"dessert_muffin\": \"I would like to eat a muffin. |||| I would like to eat %{smart_count} muffins.\",\n  \"dessert\": \"I would like to eat something.\"\n}\n```\n\nThe plural forms are merged in a single value separated by the delimiter `||||` *(4 vertical pipe characters)*.\n\nAnd the corresponding invocation:\n```js\npolyglot.t('dessert_cake', { smart_count: 1 }) // -> \"I would like to eat a cake.\"\npolyglot.t('dessert_muffin', { smart_count: 1 }) // -> \"I would like to eat a muffin.\"\npolyglot.t('dessert_cake', { smart_count: 5 }) // -> \"I would like to eat 5 cakes.\"\npolyglot.t('dessert_muffin', { smart_count: 5 }) // -> \"I would like to eat 5 muffins.\"\npolyglot.t('dessert') // -> \"I would like to eat something.\"\n```\n\nAlso this format needs to change the translation key to accomplish a context like feature.\n\n\n## Gettext <a name=\"gettext\"></a>\n\n[Gettext](http://www.gnu.org/software/gettext/) is a very old translation standard. There are implementations of Gettext in a lot of programming languages.\n<br />\n[Jed](https://messageformat.github.io/Jed/) is one of the most used gettext implementations for JavaScript. Jed doesn't include a Gettext file parser, but several third-party parsers exist that can have their output adapted for Jed.\n\nSo an original Gettext po format...\n\n```txt\nmsgid \"\"\nmsgstr \"\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\"lang: en\\n\"\n\"plural_forms: nplurals=2; plural=(n != 1);\\n\"\n\n#: \nmsgid \"dessert\"\nmsgstr \"I would like to eat something.\"\n\n#: \nmsgctxt \"cake\"\nmsgid \"dessert\"\nmsgid_plural \"I would like to eat %d cakes.\"\nmsgstr[0] \"I would like to eat a cake.\"\nmsgstr[1] \"I would like to eat %d cakes.\"\n\n#: \nmsgctxt \"muffin\"\nmsgid \"dessert\"\nmsgid_plural \"I would like to eat %d muffins.\"\nmsgstr[0] \"I would like to eat a muffin.\"\nmsgstr[1] \"I would like to eat %d muffins.\"\n```\n\n...would look like this when used in Jed:\n\n```js\nconst i18n = new Jed({\n  locale_data: {\n    messages: {\n      \"\": {\n        domain: \"messages\",\n        lang: \"en\",\n        plural_forms: \"nplurals=2; plural=(n != 1);\"\n      },\n\n      \"cake\\u0004dessert\": [\n        \"I would like to eat a cake.\",\n        \"I would like to eat %d cakes.\"\n      ],\n      \"muffin\\u0004dessert\": [\n        \"I would like to eat a muffin.\",\n        \"I would like to eat %d muffins.\"\n      ],\n      dessert: [\"I would like to eat something.\"]\n    }\n  }\n})\n```\n\nNot very intuitive, but it works.\n\n```js\ni18n.translate('dessert').withContext('cake').fetch() // -> \"I would like to eat a cake.\"\ni18n.translate('dessert').withContext('muffin').fetch() // -> \"I would like to eat a muffin.\"\ni18n.translate('dessert').withContext('cake').ifPlural(5).fetch(5) // -> \"I would like to eat 5 cakes.\"\ni18n.translate('dessert').withContext('muffin').ifPlural(5).fetch(5) // -> \"I would like to eat 5 muffins.\"\ni18n.translate('dessert').fetch() // -> \"I would like to eat something.\"\n```\n\nThis format offers, pluralization, interpolation and a context feature, but a strange API in my opinion.\n\n\n## FBT <a name=\"fbt\"></a>\n\nOf all the formats encountered in the i18n multiverse, this format is arguably the most distant universe, or should I say: most distant \"metaverse\" ;-)\n<br />\n[FBT](https://facebook.github.io/fbt/) is invented, used and maintained by [Facebook](https://www.facebook.com).\n<br />\nIt is... special. It comes with text extraction and at the center are not the translations but your code.\n\nSo first you need to instrument your code:\n```jsx\n<fbt desc=\"eating cake\">\n  I would like to eat\n  <fbt:plural\n    count={1}\n    name=\"number of cakes\"\n    showCount=\"ifMany\"\n    many=\"cakes\">\n    a cake\n  </fbt:plural>.\n</fbt> <!-- \"I would like to eat a cake.\" -->\n<fbt desc=\"eating muffin\">\n  I would like to eat\n  <fbt:plural\n    count={5}\n    name=\"number of muffins\"\n    showCount=\"ifMany\"\n    many=\"muffins\">\n    a muffin\n  </fbt:plural>.\n</fbt> <!-- \"I would like to eat 5 muffins.\" -->\n<fbt desc=\"eating something\">\n  I would like to eat something.\n</fbt> <!-- \"I would like to eat something.\" -->\n```\n\nRun some scripts, and then you can use the prepared translation files:\n```json\n{\n  \"fb-locale\": \"en\",\n  \"translations\": {\n    \"bxFNG7FeHhfvzOcxJ4WpXA==\": {\n      \"tokens\": [],\n      \"translations\": [\n        {\n          \"translation\": \"I would like to eat {number of cakes} cakes.\",\n          \"variations\": {}\n        }\n      ],\n      \"types\": []\n    },\n    \"1kfdpAZKBoeV6P/6/jU9BQ==\": {\n      \"tokens\": [],\n      \"translations\": [\n        {\n          \"translation\": \"I would like to eat a cake.\",\n          \"variations\": {}\n        }\n      ],\n      \"types\": []\n    },\n    \"Yglr/cfclqA86jmKXJXtjg==\": {\n      \"tokens\": [],\n      \"translations\": [\n        {\n          \"translation\": \"I would like to eat {number of muffins} muffins.\",\n          \"variations\": {}\n        }\n      ],\n      \"types\": []\n    },\n    \"Ic2KkQ3gBr6AUcgtsH576g==\": {\n      \"tokens\": [],\n      \"translations\": [\n        {\n          \"translation\": \"I would like to eat a muffin.\",\n          \"variations\": {}\n        }\n      ],\n      \"types\": []\n    },\n    \"r2YYz0TzAkH0b0TSwFMEAw==\": {\n      \"tokens\": [],\n      \"translations\": [\n        {\n          \"translation\": \"I would like to eat something.\",\n          \"variations\": {}\n        }\n      ],\n      \"types\": []\n    }\n  }\n}\n```\n\nEach instrumented code part is mapped with a hash to the translations.\n<br />\nLike said... it's really different than all other formats.\n\n\n## Fluent <a name=\"fluent\"></a>\n\nThe last format in this multiverse trip is [Fluent](https://projectfluent.org) a [Mozilla](https://mozilla.org) project.\n<br />\nThe Fluent format shares a lot of philosophy that drove the design of [ICU Message Format](#icu).\n\nIt's also a key/value based format:\n```js\nimport { FluentBundle, FluentResource } from \"@fluent/bundle\";\n\nconst resource = new FluentResource(`\ndessert =\n  I would like to eat \n  {$toEat ->\n    [cake] {$count ->\n      [one] a cake\n     *[other] {$count} cakes\n    }\n    [muffin] {$count ->\n      [one] a muffin\n     *[other] {$count} muffins\n    }\n   *[other] something\n  }.\n`)\n\nconst bundle = new FluentBundle('en')\nbundle.addResource(resource)\n\nbundle.formatPattern(bundle.getMessage('dessert').value, { toEat: 'cake', count: 1 }) // -> \"I would like to eat a cake.\"\nbundle.formatPattern(bundle.getMessage('dessert').value, { toEat: 'muffin', count: 1 }) // -> \"I would like to eat a muffin.\"\nbundle.formatPattern(bundle.getMessage('dessert').value, { toEat: 'cake', count: 5 }) // -> \"I would like to eat 5 cakes.\"\nbundle.formatPattern(bundle.getMessage('dessert').value, { toEat: 'muffin', count: 5 }) // -> \"I would like to eat 5 muffins.\"\nbundle.formatPattern(bundle.getMessage('dessert').value, { toEat: '' }) // -> \"I would like to eat something.\"\n```\n\nLike [ICU Message Format](#icu) it uses only 1 key to generate all variations. So the value may look a bit more complex, like a language on its own.\n\n\n## Coming back home\n\n![](portal.jpg)\n\nWe looked through the portals of the i18n multiverse and got a few small first impressions about the various formats.\n<br />\nSome are very similar and some others are really different. In the end it's a matter of taste.\n<br />\nWhich format do you feel comfortable with?\n\nThe most important thing is that all team members are comfortable with it, and that all tools in the localization process supports that format.\n<br />\nSo choose your translation management system (TMS) carefully.\n\nLooking at the [history](https://www.i18next.com/misc/the-history-of-i18next) of the currently most used i18n format, we can see the the creators of [i18next](#i18next) are also the founders of a great [translation management system](https://locize.com).\n<br />\nSo with choosing [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n<br />\n➡️ [i18next](https://www.i18next.com) + [locize](https://locize.com) = true [continuous localization](https://locize.com/how-it-works.html#continouslocalization)\n\nWatch the demo [video](https://youtu.be/ds-yEEYP1Ks) to learn more:\n{% youtube ds-yEEYP1Ks %}\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"}]},{"title":"Continuous Localization vs. Continuous Localization 🤔","slug":"modern-continuous-localization","date":"un11fin11","updated":"un44fin44","comments":true,"path":"modern-continuous-localization/","link":"","permalink":"https://locize.com/blog/modern-continuous-localization/","excerpt":"","text":"Why Continuous Localization?Because software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously. Your localization and translation process should follow the same pattern as your software development. You&#39;re already using agile concepts in your software development, right? Add some agility also in your localization process! Translations should take place in parallel with agile sprints and in smaller batches. This means translating just a part of a software product and not the whole at once. Even better, translating continuously. The benefit to developers is clear-cut: align localization efforts with the development cycle by automating and accelerating the steps involved. This way, they can seamlessly integrate their localization processes into their development cycle. You localize, as a normal part of the development process cycle. No separate localization testing phase. Translation testing is part of normal software testing activity. The translators can work on text that the developers have just added. There is no wait for a particular milestone. Keeping translations in sync with development, reduces drastically the project complexity. A project management enjoys this, because it takes lots of tedious work from product managers that they would otherwise have to perform. tldr; Shorter, faster development cycles, faster time-to-market. How Continuous Localization WorksThe classical approachThe following team roles are at least included in a typical in-house localization team: Software engineer — Responsible for implementing the continuous localization workflow. Localization QA / translator — Responsible for the quality of the localized product. Product manager — Someone who oversees the whole process, working with engineers and translators, and is responsible for deadlines. After a successful implementation for the continuous localization workflow, the process will look more or less like this: The developers create new strings in the reference language and commit dem in their code repository, like GitHub, GitLab or any other Version Control System. The strings gets synchronized with the translation management system. The translators work on new translations. The translations are synchronized back to the code repository. The CI/CD pipeline picks the current (or defined) state of the code repository, and builds, tests, etc... The result is deployed. The end user can enjoy the new features and new translations. While this approach can be implemented together with most translation management systems, there is also a more modern approach... The modern approachYou should be able to deploy your translation files separated from your software so you can update and manage them independently. Something like a platform, that anyone can directly integrate with. The process could look like this: The developers work as usual on their features and create strings on-the-fly. Those new keys get&#39;s automatically pushed as missing strings to the translation management system (TMS). The translators work on new translations and can instantaneously validate the translations. Since translations are &quot;connected&quot; directly to your software product, they can be released at any time. This way you can also fix translations of your previously released product, without having to redeploy it. If you do so, you have to make sure you can have more than one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software! You may also want to have some reviewing workflow, auditing, integrated ordering of external translations, etc... Cool, but isn’t this a little over the top… an extra tooling and deployment — doesn’t all this just add more complexity and effort? You don’t have to build this yourself!!! — There is locize!Watch the demo video to learn more: locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.","raw":"title: Continuous Localization vs. Continuous Localization 🤔\ndate: 2022-02-14\ntags:\n  - continuous localization\n  - localization\n  - l10n\n  - continuous development\n  - continuous integration\n  - continuous delivery\n  - continuous translation\nthumbnail: modern-continuous-localization/title.jpg\nredirect_from:\n- /2022-02-14-modern-continuous-localization\n---\n\n\n![](title.jpg \"continuous localization\")\n\n## Why Continuous Localization?\n\nBecause software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously. Your [localization](../localization/) and translation process should follow the same pattern as your software development.\n\n>You're already using agile concepts in your software development, right?\n\nAdd some agility also in your localization process!\n<br />\nTranslations should take place in parallel with agile sprints and in smaller batches. This means translating just a part of a software product and not the whole at once. Even better, translating continuously.\n\nThe benefit to developers is clear-cut: align localization efforts with the development cycle by automating and accelerating the steps involved. This way, they can seamlessly integrate their localization processes into their development cycle.\n<br />\nYou localize, as a normal part of the development process cycle. No separate localization testing phase. Translation testing is part of normal software testing activity.\n<br />\nThe translators can work on text that the developers have just added. There is no wait for a particular milestone.\n<br />\nKeeping translations in sync with development, reduces drastically the project complexity. A project management enjoys this, because it takes lots of tedious work from product managers that they would otherwise have to perform.\n\n>**tldr; Shorter, faster development cycles, faster time-to-market.**\n\n\n## How Continuous Localization Works\n\n### The classical approach\n\nThe following team roles are at least included in a typical in-house localization team:\n\n- Software engineer — Responsible for implementing the continuous localization workflow.\n- Localization QA / translator — Responsible for the quality of the localized product.\n- Product manager — Someone who oversees the whole process, working with engineers and translators, and is responsible for deadlines.\n\n![](classic-continuous-localization.png \"classic continuous localization\")\n\nAfter a successful implementation for the continuous localization workflow, the process will look more or less like this:\n\n1. The developers create new strings in the reference language and commit dem in their code repository, like [GitHub](http://github.com), [GitLab](https://gitlab.com) or any other [Version Control System](https://en.wikipedia.org/wiki/Version_control).\n2. The strings gets synchronized with the translation management system.\n3. The translators work on new translations.\n4. The translations are synchronized back to the code repository.\n5. The CI/CD pipeline picks the current (or defined) state of the code repository, and builds, tests, etc...\n6. The result is deployed.\n7. The end user can enjoy the new features and new translations.\n\n*While this approach can be implemented together with most translation management systems, there is also a more modern approach...*\n\n### The modern approach\n\nYou should be able to deploy your translation files separated from your software so you can update and manage them independently. Something like a platform, that anyone can directly integrate with.\n\n![](real-continuous-localization.png \"real continuous localization\")\n\nThe process could look like this:\n\n1. The developers work as usual on their features and create strings on-the-fly. Those new keys get's automatically pushed as missing strings to the translation management system (TMS).\n2. The translators work on new translations and can instantaneously validate the translations.\n3. Since translations are \"connected\" directly to your software product, they can be released at any time. This way you can also fix translations of your previously released product, without having to redeploy it.\n\nIf you do so, you have to make sure you can have more than one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software!\nYou may also want to have some reviewing workflow, auditing, integrated ordering of external translations, etc...\n\n>Cool, but isn’t this a little over the top… an extra tooling and deployment — doesn’t all this just add more complexity and effort?\n\n#### You don’t have to build this yourself!!! — There is [locize](/)!\n\nWatch the demo video to learn more:\n{% youtube ds-yEEYP1Ks %}\n\n[locize](/) removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"continuous development","slug":"continuous-development","permalink":"https://locize.com/blog/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"https://locize.com/blog/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"https://locize.com/blog/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"https://locize.com/blog/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"https://locize.com/blog/tags/continuous-translation/"}]},{"title":"The progressive guide to jQuery internationalization (i18n) using i18next","slug":"jquery-i18next","date":"un33fin33","updated":"un33fin33","comments":true,"path":"jquery-i18next/","link":"","permalink":"https://locize.com/blog/jquery-i18next/","excerpt":"","text":"Every web developer may have met the perennial Methuselah jQuery. Created back in January 2006 at BarCamp NYC by John Resig and currently maintained by a team of developers led by Timmy Willison. You may think: Why a blog post about the venerable but aged JavaScript library, that made things like HTML document traversal and manipulation, etc. easier? Because with a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript! And you can see this by the huge usage of jQuery: Based on w3Techs web technology surveys, jQuery is used by 95.4% of all the websites whose JavaScript library they know. And 78.3% of all websites. Checking the npm download trends of the jquery module it is approaching the 5 million downloads per week. So you see, jQuery is not only still relevant, it takes up the majority of all websites. Therefore, in this article, we will be using the i18next framework to internationalize a jQuery website. TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher Translate head information Interpolation and Pluralization Formatting Context Separate translations from code Better translation management For sure! How does this look like? save missing translations 👀 but there&#39;s more... 🎉🥳 Congratulations 🎊🎁 So first of all: &quot;Why i18next?&quot; When it comes to jQuery localization, one of the most popular is i18next with it&#39;s jQuery extension jquery-i18next, and for good reasons: i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). Only jQuery is older 😉 ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it... Prerequisites Make sure you have a jQuery based website or web app. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic jQuery, before jumping to jquery-i18next. This jQuery i18n example is not intended to be a jQuery beginner tutorial. Getting started Take your own jQuery project or create a new one. I have here an awesome landing page 😉 We are going to adapt the website to detect the language according to the user’s preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: i18next jquery-i18next i18next-browser-languagedetector 123&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next@21.6.10/i18next.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery-i18next@1.2.1/jquery-i18next.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next-browser-languagedetector@6.1.3/i18nextBrowserLanguageDetector.min.js&quot;&gt;&lt;/script&gt; Let&#39;s prepare an i18n.js file: 12345678910111213141516171819202122232425262728293031$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; // here we will place our translations... &#125; &#125; &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); &#125;);&#125;); Let&#39;s load that file: 12345&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next@21.6.10/i18next.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery-i18next@1.2.1/jquery-i18next.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next-browser-languagedetector@6.1.3/i18nextBrowserLanguageDetector.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/i18n.js&quot;&gt;&lt;/script&gt; Now let&#39;s try to move some hard coded text out to the translations. 1234&lt;!-- ... --&gt;&lt;h1 data-i18n=&quot;intro.title&quot;&gt;Landing Page&lt;/h1&gt;&lt;h3 data-i18n=&quot;intro.subTitle&quot;&gt;Some subtitle&lt;/h3&gt;&lt;!-- ... --&gt; Since the texts will be part of our translation resources, they could also be removed: 1234&lt;!-- ... --&gt;&lt;h1 data-i18n=&quot;intro.title&quot;&gt;&lt;/h1&gt;&lt;h3 data-i18n=&quot;intro.subTitle&quot;&gt;&lt;/h3&gt;&lt;!-- ... --&gt; The texts are now part of the translation resources: 12345678910111213141516171819202122232425262728293031323334$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; intro: &#123; title: &#x27;Landing Page&#x27;, subTitle: &#x27;Some subtitle&#x27; &#125; &#125; &#125; &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); &#125;);&#125;); Language Switcher Now let&#39;s define a language switcher: 123&lt;!-- ... --&gt;&lt;select name=&quot;language&quot; id=&quot;languageSwitcher&quot;&gt;&lt;/select&gt;&lt;!-- ... --&gt; And also add some translations for the new language: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize();&#125;$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; intro: &#123; title: &#x27;Landing Page&#x27;, subTitle: &#x27;Some subtitle&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; intro: &#123; title: &#x27;Webseite&#x27;, subTitle: &#x27;Ein Untertitel&#x27; &#125; &#125; &#125; &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // fill language switcher Object.keys(lngs).map((lng) =&gt; &#123; const opt = new Option(lngs[lng].nativeName, lng); if (lng === i18next.resolvedLanguage) &#123; opt.setAttribute(&quot;selected&quot;, &quot;selected&quot;); &#125; $(&#x27;#languageSwitcher&#x27;).append(opt); &#125;); $(&#x27;#languageSwitcher&#x27;).change((a, b, c) =&gt; &#123; const chosenLng = $(this).find(&quot;option:selected&quot;).attr(&#x27;value&#x27;); i18next.changeLanguage(chosenLng, () =&gt; &#123; rerender(); &#125;); &#125;); rerender(); &#125;);&#125;); 🥳 Awesome, you&#39;ve just created your first language switcher! Thanks to i18next-browser-languagedetector now it tries to detect the browser language and automatically use that language if you&#39;ve provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language. Translate head information Let&#39;s translate also the title and description of the website. We do this by extending our rerender function, and adding the additional translation resources: 12345678910111213141516171819202122232425262728293031323334353637const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); $(&#x27;title&#x27;).text($.t(&#x27;head.title&#x27;)) $(&#x27;meta[name=description]&#x27;).attr(&#x27;content&#x27;, $.t(&#x27;head.description&#x27;))&#125;// ...resources: &#123; en: &#123; translation: &#123; head: &#123; title: &#x27;My Awesome Landing-Page&#x27;, description: &#x27;The description of this awesome landing page.&#x27; &#125;, intro: &#123; title: &#x27;Landing Page&#x27;, subTitle: &#x27;Some subtitle&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; head: &#123; title: &#x27;Meine grossartige Webseite&#x27;, description: &#x27;Die Beschreibung dieser grossartigen Webseite.&#x27; &#125;, intro: &#123; title: &#x27;Webseite&#x27;, subTitle: &#x27;Ein Untertitel&#x27; &#125; &#125; &#125;&#125; So you see, this can be also done with the $.t() helper function. Let&#39;s check the DOM: Nice 👍 Interpolation and Pluralization i18next goes beyond just providing the standard i18n features. But for sure it&#39;s able to handle plurals and interpolation. Let&#39;s count each time the language gets changed: 12345678&lt;!-- ... --&gt;&lt;li&gt; &lt;select name=&quot;language&quot; id=&quot;languageSwitcher&quot;&gt;&lt;/select&gt;&lt;/li&gt;&lt;li id=&quot;languageChangedNotification&quot; style=&quot;display: none;&quot;&gt; &lt;i data-i18n=&quot;footer.counter&quot; data-i18n-options=&#x27;&#123; &quot;count&quot;: 0 &#125;&#x27;&gt;&lt;/i&gt;&lt;/li&gt;&lt;!-- ... --&gt; Let&#39;s remember the count in the languageChangedCounter variable and increment it on each language change. ...and extending the translation resources: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); $(&#x27;title&#x27;).text($.t(&#x27;head.title&#x27;)) $(&#x27;meta[name=description]&#x27;).attr(&#x27;content&#x27;, $.t(&#x27;head.description&#x27;))&#125;$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; head: &#123; title: &#x27;My Awesome Landing-Page&#x27;, description: &#x27;The description of this awesome landing page.&#x27; &#125;, intro: &#123; title: &#x27;Landing Page&#x27;, subTitle: &#x27;Some subtitle&#x27; &#125;, footer: &#123; counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; head: &#123; title: &#x27;Meine grossartige Webseite&#x27;, description: &#x27;Die Beschreibung dieser grossartigen Webseite.&#x27; &#125;, intro: &#123; title: &#x27;Webseite&#x27;, subTitle: &#x27;Ein Untertitel&#x27; &#125;, footer: &#123; counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27; &#125; &#125; &#125; &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // fill language switcher Object.keys(lngs).map((lng) =&gt; &#123; const opt = new Option(lngs[lng].nativeName, lng); if (lng === i18next.resolvedLanguage) &#123; opt.setAttribute(&quot;selected&quot;, &quot;selected&quot;); &#125; $(&#x27;#languageSwitcher&#x27;).append(opt); &#125;); let languageChangedCounter = 0; $(&#x27;#languageSwitcher&#x27;).change((a, b, c) =&gt; &#123; const chosenLng = $(this).find(&quot;option:selected&quot;).attr(&#x27;value&#x27;); i18next.changeLanguage(chosenLng, () =&gt; &#123; rerender(); // language changed message languageChangedCounter++; $(&#x27;#languageChangedNotification&#x27;).localize(&#123; count: languageChangedCounter &#125;) if (languageChangedCounter === 1) &#123; $(&#x27;#languageChangedNotification&#x27;).show(); &#125; &#125;); &#125;); rerender(); &#125;);&#125;); Based on the count value i18next will choose the correct plural form. Read more about pluralization and interpolation in the official i18next documentation. 💡 i18next is also able to handle languages with multiple plural forms, like arabic: 1234567891011121314151617181920// translation resources:&#123; &quot;key_zero&quot;: &quot;zero&quot;, &quot;key_one&quot;: &quot;singular&quot;, &quot;key_two&quot;: &quot;two&quot;, &quot;key_few&quot;: &quot;few&quot;, &quot;key_many&quot;: &quot;many&quot;, &quot;key_other&quot;: &quot;other&quot;&#125;// usage:t(&#x27;key&#x27;, &#123;count: 0&#125;); // -&gt; &quot;zero&quot;t(&#x27;key&#x27;, &#123;count: 1&#125;); // -&gt; &quot;singular&quot;t(&#x27;key&#x27;, &#123;count: 2&#125;); // -&gt; &quot;two&quot;t(&#x27;key&#x27;, &#123;count: 3&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 4&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 5&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 11&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 99&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 100&#125;); // -&gt; &quot;other&quot; Formatting Now, let’s check out how we can use different date formats with the help of i18next and moment.js to handle date and time. 123&lt;!-- ... --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment-with-locales.min.js&quot;&gt;&lt;/script&gt;&lt;!-- ... --&gt; We like to have the footer displaying the current date: 123&lt;!-- ... --&gt;&lt;p id=&quot;footerMessage&quot; class=&quot;text-muted small&quot; data-i18n=&quot;footer.date&quot;&gt;&lt;/p&gt;&lt;!-- ... --&gt; Define a format function, like documented in the documentation and add the new translation key: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); $(&#x27;title&#x27;).text($.t(&#x27;head.title&#x27;)) $(&#x27;meta[name=description]&#x27;).attr(&#x27;content&#x27;, $.t(&#x27;head.description&#x27;))&#125;$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; head: &#123; title: &#x27;My Awesome Landing-Page&#x27;, description: &#x27;The description of this awesome landing page.&#x27; &#125;, intro: &#123; title: &#x27;Landing Page&#x27;, subTitle: &#x27;Some subtitle&#x27; &#125;, footer: &#123; counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, date: &#x27;It\\&#x27;s &#123;&#123;date, LLLL&#125;&#125;&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; head: &#123; title: &#x27;Meine grossartige Webseite&#x27;, description: &#x27;Die Beschreibung dieser grossartigen Webseite.&#x27; &#125;, intro: &#123; title: &#x27;Webseite&#x27;, subTitle: &#x27;Ein Untertitel&#x27; &#125;, footer: &#123; counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, date: &#x27;Es ist &#123;&#123;date, LLLL&#125;&#125;&#x27; &#125; &#125; &#125; &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // define the formatter function i18next.services.formatter.add(&#x27;LLLL&#x27;, (value, lng, options) =&gt; &#123; return moment(value).locale(lng).format(&#x27;LLLL&#x27;); &#125;); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // fill language switcher Object.keys(lngs).map((lng) =&gt; &#123; const opt = new Option(lngs[lng].nativeName, lng); if (lng === i18next.resolvedLanguage) &#123; opt.setAttribute(&quot;selected&quot;, &quot;selected&quot;); &#125; $(&#x27;#languageSwitcher&#x27;).append(opt); &#125;); let languageChangedCounter = 0; $(&#x27;#languageSwitcher&#x27;).change((a, b, c) =&gt; &#123; const chosenLng = $(this).find(&quot;option:selected&quot;).attr(&#x27;value&#x27;); i18next.changeLanguage(chosenLng, () =&gt; &#123; rerender(); // language changed message languageChangedCounter++; $(&#x27;#languageChangedNotification&#x27;).localize(&#123; count: languageChangedCounter &#125;) if (languageChangedCounter === 1) &#123; $(&#x27;#languageChangedNotification&#x27;).show(); &#125; &#125;); &#125;); rerender(); &#125;);&#125;); 😎 Cool, now we have a language specific date formatting! English: German: Context What about a specific greeting message based on the current day time? i.e. morning, evening, etc. This is possible thanks to the context feature of i18next. Let&#39;s create a getGreetingTime function and use the result as context information for our footer translation. And add some context specific translations keys: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ...const getGreetingTime = () =&gt; &#123; const split_afternoon = 12; // 24hr time to split the afternoon const split_evening = 17; // 24hr time to split the evening const currentHour = moment().hour(); if (currentHour &gt;= split_afternoon &amp;&amp; currentHour &lt;= split_evening) &#123; return &#x27;afternoon&#x27;; &#125; else if (currentHour &gt;= split_evening) &#123; return &#x27;evening&#x27;; &#125; return &#x27;morning&#x27;;&#125;const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); $(&#x27;#footerMessage&#x27;).localize(&#123; context: getGreetingTime() &#125;); $(&#x27;title&#x27;).text($.t(&#x27;head.title&#x27;)) $(&#x27;meta[name=description]&#x27;).attr(&#x27;content&#x27;, $.t(&#x27;head.description&#x27;))&#125;// ...resources: &#123; en: &#123; translation: &#123; // ... footer: &#123; counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, date: &#x27;It\\&#x27;s &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_afternoon: &#x27;Good afternoon! It\\&#x27;s &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_evening: &#x27;Good evening! Today was the &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_morning: &#x27;Good morning! Today is &#123;&#123;date, LLLL&#125;&#125; | Have a nice day!&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; // ... footer: &#123; counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, date: &#x27;Es ist &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_afternoon: &#x27;Guten Tag! Es ist &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_evening: &#x27;Guten Abend! Heute war &#123;&#123;date, LLLL&#125;&#125;&#x27;, date_morning: &#x27;Guten Morgen! Heute ist &#123;&#123;date, LLLL&#125;&#125; | Wünsche einen schönen Tag!&#x27; &#125; &#125; &#125;&#125; 😁 Yeah, It works! Separate translations from code Having the translations in our i18n.js file works, but is not that suitable to work with, for translators. Let&#39;s separate the translations from the code and pleace them in dedicated json files. Because this is a web application, i18next-http-backend will help us to do so. 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next-http-backend@1.3.2/i18nextHttpBackend.min.js&quot;&gt;&lt;/script&gt; Create a locales folder and move the translations there: Adapt the i18n.js file to use the i18next-http-backend: 1234567891011121314151617181920212223242526272829// ...$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(i18nextHttpBackend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27; // i.e. if you want to customize a different translation path, // use the loadPath option: // backend: &#123; // loadPath: &#x27;/assets/locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27; // &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // ... &#125;);&#125;); Now the translations are loaded asynchronously, so it may be the UI will refresh a bit later, as soon as the translations are loaded. To optimize this behaviour, you can show some sort of loading indicator until the i18next is initialized. Something like: 1234&lt;div id=&quot;loader&quot;&gt;Loading...&lt;/div&gt;&lt;div id=&quot;content&quot; style=&quot;display: none;&quot;&gt; &lt;!-- your real content --&gt;&lt;/div&gt; 12$(&#x27;#loader&#x27;).hide();$(&#x27;#content&#x27;).show(); Now your app looks still the same, but your translations are separated. If you want to support a new language, you just create a new folder and a new translation json file. This gives you the possibility to send the translations to some translators. Or if you&#39;re working with a translation management system you can just synchronize the files with a cli. Better translation management By sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you. This is a traditional way. But be aware sending files around creates always an overhead. Does a better option exist? For sure! i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? How do you deploy translation changes without deploying your complete application? and a lot more... Looking for something like this❓ Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Profit from our content delivery network (CDN) Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... How does this look like? First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by using the cli or by importing the individual json files or via API. Done so, we&#39;re going to replace i18next-http-backend with i18next-locize-backend. 123&lt;!-- ... --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/i18next-locize-backend@4.2.8/i18nextLocizeBackend.min.js&quot;&gt;&lt;/script&gt;&lt;!-- ... --&gt; After having imported the translations to locize, delete the locales folder and adapt the i18n.js file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project: 123456789101112131415161718192021222324252627282930// ...const locizeOptions = &#123; projectId: &#x27;8d751621-323e-4bda-94c8-7d2368102e62&#x27;, apiKey: &#x27;302aca54-2ea8-4b9f-b5f0-df1369c59427&#x27; // YOU should not expose your apps API key to production!!!&#125;;$(function () &#123; // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(i18nextLocizeBackend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // ... &#125;);&#125;); i18next-locize-backend offers a functionality to retrieve the available languages directly from locize, let&#39;s use it: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ...const locizeOptions = &#123; projectId: &#x27;8d751621-323e-4bda-94c8-7d2368102e62&#x27;, apiKey: &#x27;302aca54-2ea8-4b9f-b5f0-df1369c59427&#x27; // YOU should not expose your apps API key to production!!!&#125;;$(function () &#123; const locizeBackend = new i18nextLocizeBackend(locizeOptions, (err, opts, lngs) =&gt; &#123; if (err) return console.error(err); // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(locizeBackend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // new usage i18next.services.formatter.add(&#x27;LLLL&#x27;, (value, lng, options) =&gt; &#123; return moment(value).locale(lng).format(&#x27;LLLL&#x27;); &#125;); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // fill language switcher // with the lngs retrieved directly from locize... Object.keys(lngs).map((lng) =&gt; &#123; const opt = new Option(lngs[lng].nativeName, lng); if (lng === i18next.resolvedLanguage) &#123; opt.setAttribute(&quot;selected&quot;, &quot;selected&quot;); &#125; $(&#x27;#languageSwitcher&#x27;).append(opt); &#125;); let languageChangedCounter = 0; $(&#x27;#languageSwitcher&#x27;).change((a, b, c) =&gt; &#123; const chosenLng = $(this).find(&quot;option:selected&quot;).attr(&#x27;value&#x27;); i18next.changeLanguage(chosenLng, () =&gt; &#123; rerender(); // language changed message languageChangedCounter++; $(&#x27;#languageChangedNotification&#x27;).localize(&#123; count: languageChangedCounter &#125;) if (languageChangedCounter === 1) &#123; $(&#x27;#languageChangedNotification&#x27;).show(); &#125; &#125;); &#125;); rerender(); $(&#x27;#loader&#x27;).hide(); $(&#x27;#content&#x27;).show(); &#125;); &#125;);&#125;); Now the translations are served directly from the locize CDN. The jQuery i18n has now CDN superpower 😁. save missing translations Thanks to the use of the saveMissing functionality, new keys gets added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options: 12345678// ....init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions, saveMissing: true // do not enable it on production&#125;, (err, t) =&gt; &#123;// ... Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;div data-i18n=&quot;new.key&quot;&gt;this will be added automatically&lt;/div&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see how the automatic machine translation workflow looks like! 1234&lt;!-- ... --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/locize-lastused@3.0.13/locizeLastUsed.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/locize@2.2.4/locize.min.js&quot;&gt;&lt;/script&gt;&lt;!-- ... --&gt; use them in i18n.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111const getGreetingTime = () =&gt; &#123; const split_afternoon = 12; // 24hr time to split the afternoon const split_evening = 17; // 24hr time to split the evening const currentHour = moment().hour(); if (currentHour &gt;= split_afternoon &amp;&amp; currentHour &lt;= split_evening) &#123; return &#x27;afternoon&#x27;; &#125; else if (currentHour &gt;= split_evening) &#123; return &#x27;evening&#x27;; &#125; return &#x27;morning&#x27;;&#125;const rerender = () =&gt; &#123; // start localizing, details: // https://github.com/i18next/jquery-i18next#usage-of-selector-function $(&#x27;body&#x27;).localize(); $(&#x27;#footerMessage&#x27;).localize(&#123; context: getGreetingTime() &#125;); $(&#x27;title&#x27;).text($.t(&#x27;head.title&#x27;)) $(&#x27;meta[name=description]&#x27;).attr(&#x27;content&#x27;, $.t(&#x27;head.description&#x27;))&#125;const locizeOptions = &#123; projectId: &#x27;8d751621-323e-4bda-94c8-7d2368102e62&#x27;, apiKey: &#x27;302aca54-2ea8-4b9f-b5f0-df1369c59427&#x27; // YOU should not expose your apps API key to production!!!&#125;;i18next.on(&#x27;editorSaved&#x27;, rerender); // used for the inContext editor$(function () &#123; const locizeBackend = new i18nextLocizeBackend(locizeOptions, (err, opts, lngs) =&gt; &#123; if (err) return console.error(err); // use plugins and options as needed, for options, detail see // https://www.i18next.com i18next // locize-editor // InContext Editor of locize .use(locize.locizePlugin) // locize-lastused (do not use this in production) // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused .use(locizeLastUsed) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(locizeBackend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(i18nextBrowserLanguageDetector) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; ...opts, debug: true, fallbackLng: &#x27;en&#x27;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: true // interpolation: &#123; // // legacy usage // format: (value, format, lng) =&gt; &#123; // if (value instanceof Date) &#123; // return moment(value).locale(lng).format(format); // &#125; // return value; // &#125; // &#125; &#125;, (err, t) =&gt; &#123; if (err) return console.error(err); // new usage i18next.services.formatter.add(&#x27;LLLL&#x27;, (value, lng, options) =&gt; &#123; return moment(value).locale(lng).format(&#x27;LLLL&#x27;); &#125;); // for options see // https://github.com/i18next/jquery-i18next#initialize-the-plugin jqueryI18next.init(i18next, $, &#123; useOptionsAttr: true &#125;); // fill language switcher Object.keys(lngs).map((lng) =&gt; &#123; const opt = new Option(lngs[lng].nativeName, lng); if (lng === i18next.resolvedLanguage) &#123; opt.setAttribute(&quot;selected&quot;, &quot;selected&quot;); &#125; $(&#x27;#languageSwitcher&#x27;).append(opt); &#125;); let languageChangedCounter = 0; $(&#x27;#languageSwitcher&#x27;).change((a, b, c) =&gt; &#123; const chosenLng = $(this).find(&quot;option:selected&quot;).attr(&#x27;value&#x27;); i18next.changeLanguage(chosenLng, () =&gt; &#123; rerender(); // language changed message languageChangedCounter++; $(&#x27;#languageChangedNotification&#x27;).localize(&#123; count: languageChangedCounter &#125;) if (languageChangedCounter === 1) &#123; $(&#x27;#languageChangedNotification&#x27;).show(); &#125; &#125;); &#125;); rerender(); $(&#x27;#loader&#x27;).hide(); $(&#x27;#content&#x27;).show(); &#125;); &#125;);&#125;); Automatic machine translation: Last used translations filter: InContext Editor: Now, during development, you&#39;ll continue to save missing keys and to make use of lastused feature. And in production environment, you should disable or remove the saveMissing and lastused functionality, and also the api-key should not exposed. Caching: Merging versions: 🧑‍💻 The complete code can be found here. Check also the code integration part in this YouTube video. There&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18next, jQuery localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: The progressive guide to jQuery internationalization (i18n) using i18next\ndescription: How to properly internationalize a jQuery website using i18next.\n\ndate: 2022-02-02\ntags:\n  - i18next\n  - jquery\n  - jquery-i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: jquery-i18next/jquery-localization.jpg\nredirect_from:\n- /how-to-jquery-i18next\n\nlabel: jquery-i18next\nlang: en\n---\n\n![jQuery localization](jquery-localization.jpg \"jQuery Localization example\")\n\nEvery web developer may have met the perennial [Methuselah](https://en.wikipedia.org/wiki/Methuselah) jQuery.\nCreated back in January 2006 at [BarCamp NYC](https://en.wikipedia.org/wiki/BarCamp) by [John Resig](https://en.wikipedia.org/wiki/John_Resig) and currently maintained by a [team of developers](https://jquery.org/team/) led by [Timmy Willison](https://timmywil.com).\n\n*You may think:*\n>Why a blog post about the venerable but aged JavaScript library, that made things like HTML document traversal and manipulation, etc. easier?\n\n**Because with a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript!**\n\nAnd you can see this by the huge usage of jQuery:\n\nBased on [w3Techs web technology surveys](https://w3techs.com/technologies/overview/javascript_library), [jQuery](https://w3techs.com/technologies/details/js-jquery) is used by **95.4%** of all the websites whose JavaScript library they know. And **78.3%** of all websites.\n\n![](w3techs.jpg)\n\nChecking the [npm download trends of the jquery](https://www.npmtrends.com/jquery) module it is approaching the 5 million downloads per week.\n\n![](npmtrends.jpg)\n\nSo you see, jQuery is not only still relevant, it takes up the majority of all websites.\n\nTherefore, in this article, we will be using the i18next framework to internationalize a jQuery website.\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [Translate head information](#head-translate)\n    - [Interpolation and Pluralization](#interpolation-pluralization)\n    - [Formatting](#formatting)\n    - [Context](#context)\n    - [Separate translations from code](#separate)\n    - [Better translation management](#better-translation-management)\n      - [For sure!](#for-sure)\n      - [How does this look like?](#how-look)\n      - [save missing translations](#save-missing)\n      - [👀 but there's more...](#more)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\nWhen it comes to jQuery localization, one of the most popular is [i18next](https://www.i18next.com) with it's jQuery extension [jquery-i18next](https://github.com/i18next/jquery-i18next), and for good reasons:\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology ([React](../react-i18next/), [Angular](../angular-i18next/), [Vue](../i18next-vue/), ...). Only [jQuery](https://jquery.com/) is older 😉*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have a jQuery based website or web app. It's best, if you have some experience with simple HTML, JavaScript and basic jQuery, before jumping to [jquery-i18next](https://github.com/i18next/jquery-i18next). This jQuery i18n example is not intended to be a jQuery beginner tutorial.\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own jQuery project or create a new one.\n\nI have here an awesome landing page 😉\n\n![](app_0.png \"locize © inweso GmbH\")\n\nWe are going to adapt the website to detect the language according to the user’s preference.\nAnd we will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [i18next](https://www.i18next.com)\n- [jquery-i18next](https://github.com/i18next/jquery-i18next)\n- [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector)\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/i18next@21.6.10/i18next.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery-i18next@1.2.1/jquery-i18next.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/i18next-browser-languagedetector@6.1.3/i18nextBrowserLanguageDetector.min.js\"></script>\n```\n\nLet's prepare an `i18n.js` file:\n\n```javascript\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      resources: {\n        en: {\n          translation: {\n            // here we will place our translations...\n          }\n        }\n      }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // for options see\n      // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n      jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n      // start localizing, details:\n      // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n      $('body').localize();\n    });\n});\n```\n\nLet's load that file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/i18next@21.6.10/i18next.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery-i18next@1.2.1/jquery-i18next.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/i18next-browser-languagedetector@6.1.3/i18nextBrowserLanguageDetector.min.js\"></script>\n\n<script src=\"js/i18n.js\"></script>\n```\n\nNow let's try to move some hard coded text out to the translations.\n\n```html\n<!-- ... -->\n<h1 data-i18n=\"intro.title\">Landing Page</h1>\n<h3 data-i18n=\"intro.subTitle\">Some subtitle</h3>\n<!-- ... -->\n```\n\nSince the texts will be part of our translation resources, they could also be removed:\n\n```html\n<!-- ... -->\n<h1 data-i18n=\"intro.title\"></h1>\n<h3 data-i18n=\"intro.subTitle\"></h3>\n<!-- ... -->\n```\n\nThe texts are now part of the translation resources:\n\n```javascript\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      resources: {\n        en: {\n          translation: {\n            intro: {\n              title: 'Landing Page',\n              subTitle: 'Some subtitle'\n            }\n          }\n        }\n      }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // for options see\n      // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n      jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n      // start localizing, details:\n      // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n      $('body').localize();\n    });\n});\n```\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nNow let's define a language switcher:\n\n```html\n<!-- ... -->\n<select name=\"language\" id=\"languageSwitcher\"></select>\n<!-- ... -->\n```\n\nAnd also add some translations for the new language:\n\n```javascript\nconst lngs = {\n  en: { nativeName: 'English' },\n  de: { nativeName: 'Deutsch' }\n};\n\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n}\n\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      resources: {\n        en: {\n          translation: {\n            intro: {\n              title: 'Landing Page',\n              subTitle: 'Some subtitle'\n            }\n          }\n        },\n        de: {\n          translation: {\n            intro: {\n              title: 'Webseite',\n              subTitle: 'Ein Untertitel'\n            }\n          }\n        }\n      }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // for options see\n      // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n      jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n      // fill language switcher\n      Object.keys(lngs).map((lng) => {\n        const opt = new Option(lngs[lng].nativeName, lng);\n        if (lng === i18next.resolvedLanguage) {\n          opt.setAttribute(\"selected\", \"selected\");\n        }\n        $('#languageSwitcher').append(opt);\n      });\n      $('#languageSwitcher').change((a, b, c) => {\n        const chosenLng = $(this).find(\"option:selected\").attr('value');\n        i18next.changeLanguage(chosenLng, () => {\n          rerender();\n        });\n      });\n\n      rerender();\n    });\n});\n```\n\n![jquery language switcher](app_1_switcher.jpg \"locize © inweso GmbH\")\n\n![](app_1.jpg \"locize © inweso GmbH\")\n\n\n**🥳 Awesome, you've just created your first language switcher!**\n\nThanks to [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) now it tries to detect the browser language and automatically use that language if you've provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language.\n\n\n### Translate head information <a name=\"head-translate\"></a>\n\nLet's translate also the title and description of the website.\nWe do this by extending our `rerender` function, and adding the additional translation resources:\n\n```javascript\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n\n  $('title').text($.t('head.title'))\n  $('meta[name=description]').attr('content', $.t('head.description'))\n}\n\n// ...\n\nresources: {\n  en: {\n    translation: {\n      head: {\n        title: 'My Awesome Landing-Page',\n        description: 'The description of this awesome landing page.'\n      },\n      intro: {\n        title: 'Landing Page',\n        subTitle: 'Some subtitle'\n      }\n    }\n  },\n  de: {\n    translation: {\n      head: {\n        title: 'Meine grossartige Webseite',\n        description: 'Die Beschreibung dieser grossartigen Webseite.'\n      },\n      intro: {\n        title: 'Webseite',\n        subTitle: 'Ein Untertitel'\n      }\n    }\n  }\n}\n```\n\nSo you see, this can be also done with the `$.t()` helper function.\n\nLet's check the DOM:\n\n![](dom.jpg \"locize © inweso GmbH\")\n\nNice 👍\n\n\n### Interpolation and Pluralization <a name=\"interpolation-pluralization\"></a>\n\ni18next goes beyond just providing the standard i18n features.\nBut for sure it's able to handle [plurals](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation).\n\nLet's count each time the language gets changed:\n\n```html\n<!-- ... -->\n<li>\n  <select name=\"language\" id=\"languageSwitcher\"></select>\n</li>\n<li id=\"languageChangedNotification\" style=\"display: none;\">\n  <i data-i18n=\"footer.counter\" data-i18n-options='{ \"count\": 0 }'></i>\n</li>\n<!-- ... -->\n```\n\nLet's remember the count in the `languageChangedCounter` variable and increment it on each language change.\n<br />\n...and extending the translation resources:\n\n```javascript\nconst lngs = {\n  en: { nativeName: 'English' },\n  de: { nativeName: 'Deutsch' }\n};\n\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n\n  $('title').text($.t('head.title'))\n  $('meta[name=description]').attr('content', $.t('head.description'))\n}\n\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      resources: {\n        en: {\n          translation: {\n            head: {\n              title: 'My Awesome Landing-Page',\n              description: 'The description of this awesome landing page.'\n            },\n            intro: {\n              title: 'Landing Page',\n              subTitle: 'Some subtitle'\n            },\n            footer: {\n              counter_one: 'Changed language just once',\n              counter_other: 'Changed language already {{count}} times'\n            }\n          }\n        },\n        de: {\n          translation: {\n            head: {\n              title: 'Meine grossartige Webseite',\n              description: 'Die Beschreibung dieser grossartigen Webseite.'\n            },\n            intro: {\n              title: 'Webseite',\n              subTitle: 'Ein Untertitel'\n            },\n            footer: {\n              counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n              counter_other: 'Die Sprache wurde {{count}} mal gewechselt'\n            }\n          }\n        }\n      }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // for options see\n      // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n      jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n      // fill language switcher\n      Object.keys(lngs).map((lng) => {\n        const opt = new Option(lngs[lng].nativeName, lng);\n        if (lng === i18next.resolvedLanguage) {\n          opt.setAttribute(\"selected\", \"selected\");\n        }\n        $('#languageSwitcher').append(opt);\n      });\n      let languageChangedCounter = 0;\n      $('#languageSwitcher').change((a, b, c) => {\n        const chosenLng = $(this).find(\"option:selected\").attr('value');\n        i18next.changeLanguage(chosenLng, () => {\n          rerender();\n            \n          // language changed message\n          languageChangedCounter++;\n          $('#languageChangedNotification').localize({ count: languageChangedCounter })\n          if (languageChangedCounter === 1) {\n            $('#languageChangedNotification').show();\n          }\n        });\n      });\n\n      rerender();\n    });\n});\n```\n\nBased on the count value i18next will choose the correct plural form.\nRead more about [pluralization](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation) in the [official i18next documentation](https://www.i18next.com/).\n\n![jQuery pluralization](app_2.jpg \"locize © inweso GmbH\")\n\n*💡 i18next is also able to handle languages with multiple plural forms, like arabic:*\n\n```javascript\n// translation resources:\n{\n  \"key_zero\": \"zero\",\n  \"key_one\": \"singular\",\n  \"key_two\": \"two\",\n  \"key_few\": \"few\",\n  \"key_many\": \"many\",\n  \"key_other\": \"other\"\n}\n\n// usage:\nt('key', {count: 0}); // -> \"zero\"\nt('key', {count: 1}); // -> \"singular\"\nt('key', {count: 2}); // -> \"two\"\nt('key', {count: 3}); // -> \"few\"\nt('key', {count: 4}); // -> \"few\"\nt('key', {count: 5}); // -> \"few\"\nt('key', {count: 11}); // -> \"many\"\nt('key', {count: 99}); // -> \"many\"\nt('key', {count: 100}); // -> \"other\"\n```\n\n\n### Formatting <a name=\"formatting\"></a>\n\nNow, let’s check out how we can use different date formats with the help of [i18next](https://www.i18next.com) and [moment.js](https://momentjs.com/) to handle date and time.\n\n```html\n<!-- ... -->\n<script src=\"https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment-with-locales.min.js\"></script>\n<!-- ... -->\n```\n\nWe like to have the footer displaying the current date:\n\n```html\n<!-- ... -->\n<p id=\"footerMessage\" class=\"text-muted small\" data-i18n=\"footer.date\"></p>\n<!-- ... -->\n```\n\nDefine a format function, like documented in the [documentation](https://www.i18next.com/translation-function/formatting) and add the new translation key:\n\n```javascript\nconst lngs = {\n  en: { nativeName: 'English' },\n  de: { nativeName: 'Deutsch' }\n};\n\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n\n  $('title').text($.t('head.title'))\n  $('meta[name=description]').attr('content', $.t('head.description'))\n}\n\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      resources: {\n        en: {\n          translation: {\n            head: {\n              title: 'My Awesome Landing-Page',\n              description: 'The description of this awesome landing page.'\n            },\n            intro: {\n              title: 'Landing Page',\n              subTitle: 'Some subtitle'\n            },\n            footer: {\n              counter_one: 'Changed language just once',\n              counter_other: 'Changed language already {{count}} times',\n              date: 'It\\'s {{date, LLLL}}'\n            }\n          }\n        },\n        de: {\n          translation: {\n            head: {\n              title: 'Meine grossartige Webseite',\n              description: 'Die Beschreibung dieser grossartigen Webseite.'\n            },\n            intro: {\n              title: 'Webseite',\n              subTitle: 'Ein Untertitel'\n            },\n            footer: {\n              counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n              counter_other: 'Die Sprache wurde {{count}} mal gewechselt',\n              date: 'Es ist {{date, LLLL}}'\n            }\n          }\n        }\n      }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // define the formatter function\n      i18next.services.formatter.add('LLLL', (value, lng, options) => {\n        return moment(value).locale(lng).format('LLLL');\n      });\n\n      // for options see\n      // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n      jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n      // fill language switcher\n      Object.keys(lngs).map((lng) => {\n        const opt = new Option(lngs[lng].nativeName, lng);\n        if (lng === i18next.resolvedLanguage) {\n          opt.setAttribute(\"selected\", \"selected\");\n        }\n        $('#languageSwitcher').append(opt);\n      });\n      let languageChangedCounter = 0;\n      $('#languageSwitcher').change((a, b, c) => {\n        const chosenLng = $(this).find(\"option:selected\").attr('value');\n        i18next.changeLanguage(chosenLng, () => {\n          rerender();\n            \n          // language changed message\n          languageChangedCounter++;\n          $('#languageChangedNotification').localize({ count: languageChangedCounter })\n          if (languageChangedCounter === 1) {\n            $('#languageChangedNotification').show();\n          }\n        });\n      });\n\n      rerender();\n    });\n});\n```\n\n**😎 Cool, now we have a language specific date formatting!**\n\nEnglish:\n![jQuery english](app_3.jpg \"locize © inweso GmbH\")\n\nGerman:\n![jQuery german](app_4.jpg \"locize © inweso GmbH\")\n\n\n### Context <a name=\"context\"></a>\n\nWhat about a specific greeting message based on the current day time? i.e. morning, evening, etc.\nThis is possible thanks to the [context](https://www.i18next.com/translation-function/context) feature of i18next.\n\nLet's create a `getGreetingTime` function and use the result as context information for our footer translation.\n<br />\nAnd add some context specific translations keys:\n\n```javascript\n// ...\n\nconst getGreetingTime = () => {\n  const split_afternoon = 12; // 24hr time to split the afternoon\n  const split_evening = 17; // 24hr time to split the evening\n  const currentHour = moment().hour();\n\n  if (currentHour >= split_afternoon && currentHour <= split_evening) {\n    return 'afternoon';\n  } else if (currentHour >= split_evening) {\n    return 'evening';\n  }\n  return 'morning';\n}\n\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n  $('#footerMessage').localize({ context: getGreetingTime() });\n  $('title').text($.t('head.title'))\n  $('meta[name=description]').attr('content', $.t('head.description'))\n}\n\n// ...\n\nresources: {\n  en: {\n    translation: {\n      // ...\n      footer: {\n        counter_one: 'Changed language just once',\n        counter_other: 'Changed language already {{count}} times',\n        date: 'It\\'s {{date, LLLL}}',\n        date_afternoon: 'Good afternoon! It\\'s {{date, LLLL}}',\n        date_evening: 'Good evening! Today was the {{date, LLLL}}',\n        date_morning: 'Good morning! Today is {{date, LLLL}} | Have a nice day!'\n      }\n    }\n  },\n  de: {\n    translation: {\n      // ...\n      footer: {\n        counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n        counter_other: 'Die Sprache wurde {{count}} mal gewechselt',\n        date: 'Es ist {{date, LLLL}}',\n        date_afternoon: 'Guten Tag! Es ist {{date, LLLL}}',\n        date_evening: 'Guten Abend! Heute war {{date, LLLL}}',\n        date_morning: 'Guten Morgen! Heute ist {{date, LLLL}} | Wünsche einen schönen Tag!'\n      }\n    }\n  }\n}\n```\n\n**😁 Yeah, It works!**\n\n![jQuery translations](app_5.jpg \"locize © inweso GmbH\")\n\n\n### Separate translations from code <a name=\"separate\"></a>\n\nHaving the translations in our `i18n.js` file works, but is not that suitable to work with, for translators.\nLet's separate the translations from the code and pleace them in dedicated json files.\n\nBecause this is a web application, [i18next-http-backend](https://github.com/i18next/i18next-http-backend) will help us to do so.\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/i18next-http-backend@1.3.2/i18nextHttpBackend.min.js\"></script>\n```\n\nCreate a `locales` folder and move the translations there:\n\n![public locales](public_folder.jpg \"locize © inweso GmbH\")\n\nAdapt the `i18n.js` file to use the `i18next-http-backend`:\n\n```javascript\n// ...\n\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // i18next-http-backend\n    // loads translations from your server\n    // https://github.com/i18next/i18next-http-backend\n    .use(i18nextHttpBackend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en'\n      // i.e. if you want to customize a different translation path,\n      // use the loadPath option:\n      // backend: {\n      //   loadPath: '/assets/locales/{{lng}}/{{ns}}.json'\n      // }\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // ...\n    });\n});\n```\n\nNow the translations are loaded asynchronously, so it may be the UI will refresh a bit later, as soon as the translations are loaded.\nTo optimize this behaviour, you can show some sort of loading indicator until the i18next is initialized.\n\nSomething like:\n\n```html\n<div id=\"loader\">Loading...</div>\n<div id=\"content\" style=\"display: none;\">\n  <!-- your real content -->\n</div>\n```\n\n```javascript\n$('#loader').hide();\n$('#content').show();\n```\n\nNow your app looks still the same, but your translations are separated.\n\n![](spinner.gif)\n\nIf you want to support a new language, you just create a new folder and a new translation json file.\nThis gives you the possibility to send the translations to some translators.\nOr if you're working with a translation management system you can just [synchronize the files with a cli](https://github.com/locize/react-tutorial#use-the-locize-cli).\n\n\n### Better translation management <a name=\"better-translation-management\"></a>\n\nBy sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you.\nThis is a traditional way. But be aware sending files around creates always an overhead.\n\n> Does a better option exist?\n\n#### For sure! <a name=\"for-sure\"></a>\n\ni18next helps to get the application translated, and this is great - but there is more to it.\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- How do you deploy translation changes without deploying your complete application?\n- and a lot more...\n\n**Looking for something like this❓**\n\n- [Easy to integrate](https://docs.locize.com/integration/instrumenting-your-code#i-18-next)\n- Continuous deployment? [Continuous localization](https://locize.com/how-it-works.html#continouslocalization)!\n- Manage the translation files with ease\n- [Order professional translations](https://docs.locize.com/guides-tips-and-tricks/working-with-translators)\n- Analytics & Statistics\n- [Profit from our content delivery network (CDN)](https://docs.locize.com/whats-inside/cdn-content-delivery-network)\n- [Versioning of your translations](https://docs.locize.com/more/versioning)\n- [Automatic and On-Demand Machine Translation](https://docs.locize.com/whats-inside/auto-machine-translation)\n- [Riskfree: Take your data with you](https://docs.locize.com/more/general-questions/how-is-locize-different-from-the-alternatives#service-lock-in)\n- [Transparent and fair pricing](https://locize.com/pricing.html)\n- and a lot more...\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by using the [cli](https://github.com/locize/react-tutorial#use-the-locize-cli) or by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations).\n\nDone so, we're going to replace [i18next-http-backend](https://github.com/i18next/i18next-http-backend) with [i18next-locize-backend](https://github.com/locize/i18next-locize-backend).\n\n```html\n<!-- ... -->\n<script src=\"https://cdn.jsdelivr.net/npm/i18next-locize-backend@4.2.8/i18nextLocizeBackend.min.js\"></script>\n<!-- ... -->\n```\n\nAfter having imported the translations to locize, delete the `locales` folder and adapt the `i18n.js` file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project:\n\n```javascript\n// ...\n\nconst locizeOptions = {\n  projectId: '8d751621-323e-4bda-94c8-7d2368102e62',\n  apiKey: '302aca54-2ea8-4b9f-b5f0-df1369c59427' // YOU should not expose your apps API key to production!!!\n};\n\n$(function () {\n  // use plugins and options as needed, for options, detail see\n  // https://www.i18next.com\n  i18next\n    // i18next-locize-backend\n    // loads translations from your project, saves new keys to it (saveMissing: true)\n    // https://github.com/locize/i18next-locize-backend\n    .use(i18nextLocizeBackend)\n    // detect user language\n    // learn more: https://github.com/i18next/i18next-browser-languageDetector\n    .use(i18nextBrowserLanguageDetector)\n    // init i18next\n    // for all options read: https://www.i18next.com/overview/configuration-options\n    .init({\n      debug: true,\n      fallbackLng: 'en',\n      backend: locizeOptions\n    }, (err, t) => {\n      if (err) return console.error(err);\n\n      // ...\n    });\n});\n```\n\n[i18next-locize-backend](https://github.com/locize/i18next-locize-backend) offers a functionality to retrieve the available languages directly from locize, let's use it:\n\n```javascript\n// ...\n\nconst locizeOptions = {\n  projectId: '8d751621-323e-4bda-94c8-7d2368102e62',\n  apiKey: '302aca54-2ea8-4b9f-b5f0-df1369c59427' // YOU should not expose your apps API key to production!!!\n};\n\n$(function () {\n  const locizeBackend = new i18nextLocizeBackend(locizeOptions, (err, opts, lngs) => {\n    if (err) return console.error(err);\n\n    // use plugins and options as needed, for options, detail see\n    // https://www.i18next.com\n    i18next\n      // i18next-locize-backend\n      // loads translations from your project, saves new keys to it (saveMissing: true)\n      // https://github.com/locize/i18next-locize-backend\n      .use(locizeBackend)\n      // detect user language\n      // learn more: https://github.com/i18next/i18next-browser-languageDetector\n      .use(i18nextBrowserLanguageDetector)\n      // init i18next\n      // for all options read: https://www.i18next.com/overview/configuration-options\n      .init({\n        debug: true,\n        fallbackLng: 'en',\n        backend: locizeOptions\n      }, (err, t) => {\n        if (err) return console.error(err);\n\n        // new usage\n        i18next.services.formatter.add('LLLL', (value, lng, options) => {\n          return moment(value).locale(lng).format('LLLL');\n        });\n\n        // for options see\n        // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n        jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n        // fill language switcher\n        // with the lngs retrieved directly from locize...\n        Object.keys(lngs).map((lng) => {\n          const opt = new Option(lngs[lng].nativeName, lng);\n          if (lng === i18next.resolvedLanguage) {\n            opt.setAttribute(\"selected\", \"selected\");\n          }\n          $('#languageSwitcher').append(opt);\n        });\n        let languageChangedCounter = 0;\n        $('#languageSwitcher').change((a, b, c) => {\n          const chosenLng = $(this).find(\"option:selected\").attr('value');\n          i18next.changeLanguage(chosenLng, () => {\n            rerender();\n            \n            // language changed message\n            languageChangedCounter++;\n            $('#languageChangedNotification').localize({ count: languageChangedCounter })\n            if (languageChangedCounter === 1) {\n              $('#languageChangedNotification').show();\n            }\n          });\n        });\n\n        rerender();\n\n        $('#loader').hide();\n        $('#content').show();\n      });\n  });\n});\n```\n\nNow the translations are served directly from the [locize CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network). The jQuery i18n has now CDN superpower 😁.\n\n#### save missing translations <a name=\"save-missing\"></a>\n\nThanks to the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys gets added to locize automatically, while developing the app.\n\nJust pass `saveMissing: true` in the i18next options:\n\n```javascript\n// ...\n.init({\n  debug: true,\n  fallbackLng: 'en',\n  backend: locizeOptions,\n  saveMissing: true // do not enable it on production\n}, (err, t) => {\n// ...\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<div data-i18n=\"new.key\">this will be added automatically</div>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation) and the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation.\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see how the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n```html\n<!-- ... -->\n<script src=\"https://cdn.jsdelivr.net/npm/locize-lastused@3.0.13/locizeLastUsed.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/locize@2.2.4/locize.min.js\"></script>\n<!-- ... -->\n```\n\nuse them in `i18n.js`:\n\n```javascript\nconst getGreetingTime = () => {\n  const split_afternoon = 12; // 24hr time to split the afternoon\n  const split_evening = 17; // 24hr time to split the evening\n  const currentHour = moment().hour();\n\n  if (currentHour >= split_afternoon && currentHour <= split_evening) {\n    return 'afternoon';\n  } else if (currentHour >= split_evening) {\n    return 'evening';\n  }\n  return 'morning';\n}\n\nconst rerender = () => {\n  // start localizing, details:\n  // https://github.com/i18next/jquery-i18next#usage-of-selector-function\n  $('body').localize();\n  $('#footerMessage').localize({ context: getGreetingTime() });\n  $('title').text($.t('head.title'))\n  $('meta[name=description]').attr('content', $.t('head.description'))\n}\n\nconst locizeOptions = {\n  projectId: '8d751621-323e-4bda-94c8-7d2368102e62',\n  apiKey: '302aca54-2ea8-4b9f-b5f0-df1369c59427' // YOU should not expose your apps API key to production!!!\n};\n\ni18next.on('editorSaved', rerender); // used for the inContext editor\n\n$(function () {\n  const locizeBackend = new i18nextLocizeBackend(locizeOptions, (err, opts, lngs) => {\n    if (err) return console.error(err);\n\n    // use plugins and options as needed, for options, detail see\n    // https://www.i18next.com\n    i18next\n      // locize-editor\n      // InContext Editor of locize\n      .use(locize.locizePlugin)\n      // locize-lastused (do not use this in production)\n      // sets a timestamp of last access on every translation segment on locize\n      // -> safely remove the ones not being touched for weeks/months\n      // https://github.com/locize/locize-lastused\n      .use(locizeLastUsed)\n      // i18next-locize-backend\n      // loads translations from your project, saves new keys to it (saveMissing: true)\n      // https://github.com/locize/i18next-locize-backend\n      .use(locizeBackend)\n      // detect user language\n      // learn more: https://github.com/i18next/i18next-browser-languageDetector\n      .use(i18nextBrowserLanguageDetector)\n      // init i18next\n      // for all options read: https://www.i18next.com/overview/configuration-options\n      .init({\n        ...opts,\n        debug: true,\n        fallbackLng: 'en',\n        backend: locizeOptions,\n        locizeLastUsed: locizeOptions,\n        saveMissing: true\n        // interpolation: {\n        //   // legacy usage\n        //   format: (value, format, lng) => {\n        //     if (value instanceof Date) {\n        //       return moment(value).locale(lng).format(format);\n        //     }\n        //     return value;\n        //   }\n        // }\n      }, (err, t) => {\n        if (err) return console.error(err);\n\n        // new usage\n        i18next.services.formatter.add('LLLL', (value, lng, options) => {\n          return moment(value).locale(lng).format('LLLL');\n        });\n\n        // for options see\n        // https://github.com/i18next/jquery-i18next#initialize-the-plugin\n        jqueryI18next.init(i18next, $, { useOptionsAttr: true });\n\n        // fill language switcher\n        Object.keys(lngs).map((lng) => {\n          const opt = new Option(lngs[lng].nativeName, lng);\n          if (lng === i18next.resolvedLanguage) {\n            opt.setAttribute(\"selected\", \"selected\");\n          }\n          $('#languageSwitcher').append(opt);\n        });\n        let languageChangedCounter = 0;\n        $('#languageSwitcher').change((a, b, c) => {\n          const chosenLng = $(this).find(\"option:selected\").attr('value');\n          i18next.changeLanguage(chosenLng, () => {\n            rerender();\n            \n            // language changed message\n            languageChangedCounter++;\n            $('#languageChangedNotification').localize({ count: languageChangedCounter })\n            if (languageChangedCounter === 1) {\n              $('#languageChangedNotification').show();\n            }\n          });\n        });\n\n        rerender();\n\n        $('#loader').hide();\n        $('#content').show();\n      });\n  });\n});\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![missing key auto](missing_key_auto_mt.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![i18next last used](last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![i18next incontext](in_context.jpg \"locize © inweso GmbH\")\n\n\nNow, during development, you'll continue to save missing keys and to make use of `lastused` feature.\n\nAnd in production environment, you should disable or remove the `saveMissing` and `lastused` functionality, and also the api-key should not exposed.\n\n\n[Caching](https://docs.locize.com/more/caching):\n\n![i18next caching](caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code can be found [here](https://github.com/i18next/jquery-i18next/tree/master/example/landing).*\n\n*Check also the [code integration part](https://www.youtube.com/watch?v=ds-yEEYP1Ks&t=423s) in this [YouTube video](https://www.youtube.com/watch?v=ds-yEEYP1Ks).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [i18next](https://www.i18next.com), [jQuery localization](https://github.com/i18next/jquery-i18next) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"jquery","slug":"jquery","permalink":"https://locize.com/blog/tags/jquery/"},{"name":"jquery-i18next","slug":"jquery-i18next","permalink":"https://locize.com/blog/tags/jquery-i18next/"}]},{"title":"Internationalization (i18n) for Deno with i18next","slug":"i18n-for-deno-with-i18next","date":"un55fin55","updated":"un66fin66","comments":true,"path":"i18n-for-deno-with-i18next/","link":"","permalink":"https://locize.com/blog/i18n-for-deno-with-i18next/","excerpt":"","text":"You may already know how to properly internationalize a client side application, like described in this React based tutorial, this Angular based tutorial or this Vue based tutorial. In this blog post we will shed light on Deno. Why do I need to handle i18n in Deno? Think of all user faced content not directly rendered in your browser... For example you&#39;re building a command line interface (CLI)? You&#39;re using server side rendering (SSR)? Or you&#39;re sending some emails? etc. Let&#39;s check that out...We will show some examples that uses i18next as i18n framework. If you&#39;re curious to know why we suggest i18next, have a look at this page. Command line interface (CLI) Let&#39;s start with something simple: a verry small CLI app. We are defining a sayhi command with optional language and name parameters that should respond with a salutation in the appropriate language. 123456789101112131415import &#123; parse &#125; from &quot;https://deno.land/std/flags/mod.ts&quot;;const &#123; args &#125; = Deno;const parsedArgs = parse(args);const cmd = parsedArgs._[0];if (cmd !== &quot;sayhi&quot; &amp;&amp; cmd !== &quot;s&quot;) &#123; throw new Error(`unknown command $&#123;cmd&#125;`);&#125;const name = parsedArgs.n || parsedArgs.name;const language = parsedArgs.l || parsedArgs.language;console.log(&#123; name, language &#125;) Ok, now let&#39;s create a new i18n.ts file and setup i18next accordingly: 123456789101112131415161718192021222324252627import i18next from &quot;https://deno.land/x/i18next/index.js&quot;;import enTranslation from &quot;./locales/en/translation.json&quot; assert &#123; type: &quot;json&quot;,&#125;;import deTranslation from &quot;./locales/de/translation.json&quot; assert &#123; type: &quot;json&quot;,&#125;;const systemLocale = Intl.DateTimeFormat().resolvedOptions().locale;i18next .use(Backend) .init(&#123; // debug: true, fallbackLng: &quot;en&quot;, resources: &#123; en: &#123; translation: enTranslation, &#125;, de: &#123; translation: deTranslation, &#125;, &#125; &#125;);export default (lng: string | undefined | null) =&gt; i18next.getFixedT(lng || systemLocale); And also our translation resources: 1234567891011// locales/en/translations.json&#123; &quot;salutation&quot;: &quot;Hello World!&quot;, &quot;salutationWithName&quot;: &quot;Hello &#123;&#123;name&#125;&#125;!&quot;&#125;// locales/de/translations.json&#123; &quot;salutation&quot;: &quot;Hallo Welt!&quot;, &quot;salutationWithName&quot;: &quot;Hallo &#123;&#123;name&#125;&#125;!&quot;&#125; Now we can use the i18n.ts export like that: 123456789101112131415161718192021import &#123; parse &#125; from &quot;https://deno.land/std/flags/mod.ts&quot;;import i18n from &quot;./i18n.ts&quot;;const &#123; args &#125; = Deno;const parsedArgs = parse(args);const cmd = parsedArgs._[0];if (cmd !== &quot;sayhi&quot; &amp;&amp; cmd !== &quot;s&quot;) &#123; throw new Error(`unknown command $&#123;cmd&#125;`);&#125;const name = parsedArgs.n || parsedArgs.name;const language = parsedArgs.l || parsedArgs.language;const t = i18n(language);if (name) &#123; console.log(t(&quot;salutationWithName&quot;, &#123; name &#125;));&#125; else &#123; console.log(t(&quot;salutation&quot;));&#125; Ok, what&#39;s the result? 1234567891011## if we execute the cli command without any parameters...deno run --allow-read mod.ts sayhi## result: Hello World!## if we execute the cli command with a language parameter...deno run --allow-read mod.ts sayhi --language de## result: Hallo Welt!## if we execute the cli command with a language parameter and a name parameter...deno run --allow-read mod.ts sayhi --language de --name John## result: Hallo John! Easy, isn&#39;t it? You can also i.e. use the i18next-fs-backend to dynamically load your translations, for example like this: 12345678910111213141516171819import i18next from &quot;https://deno.land/x/i18next/index.js&quot;;import Backend from &quot;https://deno.land/x/i18next_fs_backend/index.js&quot;;const systemLocale = Intl.DateTimeFormat().resolvedOptions().locale;i18next .use(Backend) .init(&#123; // debug: true, initImmediate: false, // setting initImediate to false, will load the resources synchronously fallbackLng: &quot;en&quot;, preload: [&#x27;en&#x27;, &#x27;de&#x27;], backend: &#123; loadPath: &quot;locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&quot;, &#125;, &#125;);export default (lng: string | undefined | null) =&gt; i18next.getFixedT(lng || systemLocale); 🧑‍💻 A code example can be found here. A possible next step...A possible next step could be to professionalize the translation management. This means the translations would be &quot;managed&quot; (add new languages, new translations etc...) in a translation management system (TMS), like locize and synchronized with your code. To see how this could look like, check out Step 1 in this tutorial. Server Side Rendering (SSR) For this example we will use the http framework abc (created by 木杉, but any other framework will also work. This time we will use a different i18next module, i18next-http-middleware. It can be used for all Deno web frameworks, like abc or ServestJS, but also for Node.js web frameworks, like express or Fastify. As already said, here we will use abc. Let&#39;s again start with the i18n.js file: 12345678910111213141516171819import i18next from &#x27;https://deno.land/x/i18next/index.js&#x27;import Backend from &#x27;https://deno.land/x/i18next_fs_backend/index.js&#x27;import i18nextMiddleware from &#x27;https://deno.land/x/i18next_http_middleware/index.js&#x27;i18next .use(Backend) .use(i18nextMiddleware.LanguageDetector) .init(&#123; // debug: true, initImmediate: false, // setting initImediate to false, will load the resources synchronously backend: &#123; loadPath: &#x27;locales/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27; &#125;, fallbackLng: &#x27;en&#x27;, preload: [&#x27;en&#x27;, &#x27;de&#x27;, &#x27;it&#x27;] &#125;)export const i18n = i18nextexport const middleware = i18nextMiddleware And our translation resources... 1234567891011121314151617181920212223242526272829// locales/en/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Hello World!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Server is listening on port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125;// locales/de/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Hallo Welt!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Der server lauscht auf dem Port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125;// locales/it/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Ciao Mondo!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Il server sta aspettando sul port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125; A simple ejs template: 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;i18next - abc with dejs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= t(&#x27;home.title&#x27;) %&gt;&lt;/h1&gt; &lt;div&gt;&lt;a href=&quot;/?lng=en&quot;&gt;english&lt;/a&gt;&amp;nbsp; | &amp;nbsp;&lt;a href=&quot;/?lng=de&quot;&gt;deutsch&lt;/a&gt; | &amp;nbsp;&lt;a href=&quot;/?lng=it&quot;&gt;italiano&lt;/a&gt;&lt;/div&gt; &lt;hr /&gt; &lt;div&gt;&lt;a href=&lt;%= &quot;/raw?lng=&quot; + i18n.resolvedLanguage %&gt;&gt;raw test&lt;/a&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Our &quot;main&quot; file index.js: 1234567891011121314151617181920212223242526272829303132// deno run --allow-net --allow-read index.jsimport &#123; Application &#125; from &#x27;https://deno.land/x/abc/mod.ts&#x27;import &#123; config &#125; from &quot;https://deno.land/x/dotenv/mod.ts&quot;import &#123; i18n, middleware &#125; from &#x27;./i18n.js&#x27;import &#123; renderFile &#125; from &#x27;https://deno.land/x/dejs/mod.ts&#x27;const port = config.PORT || 8080const app = new Application()app.renderer = &#123; render(name, data) &#123; return renderFile(`./views/$&#123;name&#125;.html`, data) &#125;&#125;const handle = middleware.handle(i18n)app.use((next) =&gt; (c) =&gt; &#123; handle(c) return next(c) &#125;)app.get(&#x27;/&#x27;, (c) =&gt; c.render(&#x27;index&#x27;, &#123; t: c.request.t, i18n: c.request.i18n &#125;))app.get(&#x27;/raw&#x27;, (c) =&gt; c.request.t(&#x27;home.title&#x27;))app.start(&#123; port &#125;)console.log(i18n.t(&#x27;server.started&#x27;, &#123; port &#125;))console.log(i18n.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;de&#x27; &#125;))console.log(i18n.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;it&#x27; &#125;)) Now start the app and check what language you&#39;re seeing... If you check the console output you&#39;ll also see something like this: 1234node app.js## Server is listening on port 8080.## Der server lauscht auf dem Port 8080.## Il server sta aspettando sul port 8080. Yes, if you like, you can also internationalize your log statements 😁 🧑‍💻 A code example can be found here. A possible next step...Do you wish to manage your translations in a translation management system (TMS), like locize? Just use this cli to synchronize the translations with your code. To see how this could look like check out Step 1 in this tutorial. Alternatively, use i18next-locize-backend instead of the i18next-fs-backend. If you&#39;re running your code in a serverless environment, make sure you read this advice first! There&#39;s also an i18next crash course video. 🎉🥳 Conclusion 🎊🎁As you see i18n is also important for Deno. I hope you’ve learned a few new things about Deno server side internationalization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try i18next and also locize. 👍","raw":"---\ntitle: Internationalization (i18n) for Deno with i18next\ndescription: How does internationalization (i18n) for Deno look like? CLI, webserver, server side rendered sites, etc...\n\ndate: 2022-01-28 12:21:00\ntags:\n  - server\n  - serverside\n  - backend\n  - cli\n  - deno\n  - i18n\n  - i18next\n  - internationalization\n  - translation\n  - react\n  - abc\n  - ejs\n  - dejs\nthumbnail: i18n-for-deno-with-i18next/deno_i18next.jpg\n---\n\n![Deno i18n](deno_i18next.jpg \"Deno Internationalization\")\n\nYou may already know how to properly internationalize a client side application, like described in this [React based tutorial](../react-i18next/), this [Angular based tutorial](../angular-i18next/) or this [Vue based tutorial](../give-vue-i18n-more-superpowers/).\n\nIn this blog post we will shed light on [Deno](https://deno.land).\n\n> Why do I need to handle i18n in Deno?\n\nThink of all user faced content not directly rendered in your browser...\n\n- For example you're building a [command line interface (CLI)](#cli)?\n- You're using [server side rendering (SSR)](#ssr)?\n- Or you're sending some emails?\n- etc.\n\n## Let's check that out...\n\nWe will show some examples that uses [i18next](https://www.i18next.com) as i18n framework. If you're curious to know why we suggest i18next, have a look at [this page](https://locize.com/i18next.html).\n\n\n## Command line interface (CLI) <a name=\"cli\"></a>\n\nLet's start with something simple: a verry small CLI app.\nWe are defining a `sayhi` command with optional language and name parameters that should respond with a salutation in the appropriate language.\n\n```javascript\nimport { parse } from \"https://deno.land/std/flags/mod.ts\";\n\nconst { args } = Deno;\nconst parsedArgs = parse(args);\n\nconst cmd = parsedArgs._[0];\n\nif (cmd !== \"sayhi\" && cmd !== \"s\") {\n  throw new Error(`unknown command ${cmd}`);\n}\n\nconst name = parsedArgs.n || parsedArgs.name;\nconst language = parsedArgs.l || parsedArgs.language;\n\nconsole.log({ name, language })\n```\n\nOk, now let's create a new `i18n.ts` file and setup i18next accordingly:\n\n```javascript\nimport i18next from \"https://deno.land/x/i18next/index.js\";\nimport enTranslation from \"./locales/en/translation.json\" assert {\n  type: \"json\",\n};\nimport deTranslation from \"./locales/de/translation.json\" assert {\n  type: \"json\",\n};\n\nconst systemLocale = Intl.DateTimeFormat().resolvedOptions().locale;\n\ni18next\n  .use(Backend)\n  .init({\n    // debug: true,\n    fallbackLng: \"en\",\n    resources: {\n      en: {\n        translation: enTranslation,\n      },\n      de: {\n        translation: deTranslation,\n      },\n    }\n  });\n\nexport default (lng: string | undefined | null) =>\n  i18next.getFixedT(lng || systemLocale);\n```\n\nAnd also our translation resources:\n\n```javascript\n// locales/en/translations.json\n{\n  \"salutation\": \"Hello World!\",\n  \"salutationWithName\": \"Hello {{name}}!\"\n}\n\n// locales/de/translations.json\n{\n  \"salutation\": \"Hallo Welt!\",\n  \"salutationWithName\": \"Hallo {{name}}!\"\n}\n```\n\nNow we can use the `i18n.ts` export like that:\n\n```javascript\nimport { parse } from \"https://deno.land/std/flags/mod.ts\";\nimport i18n from \"./i18n.ts\";\n\nconst { args } = Deno;\nconst parsedArgs = parse(args);\n\nconst cmd = parsedArgs._[0];\n\nif (cmd !== \"sayhi\" && cmd !== \"s\") {\n  throw new Error(`unknown command ${cmd}`);\n}\n\nconst name = parsedArgs.n || parsedArgs.name;\nconst language = parsedArgs.l || parsedArgs.language;\n\nconst t = i18n(language);\nif (name) {\n  console.log(t(\"salutationWithName\", { name }));\n} else {\n  console.log(t(\"salutation\"));\n}\n```\n\nOk, what's the result?\n\n```sh\n## if we execute the cli command without any parameters...\ndeno run --allow-read mod.ts sayhi\n## result: Hello World!\n\n## if we execute the cli command with a language parameter...\ndeno run --allow-read mod.ts sayhi --language de\n## result: Hallo Welt!\n\n## if we execute the cli command with a language parameter and a name parameter...\ndeno run --allow-read mod.ts sayhi --language de --name John\n## result: Hallo John!\n```\n\n**Easy, isn't it?**\n\nYou can also i.e. use the [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend) to dynamically load your translations, for example like this:\n\n```javascript\nimport i18next from \"https://deno.land/x/i18next/index.js\";\nimport Backend from \"https://deno.land/x/i18next_fs_backend/index.js\";\n\nconst systemLocale = Intl.DateTimeFormat().resolvedOptions().locale;\n\ni18next\n  .use(Backend)\n  .init({\n    // debug: true,\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    fallbackLng: \"en\",\n    preload: ['en', 'de'],\n    backend: {\n      loadPath: \"locales/{{lng}}/{{ns}}.json\",\n    },\n  });\n\nexport default (lng: string | undefined | null) =>\n  i18next.getFixedT(lng || systemLocale);\n```\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-cli-app-example-deno).*\n\n### A possible next step...\n\nA possible next step could be to professionalize the translation management.\nThis means the translations would be \"managed\" (add new languages, new translations etc...) in a translation management system (TMS), like [locize](https://www.locize.com) and synchronized with your code. To see how this could look like, check out [**Step 1** in this tutorial](https://github.com/locize/react-tutorial#step-1---keep-existing-code-setup-but-synchronize-with-locize).\n\n\n## Server Side Rendering (SSR) <a name=\"ssr\"></a>\n\nFor this example we will use the http framework [abc](https://github.com/zhmushan/abc) (created by [木杉](https://twitter.com/zhmushan), but any other framework will also work.\n\nThis time we will use a different i18next module, [i18next-http-middleware](https://github.com/i18next/i18next-http-middleware).\nIt can be used for all Deno web frameworks, like [abc](https://github.com/zhmushan/abc) or [ServestJS](https://github.com/keroxp/servest), but also for Node.js web frameworks, like [express](https://expressjs.com) or [Fastify](https://www.fastify.io).\n\nAs already said, here we will use [abc](https://github.com/zhmushan/abc).\n\nLet's again start with the `i18n.js` file:\n\n```javascript\nimport i18next from 'https://deno.land/x/i18next/index.js'\nimport Backend from 'https://deno.land/x/i18next_fs_backend/index.js'\nimport i18nextMiddleware from 'https://deno.land/x/i18next_http_middleware/index.js'\n\ni18next\n  .use(Backend)\n  .use(i18nextMiddleware.LanguageDetector)\n  .init({\n    // debug: true,\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    backend: {\n      loadPath: 'locales/{{lng}}/{{ns}}.json'\n    },\n    fallbackLng: 'en',\n    preload: ['en', 'de', 'it']\n  })\n\nexport const i18n = i18next\nexport const middleware = i18nextMiddleware\n```\n\nAnd our translation resources...\n\n```javascript\n// locales/en/translations.json\n{\n  \"home\": {\n    \"title\": \"Hello World!\"\n  },\n  \"server\": {\n    \"started\": \"Server is listening on port {{port}}.\"\n  }\n}\n\n// locales/de/translations.json\n{\n  \"home\": {\n    \"title\": \"Hallo Welt!\"\n  },\n  \"server\": {\n    \"started\": \"Der server lauscht auf dem Port {{port}}.\"\n  }\n}\n\n// locales/it/translations.json\n{\n  \"home\": {\n    \"title\": \"Ciao Mondo!\"\n  },\n  \"server\": {\n    \"started\": \"Il server sta aspettando sul port {{port}}.\"\n  }\n}\n```\n\nA simple ejs template:\n\n```html\n<html>\n\n  <head>\n      <title>i18next - abc with dejs</title>\n  </head>\n\n  <body>\n      <h1><%= t('home.title') %></h1>\n      <div><a href=\"/?lng=en\">english</a>&nbsp; | &nbsp;<a href=\"/?lng=de\">deutsch</a> | &nbsp;<a href=\"/?lng=it\">italiano</a></div>\n      <hr />\n      <div><a href=<%= \"/raw?lng=\" + i18n.resolvedLanguage %>>raw test</a></div>\n  </body>\n\n</html>\n```\n\nOur \"main\" file `index.js`:\n\n```javascript\n// deno run --allow-net --allow-read index.js\nimport { Application } from 'https://deno.land/x/abc/mod.ts'\nimport { config } from \"https://deno.land/x/dotenv/mod.ts\"\nimport { i18n, middleware } from './i18n.js'\nimport { renderFile } from 'https://deno.land/x/dejs/mod.ts'\n\nconst port = config.PORT || 8080\nconst app = new Application()\n\napp.renderer = {\n  render(name, data) {\n    return renderFile(`./views/${name}.html`, data)\n  }\n}\n\nconst handle = middleware.handle(i18n)\n\napp.use((next) =>\n  (c) => {\n    handle(c)\n    return next(c)\n  }\n)\n\napp.get('/', (c) => c.render('index', { t: c.request.t, i18n: c.request.i18n }))\napp.get('/raw', (c) => c.request.t('home.title'))\n\napp.start({ port })\n\nconsole.log(i18n.t('server.started', { port }))\nconsole.log(i18n.t('server.started', { port, lng: 'de' }))\nconsole.log(i18n.t('server.started', { port, lng: 'it' }))\n```\n\nNow start the app and check what language you're seeing...\n![dejs abc](dejs_abc.jpg)\n\nIf you check the console output you'll also see something like this:\n\n```sh\nnode app.js\n## Server is listening on port 8080.\n## Der server lauscht auf dem Port 8080.\n## Il server sta aspettando sul port 8080.\n```\n\n*Yes, if you like, you can also internationalize your log statements 😁*\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-http-middleware/tree/master/example/deno).*\n\n#### A possible next step...\n\nDo you wish to manage your translations in a translation management system (TMS), like [locize](https://www.locize.com)?\n\nJust use [this cli](https://github.com/locize/locize-cli) to synchronize the translations with your code. To see how this could look like check out [**Step 1** in this tutorial](https://github.com/locize/react-tutorial#step-1---keep-existing-code-setup-but-synchronize-with-locize).\n\nAlternatively, use [i18next-locize-backend](https://github.com/locize/i18next-locize-backend) instead of the [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend).\nIf you're running your code in a serverless environment, make sure you [read this advice first](https://github.com/locize/i18next-locize-backend#important-advice-for-serverless-environments---aws-lambda-google-cloud-functions-azure-functions-etc)!\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Conclusion 🎊🎁\n\nAs you see i18n is also important for Deno.\n\nI hope you’ve learned a few new things about Deno server side internationalization and modern localization workflows.\n\nSo if you want to take your i18n topic to the next level, it's worth to try [i18next](https://www.i18next.com) and also [locize](https://www.locize.com).\n\n👍","categories":[],"tags":[{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"backend","slug":"backend","permalink":"https://locize.com/blog/tags/backend/"},{"name":"server","slug":"server","permalink":"https://locize.com/blog/tags/server/"},{"name":"serverside","slug":"serverside","permalink":"https://locize.com/blog/tags/serverside/"},{"name":"cli","slug":"cli","permalink":"https://locize.com/blog/tags/cli/"},{"name":"deno","slug":"deno","permalink":"https://locize.com/blog/tags/deno/"},{"name":"abc","slug":"abc","permalink":"https://locize.com/blog/tags/abc/"},{"name":"ejs","slug":"ejs","permalink":"https://locize.com/blog/tags/ejs/"},{"name":"dejs","slug":"dejs","permalink":"https://locize.com/blog/tags/dejs/"}]},{"title":"Static HTML Export with i18n compatibility in Next.js","slug":"next-i18n-static","date":"un22fin22","updated":"un66fin66","comments":true,"path":"next-i18n-static/","link":"","permalink":"https://locize.com/blog/next-i18n-static/","excerpt":"","text":"You know Next.js, right? - If not, stop reading this article and make something else. If you&#39;re using Next.js 13 with app directory, have a look at this blog post. Next.js is awesome! It gives you the best developer experience with all the features you need... TOC BUT, you may have heard about this So what can we do now? The recipe The outcome The voluntary part 🎉🥳 Congratulations 🎊🎁 BUT, you may have heard about this: Error: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment This happens if you&#39;re using the internationalized routing feature and are trying to generate a static HTML export by executing next export. Well, this features requires a Node.js server, or dynamic logic that cannot be computed during the build process, that&#39;s why it is unsupported. This is the case if you&#39;re using next-i18next for example. So what can we do now? An obvious option is, to renounce to the static HTML export and use a Node.js server or Vercel as deployment environment. But sometimes, due to company or architectural guidelines it is mandatory to use a static web server. Ok then renounce to i18n? - Not really, if we are here, it seems like to be a requirement. So then do it without Next.js? - But this usually means to rewrite the whole project. Executing next export when not using i18n seems to work. What if we do not try to use the internationalized routing feature and do the i18n routing on our own? The recipe To &quot;cook&quot; this recipe you will need the following ingredients: use the dynamic route segments feature willingness to change the structure of your project files willingness to adapt a bit of code a logic to detect the user language and redirect accordingly Sounds feasible. Let&#39;s start! 1. Remove the i18n options from next.config.js. 123456- const &#123; i18n &#125; = require(&#x27;./next-i18next.config&#x27;)- module.exports = &#123;- i18n, trailingSlash: true,&#125; 2. Create a [locale] folder inside your pages directory. a) Move all your pages files to that folder (not _app.js or _document.js etc..). b) Adapt your imports, if needed. 3. Create a getStatic.js file and place it for example in a lib directory. 123456789101112131415161718192021222324252627282930import &#123; serverSideTranslations &#125; from &#x27;next-i18next/serverSideTranslations&#x27;;import i18nextConfig from &#x27;../next-i18next.config&#x27;export const getI18nPaths = () =&gt; i18nextConfig.i18n.locales.map((lng) =&gt; (&#123; params: &#123; locale: lng &#125; &#125;))export const getStaticPaths = () =&gt; (&#123; fallback: false, paths: getI18nPaths()&#125;)export async function getI18nProps(ctx, ns = [&#x27;common&#x27;]) &#123; const locale = ctx?.params?.locale let props = &#123; ...(await serverSideTranslations(locale, ns)) &#125; return props&#125;export function makeStaticProps(ns = &#123;&#125;) &#123; return async function getStaticProps(ctx) &#123; return &#123; props: await getI18nProps(ctx, ns) &#125; &#125;&#125; 4. Use getStaticPaths and makeStaticProps in your pages, like this: 1234567891011121314151617181920212223242526import &#123; useTranslation &#125; from &#x27;next-i18next&#x27;import &#123; getStaticPaths, makeStaticProps &#125; from &#x27;../../lib/getStatic&#x27;import &#123; Header &#125; from &#x27;../../components/Header&#x27;import &#123; Footer &#125; from &#x27;../../components/Footer&#x27;import Link from &#x27;../../components/Link&#x27;+ const getStaticProps = makeStaticProps([&#x27;common&#x27;, &#x27;footer&#x27;])+ export &#123; getStaticPaths, getStaticProps &#125;const Homepage = () =&gt; &#123; const &#123; t &#125; = useTranslation(&#x27;common&#x27;) return ( &lt;&gt; &lt;main&gt; &lt;Header heading=&#123;t(&#x27;h1&#x27;)&#125; title=&#123;t(&#x27;title&#x27;)&#125; /&gt; &lt;div&gt; &lt;Link href=&#x27;/second-page&#x27;&gt;&lt;button type=&#x27;button&#x27;&gt;&#123;t(&#x27;to-second-page&#x27;)&#125;&lt;/button&gt;&lt;/Link&gt; &lt;/div&gt; &lt;/main&gt; &lt;Footer /&gt; &lt;/&gt; )&#125;export default Homepage 5. Install next-language-detector. npm i next-language-detector 6. Create a languageDetector.js file and place it for example in the lib directory. 1234567import languageDetector from &#x27;next-language-detector&#x27;import i18nextConfig from &#x27;../next-i18next.config&#x27;export default languageDetector(&#123; supportedLngs: i18nextConfig.i18n.locales, fallbackLng: i18nextConfig.i18n.defaultLocale&#125;) 7. Create a redirect.js file and place it for example in the lib directory. 123456789101112131415161718192021222324252627282930313233import &#123; useEffect &#125; from &#x27;react&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;import languageDetector from &#x27;./languageDetector&#x27;export const useRedirect = (to) =&gt; &#123; const router = useRouter() to = to || router.asPath // language detection useEffect(() =&gt; &#123; const detectedLng = languageDetector.detect() if (to.startsWith(&#x27;/&#x27; + detectedLng) &amp;&amp; router.route === &#x27;/404&#x27;) &#123; // prevent endless loop router.replace(&#x27;/&#x27; + detectedLng + router.route) return &#125; languageDetector.cache(detectedLng) router.replace(&#x27;/&#x27; + detectedLng + to) &#125;) return &lt;&gt;&lt;/&gt;&#125;;export const Redirect = () =&gt; &#123; useRedirect() return &lt;&gt;&lt;/&gt;&#125;// eslint-disable-next-line react/display-nameexport const getRedirect = (to) =&gt; () =&gt; &#123; useRedirect(to) return &lt;&gt;&lt;/&gt;&#125; 8. For each of your pages files in your [locale] directory, but especially for the index.js file, create a file with the same name with this content: 12import &#123; Redirect &#125; from &#x27;../lib/redirect&#x27;export default Redirect 9. Create a Link.js component and place it for example in the components directory. 1234567891011121314151617181920212223242526import React from &#x27;react&#x27;import Link from &#x27;next/link&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const LinkComponent = (&#123; children, skipLocaleHandling, ...rest &#125;) =&gt; &#123; const router = useRouter() const locale = rest.locale || router.query.locale || &#x27;&#x27; let href = rest.href || router.asPath if (href.indexOf(&#x27;http&#x27;) === 0) skipLocaleHandling = true if (locale &amp;&amp; !skipLocaleHandling) &#123; href = href ? `/$&#123;locale&#125;$&#123;href&#125;` : router.pathname.replace(&#x27;[locale]&#x27;, locale) &#125; return ( &lt;&gt; &lt;Link href=&#123;href&#125;&gt; &lt;a &#123;...rest&#125;&gt;&#123;children&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/&gt; )&#125;export default LinkComponent 10. Replace al next/link Link imports with the appropriate ../components/Link Link import: 12- import Link from &#x27;next/link&#x27;+ import Link from &#x27;../../components/Link&#x27; 11. Add or modify your _document.js file to set the correct html lang attribute: 12345678910111213141516171819import Document, &#123; Html, Head, Main, NextScript &#125; from &#x27;next/document&#x27;import i18nextConfig from &#x27;../next-i18next.config&#x27;class MyDocument extends Document &#123; render() &#123; const currentLocale = this.props.__NEXT_DATA__.query.locale || i18nextConfig.i18n.defaultLocale return ( &lt;Html lang=&#123;currentLocale&#125;&gt; &lt;Head /&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) &#125;&#125;export default MyDocument 12. In case you have a language switcher, create or adapt it: 1234567891011121314151617181920212223242526272829303132// components/LanguageSwitchLink.jsimport languageDetector from &#x27;../lib/languageDetector&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;import Link from &#x27;next/link&#x27;const LanguageSwitchLink = (&#123; locale, ...rest &#125;) =&gt; &#123; const router = useRouter() let href = rest.href || router.asPath let pName = router.pathname Object.keys(router.query).forEach((k) =&gt; &#123; if (k === &#x27;locale&#x27;) &#123; pName = pName.replace(`[$&#123;k&#125;]`, locale) return &#125; pName = pName.replace(`[$&#123;k&#125;]`, router.query[k]) &#125;) if (locale) &#123; href = rest.href ? `/$&#123;locale&#125;$&#123;rest.href&#125;` : pName &#125; return ( &lt;Link href=&#123;href&#125; onClick=&#123;() =&gt; languageDetector.cache(locale)&#125; &gt; &lt;button style=&#123;&#123; fontSize: &#x27;small&#x27; &#125;&#125;&gt;&#123;locale&#125;&lt;/button&gt; &lt;/Link&gt; );&#125;;export default LanguageSwitchLink 12345678910111213141516171819202122232425262728// components/Footer.jsimport &#123; useTranslation &#125; from &#x27;next-i18next&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;import LanguageSwitchLink from &#x27;./LanguageSwitchLink&#x27;import i18nextConfig from &#x27;../next-i18next.config&#x27;export const Footer = () =&gt; &#123; const router = useRouter() const &#123; t &#125; = useTranslation(&#x27;footer&#x27;) const currentLocale = router.query.locale || i18nextConfig.i18n.defaultLocale return ( &lt;footer&gt; &lt;p&gt; &lt;span style=&#123;&#123; lineHeight: &#x27;4.65em&#x27;, fontSize: &#x27;small&#x27; &#125;&#125;&gt;&#123;t(&#x27;change-locale&#x27;)&#125;&lt;/span&gt; &#123;i18nextConfig.i18n.locales.map((locale) =&gt; &#123; if (locale === currentLocale) return null return ( &lt;LanguageSwitchLink locale=&#123;locale&#125; key=&#123;locale&#125; /&gt; ) &#125;)&#125; &lt;/p&gt; &lt;/footer&gt; )&#125; The outcome If you now start your project (next dev) you should see, more or less, the same behaviour as before. So what&#39;s the benefit? Try: next build &amp;&amp; next export You should see something like this at the end: 123456789● (SSG) automatically generated as static HTML + JSON (uses getStaticProps)info - using build directory: /Users/usr/projects/my-awesome-project/.nextinfo - Copying &quot;static build&quot; directoryinfo - No &quot;exportPathMap&quot; found in &quot;/Users/usr/projects/my-awesome-project/next.config.js&quot;. Generating map from &quot;./pages&quot;info - Launching 9 workersinfo - Copying &quot;public&quot; directoryinfo - Exporting (3/3)Export successful. Files written to /Users/usr/projects/my-awesome-project/out Yeah no i18n support is not compatible with next export error anymore!!! Congratulations! Now you can &quot;deploy&quot; the content of your out directory to any static web server. 🧑‍💻 The complete code can be found here. The voluntary part Connect to an awesome translation management system and manage your translations outside of your code. Let&#39;s synchronize the translation files with locize. This can be done on-demand or on the CI-Server or before deploying the app. What to do to reach this step: in locize: signup at https://locize.app/register and login in locize: create a new project in locize: add all your additional languages (this can also be done via API) install the locize-cli (npm i locize-cli) Use the locize-cliUse the locize sync command to synchronize your local repository (public/locales) with what is published on locize. Alternatively, you can also use the locize download command to always download the published locize translations to your local repository (public/locales) before bundling your app. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about static site generation (SSG), Next.js, next-i18next, i18next and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍 Looking for an optimized Next.js translations setup? Here you&#39;ll find a blog post on how to best use next-i18next with client side translation download and SEO optimization.","raw":"---\ntitle: Static HTML Export with i18n compatibility in Next.js\ndescription: How to generate a static HTML export with i18n compatibility in Next.js.\n\ndate: 2021-12-07\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - next-i18next\n  - next\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - translation\nthumbnail: next-i18n-static/title.jpg\nredirect_from:\n- /2021-12-07-next-i18n-static\n\nlabel: next-i18n-static\nlang: en\n---\n\n![](title.jpg \"Next.js SSG example\")\n\nYou know [Next.js](https://nextjs.org), right? - If not, stop reading this article and make something else.\n\n*If you're using Next.js 13 with app directory, have a look at [this blog post](../next-13-app-dir-i18n/).*\n\nNext.js is awesome! It gives you the best developer experience with all the features you need...\n\n\n### TOC\n  * [BUT, you may have heard about this](#but)\n  * [So what can we do now?](#what-do)\n  * [The recipe](#recipe)\n  * [The outcome](#outcome)\n  * [The voluntary part](#voluntary)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n      \n\n## **BUT**, you may have heard about this: <a name=\"but\"></a>\n\n>Error: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment\n\nThis happens if you're using the [internationalized routing](https://nextjs.org/docs/advanced-features/i18n-routing) feature and are trying to generate a [static HTML export](https://nextjs.org/docs/advanced-features/static-html-export) by executing `next export`.\nWell, this features requires a Node.js server, or dynamic logic that cannot be computed during the build process, that's why it is [unsupported](https://nextjs.org/docs/advanced-features/static-html-export#unsupported-features).\n\nThis is the case if you're using [next-i18next](https://github.com/i18next/next-i18next) for example.\n\n## So what can we do now? <a name=\"what-do\"></a>\n\n![](what.jpg)\n\nAn obvious option is, to renounce to the static HTML export and use a Node.js server or [Vercel](https://vercel.com) as deployment environment.\n\nBut sometimes, due to company or architectural guidelines it is mandatory to use a static web server.\n<br/>\nOk then renounce to i18n? - Not really, if we are here, it seems like to be a requirement.\n<br/>\nSo then do it without [Next.js](https://nextjs.org)? - But this usually means to rewrite the whole project.\n\nExecuting `next export` when not using i18n seems to work.\nWhat if we do not try to use the [internationalized routing](https://nextjs.org/docs/advanced-features/i18n-routing) feature and do the i18n routing on our own?\n\n\n## The recipe <a name=\"recipe\"></a>\n\n![](cook-book.jpg \"recipe\")\n\nTo \"cook\" this recipe you will need the following ingredients:\n\n- use the [dynamic route segments](https://nextjs.org/docs/routing/introduction#dynamic-route-segments) feature\n- willingness to change the structure of your project files\n- willingness to adapt a bit of code\n- a logic to detect the user language and redirect accordingly\n\nSounds feasible. Let's start!\n\n\n**1. Remove the i18n options from `next.config.js`.**\n\n  ```diff\n  - const { i18n } = require('./next-i18next.config')\n  - \n  module.exports = {\n  -   i18n,\n    trailingSlash: true,\n  }\n  ```\n\n**2. Create a `[locale]` folder inside your pages directory.**\n\n  a) Move all your pages files to that folder *(not `_app.js` or `_document.js` etc..)*.\n\n  b) Adapt your imports, if needed.\n\n**3. Create a `getStatic.js` file and place it for example in a `lib` directory.**\n\n  ```js\n  import { serverSideTranslations } from 'next-i18next/serverSideTranslations';\n  import i18nextConfig from '../next-i18next.config'\n\n  export const getI18nPaths = () =>\n    i18nextConfig.i18n.locales.map((lng) => ({\n      params: {\n        locale: lng\n      }\n    }))\n\n  export const getStaticPaths = () => ({\n    fallback: false,\n    paths: getI18nPaths()\n  })\n\n  export async function getI18nProps(ctx, ns = ['common']) {\n    const locale = ctx?.params?.locale\n    let props = {\n      ...(await serverSideTranslations(locale, ns))\n    }\n    return props\n  }\n\n  export function makeStaticProps(ns = {}) {\n    return async function getStaticProps(ctx) {\n      return {\n        props: await getI18nProps(ctx, ns)\n      }\n    }\n  }\n  ```\n\n**4. Use `getStaticPaths` and `makeStaticProps` in your pages, like this:**\n\n  ```diff\n  import { useTranslation } from 'next-i18next'\n  import { getStaticPaths, makeStaticProps } from '../../lib/getStatic'\n  import { Header } from '../../components/Header'\n  import { Footer } from '../../components/Footer'\n  import Link from '../../components/Link'\n\n  + const getStaticProps = makeStaticProps(['common', 'footer'])\n  + export { getStaticPaths, getStaticProps }\n\n  const Homepage = () => {\n    const { t } = useTranslation('common')\n\n    return (\n      <>\n        <main>\n          <Header heading={t('h1')} title={t('title')} />\n          <div>\n            <Link href='/second-page'><button type='button'>{t('to-second-page')}</button></Link>\n          </div>\n        </main>\n        <Footer />\n      </>\n    )\n  }\n\n  export default Homepage\n  ```\n\n**5. Install [next-language-detector](https://github.com/i18next/next-language-detector).**\n\n  `npm i next-language-detector`\n\n**6. Create a `languageDetector.js` file and place it for example in the `lib` directory.**\n\n  ```js\n  import languageDetector from 'next-language-detector'\n  import i18nextConfig from '../next-i18next.config'\n\n  export default languageDetector({\n    supportedLngs: i18nextConfig.i18n.locales,\n    fallbackLng: i18nextConfig.i18n.defaultLocale\n  })\n  ```\n\n**7. Create a `redirect.js` file and place it for example in the `lib` directory.**\n\n  ```js\n  import { useEffect } from 'react'\n  import { useRouter } from 'next/router'\n  import languageDetector from './languageDetector'\n\n  export const useRedirect = (to) => {\n    const router = useRouter()\n    to = to || router.asPath\n\n    // language detection\n    useEffect(() => {\n      const detectedLng = languageDetector.detect()\n      if (to.startsWith('/' + detectedLng) && router.route === '/404') { // prevent endless loop\n        router.replace('/' + detectedLng + router.route)\n        return\n      }\n\n      languageDetector.cache(detectedLng)\n      router.replace('/' + detectedLng + to)\n    })\n\n    return <></>\n  };\n\n  export const Redirect = () => {\n    useRedirect()\n    return <></>\n  }\n\n  // eslint-disable-next-line react/display-name\n  export const getRedirect = (to) => () => {\n    useRedirect(to)\n    return <></>\n  }\n  ```\n\n**8. For each of your pages files in your `[locale]` directory, but especially for the `index.js` file, create a file with the same name with this content:**\n\n  ```js\n  import { Redirect } from '../lib/redirect'\n  export default Redirect\n  ```\n\n**9. Create a `Link.js` component and place it for example in the `components` directory.**\n\n  ```js\n  import React from 'react'\n  import Link from 'next/link'\n  import { useRouter } from 'next/router'\n\n  const LinkComponent = ({ children, skipLocaleHandling, ...rest }) => {\n    const router = useRouter()\n    const locale = rest.locale || router.query.locale || ''\n\n    let href = rest.href || router.asPath\n    if (href.indexOf('http') === 0) skipLocaleHandling = true\n    if (locale && !skipLocaleHandling) {\n      href = href\n        ? `/${locale}${href}`\n        : router.pathname.replace('[locale]', locale)\n    }\n\n    return (\n      <>\n        <Link href={href}>\n          <a {...rest}>{children}</a>\n        </Link>\n      </>\n    )\n  }\n\n  export default LinkComponent\n  ```\n\n**10. Replace al `next/link` `Link` imports with the appropriate `../components/Link` `Link` import:**\n\n  ```diff\n  - import Link from 'next/link'\n  + import Link from '../../components/Link'\n  ```\n\n**11. Add or modify your `_document.js` file to set the correct html `lang` attribute:**\n\n  ```js\n  import Document, { Html, Head, Main, NextScript } from 'next/document'\n  import i18nextConfig from '../next-i18next.config'\n\n  class MyDocument extends Document {\n    render() {\n      const currentLocale = this.props.__NEXT_DATA__.query.locale || i18nextConfig.i18n.defaultLocale\n      return (\n        <Html lang={currentLocale}>\n          <Head />\n          <body>\n            <Main />\n            <NextScript />\n          </body>\n        </Html>\n      )\n    }\n  }\n\n  export default MyDocument\n  ```\n\n**12. In case you have a language switcher, create or adapt it:**\n\n  ```js\n  // components/LanguageSwitchLink.js\n  import languageDetector from '../lib/languageDetector'\n  import { useRouter } from 'next/router'\n  import Link from 'next/link'\n\n  const LanguageSwitchLink = ({ locale, ...rest }) => {\n    const router = useRouter()\n\n    let href = rest.href || router.asPath\n    let pName = router.pathname\n    Object.keys(router.query).forEach((k) => {\n      if (k === 'locale') {\n        pName = pName.replace(`[${k}]`, locale)\n        return\n      }\n      pName = pName.replace(`[${k}]`, router.query[k])\n    })\n    if (locale) {\n      href = rest.href ? `/${locale}${rest.href}` : pName\n    }\n\n    return (\n      <Link\n        href={href}\n        onClick={() => languageDetector.cache(locale)}\n      >\n        <button style={{ fontSize: 'small' }}>{locale}</button>\n      </Link>\n    );\n  };\n\n  export default LanguageSwitchLink\n  ```\n\n  ```js\n  // components/Footer.js\n  import { useTranslation } from 'next-i18next'\n  import { useRouter } from 'next/router'\n  import LanguageSwitchLink from './LanguageSwitchLink'\n  import i18nextConfig from '../next-i18next.config'\n\n  export const Footer = () => {\n    const router = useRouter()\n    const { t } = useTranslation('footer')\n    const currentLocale = router.query.locale || i18nextConfig.i18n.defaultLocale\n\n    return (\n      <footer>\n        <p>\n          <span style={{ lineHeight: '4.65em', fontSize: 'small' }}>{t('change-locale')}</span>\n          {i18nextConfig.i18n.locales.map((locale) => {\n            if (locale === currentLocale) return null\n            return (\n              <LanguageSwitchLink\n                locale={locale}\n                key={locale}\n              />\n            )\n          })}\n        </p>\n      </footer>\n    )\n  }\n  ```\n\n\n## The outcome <a name=\"outcome\"></a>\n\n![](result.jpg)\n\nIf you now start your project (`next dev`) you should see, more or less, the same behaviour as before.\n\nSo what's the benefit?\n\nTry: `next build && next export`\n\nYou should see something like this at the end:\n\n```sh\n●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)\n\ninfo  - using build directory: /Users/usr/projects/my-awesome-project/.next\ninfo  - Copying \"static build\" directory\ninfo  - No \"exportPathMap\" found in \"/Users/usr/projects/my-awesome-project/next.config.js\". Generating map from \"./pages\"\ninfo  - Launching 9 workers\ninfo  - Copying \"public\" directory\ninfo  - Exporting (3/3)\nExport successful. Files written to /Users/usr/projects/my-awesome-project/out\n```\n\n**Yeah no `i18n support is not compatible with next export` error anymore!!!**\n\n**Congratulations! Now you can \"deploy\" the content of your `out` directory to any static web server.**\n\n*🧑‍💻 The complete code can be found [here](https://github.com/i18next/next-language-detector/tree/main/examples/basic).*\n\n\n## The voluntary part <a name=\"voluntary\"></a>\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\nConnect to an awesome translation management system and manage your translations outside of your code.\n\nLet's synchronize the translation files with [locize](https://locize.com).\nThis can be done on-demand or on the CI-Server or before deploying the app.\n\n### What to do to reach this step:\n1. in locize: signup at https://locize.app/register and [login](https://docs.locize.com/integration/getting-started/create-a-user-account)\n2. in locize: [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project)\n3. in locize: add all your additional languages (this can also be done via [API](https://docs.locize.com/integration/api#add-new-language))\n4. install the [locize-cli](https://github.com/locize/locize-cli) (`npm i locize-cli`)\n\n### Use the [locize-cli](https://github.com/locize/locize-cli)\nUse the `locize sync` command to synchronize your local repository (`public/locales`) with what is published on locize.\n\nAlternatively, you can also use the `locize download` command to always download the published locize translations to your local repository (`public/locales`) before bundling your app.\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about static site generation (SSG), [Next.js](https://nextjs.org), [next-i18next](https://github.com/i18next/next-i18next), [i18next](https://www.i18next.com) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n\n---\n\n## Looking for an optimized Next.js translations setup?\n\n[![next-i18next](../next-i18next/next-i18next.jpg)](../next-i18next/)\n[Here](../next-i18next/) you'll find a blog post on how to best use next-i18next with client side translation download and SEO optimization.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"next","slug":"next","permalink":"https://locize.com/blog/tags/next/"},{"name":"next-i18next","slug":"next-i18next","permalink":"https://locize.com/blog/tags/next-i18next/"}]},{"title":"What is video game localization","slug":"what-is-video-game-localization","date":"un33fin33","updated":"un33fin33","comments":true,"path":"what-is-video-game-localization/","link":"","permalink":"https://locize.com/blog/what-is-video-game-localization/","excerpt":"","text":"Video games are one of the biggest recreational pastimes in the world, with recent estimates suggesting that there are currently nearly 2.7 billion gamers across the globe. The incredible demand in recent years has seen growth skyrocket, and estimates suggest that by 2025 the industry will be worth an astounding $268 billion, up from the $159.3 billion in 2020. While there can be no denying the popularity of the video game market, effective localization is essential for every video game producer. What is localization in video games, though? How does it work? To help you, we thought we would take a closer look at what video game localization is and how it benefits not only game producers but players, too. What is localization in video games?While the very first video games such as tennis or Tetris might have been simple storylines, modern video games are a truly holistic experience more akin to a feature movie. Games such as Red Dead Redemption, Grand Theft Auto, and Call of Duty are truly an in-depth story that takes gaming to completely new levels. Increasingly becoming more like a Hollywood blockbuster, modern games are highly sophisticated pieces of software. However, the cinematic gameplay, complex dialogue, and real-time interaction mean the game needs to be able to work across multiple markets, languages, and countries. This is where video game localization is vital, helping to ensure that players around the world are able to enjoy the same experience. Localization makes it feel like the game was made for every region it has been launched in, improving the overall player experience. What is localization in video games?While it might seem like a simple enough concept, the actual process of localization is incredibly complex. When it comes to answering the question, “what is localization in video games?” there are many different factors that need to combine to ensure a seamless playing experience for every gamer. The three most important areas for video game localization are: 1) The in-game storyVideo games are becoming a far more complex story that has many interwoven narratives that combine as players work their way through. This helps to keep them engaged, but in order for every gamer to have the same experience, the script and story need to be localized to specific regions. This means that everything from character names, weapons, and locations should be adapted for the target audience. For example, if the game was set in Russia, then it would not make sense to have a local bar with an English name. Game developers should be working to ensure the script and gameplay are as realistic as possible; otherwise, they risk discouraging players from continuing with the game. Equally, it is important to remember that names change around the world. For example, while Kim might be a feminine name in America, it is a popular male name in places such as Norway. This might seem like a minor difference against the overall gameplay, but these little nuances are essential in ensuring that the game is able to capture the attention of players. 2) Technical elementsOf course, while the overall gameplay experience is essential, game developers also need to ensure that they are focusing on localizing the many various technical aspects of the game too. One of the biggest areas most commonly overlooked is how dates and times are written, or the units of measurements are displayed. These are critical components in creating a truly immersive experience for every player. It is also important to consider the space for text and the symbols being used. For example, in Europe, many languages use quite short words apart from German, which traditionally has quite lengthy words. This is something that will need to be considered when adding in subtitles or written wording. 3) Marketing campaignsWhen it comes to understanding “what is localization in video games?” it is important to remember that it is not just limited to the actual game itself. In the highly competitive world of modern gaming, marketing campaigns are one of the most important steps to success and begin months, if not years, in advance of the launch. However, to truly maximize the commercial appeal of the game, developers need to ensure that they are localizing their marketing campaign. Without doing so, they risk alienating certain audiences and losing a vital opportunity to maximize pre-launch interest in the game. Localizing your marketing content requires a comprehensive review of all materials. From the images and graphics being used to the language and wording, you want to ensure you are targeting the gaming habits of those players in each region you are launching in. This is also important in other areas of localization like webapps, for this check out this guide on react localization. Why is video game localization importantWhen it comes to understanding “What is localization in video games?” it is important to understand the many benefits that it can provide. 1) Boost salesFocusing on localization and culturalization ensures that gamers are more invested in your game and company. This helps you to launch the game in more regions, significantly boosting the number of players and maximizing your sales. While video game localization does require time and resource investment, it is a worthwhile process as it ensures you can reach a far greater audience. 2) Increase customer satisfactionLocalization is also a great way to boost customer satisfaction by making them feel important. When they can see that the developer has gone the extra mile to create a seamless experience that feels like it has been specifically developed for them, they become far more invested in the game. The higher the satisfaction of your players, the more likely they are to share their experience with friends and remain customers for any future games you might release. 3) Stay competitiveAs the market continues to grow, it is becoming increasingly more challenging for game developers to stand out from the crowd. This means localization is going to become increasingly more important to remain competitive. This strategic approach will allow you to branch out into more markets, helping you to become more resilient in the process. Localizing your video gameWhat is localization in video games? Well, as the market continues to grow, it is set to become an essential aspect of any game development. While it might not be the first thing that developers think of, focusing on localizing the game from the start can help to make the process far more efficient and effective. Localization can be a complex process, though, so working with a professional partner can help to ensure that you are able to create the most immersive and engaging experience possible. To make the process more streamlined, you should take the time to plan your project, create a localization kit, and creating quality assurance checks will ensure that your various localization partners know exactly what is required. The more detailed your localization is, the greater the experience that each player has and the more gamers that will want to engage with your game. With some 2.7 billion players in the world, open your game up to a wider audience today. Try Locize to make your game incredibleThe localization-software of locize helps game companies to easily translate their software-components through an easy interface and while split the development process from the marketing-work. Game localization should keep up with the development of the game. Continuous localization allows you to join several markets practically simultaneously, resulting in shorter translation turnaround times and much-needed velocity.","raw":"---\ntitle: What is video game localization\ndescription: Learn how video game translation works and how you can utilize it to boost your company's revenue.\n\ndate: 2021-09-15 10:01:48\ntags:\n  - video game\n  - translation\n  - example\n  - problems\n  - i18n\nthumbnail: what-is-video-game-localization/what-is-video-game-localization.webp\n---\n\n![what is localization in video games](what-is-video-game-localization.webp \"what is localization in video games\")\n\n\nVideo games are one of the biggest recreational pastimes in the world, with recent estimates suggesting that there are currently nearly <a href=\"https://financesonline.com/number-of-gamers-worldwide/\" title=\"2.7 billion gamers\">2.7 billion gamers</a> across the globe. The incredible demand in recent years has seen growth skyrocket, and estimates suggest that by 2025 the industry will be worth an astounding <a href=\"https://www.wepc.com/news/video-game-statistics/\" title=\"$268 billion\">$268 billion</a>, up from the $159.3 billion in 2020. \n\nWhile there can be no denying the popularity of the video game market, effective localization is essential for every video game producer. What is localization in video games, though? How does it work?\n\nTo help you, we thought we would take a closer look at what video game localization is and how it benefits not only game producers but players, too. \n\n![gamers](gamers.webp \"gamers\")\n\n\n\n## What is localization in video games?\n\nWhile the very first video games such as tennis or Tetris might have been simple storylines, modern video games are a truly holistic experience more akin to a feature movie. Games such as Red Dead Redemption, Grand Theft Auto, and Call of Duty are truly an in-depth story that takes gaming to completely new levels. \n\nIncreasingly becoming more like a Hollywood blockbuster, modern games are highly sophisticated pieces of software. However, the cinematic gameplay, complex dialogue, and real-time interaction mean the game needs to be able to work across multiple markets, languages, and countries. \n\nThis is where video game localization is vital, helping to ensure that players around the world are able to enjoy the same experience. Localization makes it feel like the game was made for every region it has been launched in, improving the overall player experience. \n\n\n\n## What is localization in video games?\n\nWhile it might seem like a simple enough concept, the actual process of localization is incredibly complex. When it comes to answering the question, “what is localization in video games?” there are many different factors that need to combine to ensure a seamless playing experience for every gamer. \n\nThe three most important areas for video game localization are:\n\n\n### 1)\tThe in-game story \nVideo games are becoming a far more complex story that has many interwoven narratives that combine as players work their way through. This helps to keep them engaged, but in order for every gamer to have the same experience, the script and story need to be localized to specific regions. \n\nThis means that everything from character names, weapons, and locations should be adapted for the target audience. For example, if the game was set in Russia, then it would not make sense to have a local bar with an English name. Game developers should be working to ensure the script and gameplay are as realistic as possible; otherwise, they risk discouraging players from continuing with the game. \n\nEqually, it is important to remember that names change around the world. For example, while Kim might be a feminine name in America, it is a popular male name in places such as Norway. This might seem like a minor difference against the overall gameplay, but these little nuances are essential in ensuring that the game is able to capture the attention of players. \n\n### 2)\tTechnical elements \nOf course, while the overall gameplay experience is essential, game developers also need to ensure that they are focusing on localizing the many various technical aspects of the game too. One of the biggest areas most commonly overlooked is how dates and times are written, or the units of measurements are displayed. \n\nThese are critical components in creating a truly immersive experience for every player. It is also important to consider the space for text and the symbols being used. For example, in Europe, many languages use quite short words apart from German, which traditionally has quite lengthy words. This is something that will need to be considered when adding in subtitles or written wording. \n\n### 3)\tMarketing campaigns \nWhen it comes to understanding “what is localization in video games?” it is important to remember that it is not just limited to the actual game itself. In the highly competitive world of modern gaming, marketing campaigns are one of the most important steps to success and begin months, if not years, in advance of the launch. \n\n![marketing campaign](marketing.webp \"marketing campaign\")\n\nHowever, to truly maximize the commercial appeal of the game, developers need to ensure that they are localizing their marketing campaign. Without doing so, they risk alienating certain audiences and losing a vital opportunity to maximize pre-launch interest in the game. \n\nLocalizing your marketing content requires a comprehensive review of all materials. From the images and graphics being used to the language and wording, you want to ensure you are targeting the gaming habits of those players in each region you are launching in. This is also important in other areas of localization like webapps, for this check out this guide on <a href=\"../react-i18next/\" title=\"react localization\">react localization</a>.\n\n\n## Why is video game localization important\n\nWhen it comes to understanding “What is localization in video games?” it is important to understand the many benefits that it can provide. \n\n### 1)\tBoost sales \nFocusing on localization and culturalization ensures that gamers are more invested in your game and company. This helps you to launch the game in more regions, significantly boosting the number of players and maximizing your sales. \n\nWhile video game localization does require time and resource investment, it is a worthwhile process as it ensures you can reach a far greater audience. \n\n### 2)\tIncrease customer satisfaction \nLocalization is also a great way to boost customer satisfaction by making them feel important. When they can see that the developer has gone the extra mile to create a seamless experience that feels like it has been specifically developed for them, they become far more invested in the game. \n\nThe higher the satisfaction of your players, the more likely they are to share their experience with friends and remain customers for any future games you might release. \n\n### 3)\tStay competitive \nAs the market continues to grow, it is becoming increasingly more challenging for game developers to stand out from the crowd. This means localization is going to become increasingly more important to remain competitive.\n\nThis strategic approach will allow you to branch out into more markets, helping you to become more resilient in the process. \n\n\n## Localizing your video game \nWhat is localization in video games? Well, as the market continues to grow, it is set to become an essential aspect of any game development. While it might not be the first thing that developers think of, focusing on localizing the game from the start can help to make the process far more efficient and effective. \n\nLocalization can be a complex process, though, so working with a professional partner can help to ensure that you are able to create the most immersive and engaging experience possible. To make the process more streamlined, you should take the time to plan your project, create a localization kit, and creating quality assurance checks will ensure that your various localization partners know exactly what is required. \n\nThe more detailed your localization is, the greater the experience that each player has and the more gamers that will want to engage with your game. With some 2.7 billion players in the world, open your game up to a wider audience today.  \n\n## Try Locize to make your game incredible\n\nThe <a href=\"/\" title=\"localization-software\">localization-software</a> of locize helps game companies to easily translate their software-components through an easy interface and while split the development process from the marketing-work. Game localization should keep up with the development of the game. Continuous localization allows you to join several markets practically simultaneously, resulting in shorter translation turnaround times and much-needed velocity.\n\n![game-localization-logo](game-localization-logo.jpg \"game-localization-logo\")","categories":[],"tags":[{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"video game","slug":"video-game","permalink":"https://locize.com/blog/tags/video-game/"},{"name":"example","slug":"example","permalink":"https://locize.com/blog/tags/example/"},{"name":"problems","slug":"problems","permalink":"https://locize.com/blog/tags/problems/"}]},{"title":"Globalization vs. Localization - What is the difference","slug":"globalization-vs-localization","date":"un33fin33","updated":"un55fin55","comments":true,"path":"globalization-vs-localization/","link":"","permalink":"https://locize.com/blog/globalization-vs-localization/","excerpt":"","text":"Do you know what is meant by globalization versus localization? From the outside, these two terms could appear like complete opposites of each other. However, that is not quite the case, and they actually go hand-in-hand, which is often where the confusion arises. To help you understand the differences between globalization versus localization, we were thinking we could take a closer look at what they mean and why they are important. What is globalization?Before looking at the differences between the two, it is essential to understand what each term means. Globalization is often the process that needs to happen before content can be localized, although the process does not stop once localization begins. Globalization is the process of adapting resources to ensure that they are able to meet the demands of various cultures. This ensures that the content is able to be easily accessed and used worldwide, and this can be done through multiple methods: LanguageOne of the core aspects of globalization is ensuring that the language is suitable to meet multiple markets. While this is also an important aspect of localization, it requires a different approach. Globalization requires translating existing content to ensure that it can be read and accessed to multiple audiences in new localities. ContentAlongside ensuring the language is suitable for multiple viewers, globalization also examines the content being used. This requires thinking about every aspect of the design and style, ensuring that it is as appealing as possible to your target audience, no matter where they are based. This can be a challenge; for example, while users read from left to right in the West, in East Asia and the Middle East, they tend to read from right to left. This often requires unique coding that allows websites to be more flexible to allow content to be adapted and ensuring the pages can support time, date, and number formats most commonly used in the reader’s location. Globalization is all about thinking of the bigger picture and how customers around the world will be able to interact and engage with your content. Also watch this interesting video from financial times Video: Globalisation to Localisation What is localization?When it comes to understanding globalization versus localization, knowing the differences between the two is crucial. While globalization is the process of ensuring the content can meet multiple markets, localization is the process of guaranteeing your resources are focused on the requirements of one specific audience. Effective localization requires multiple factors, including: TranslationsJust like globalization, one of the most important factors of localization is the language and translations you are using. For example, do you know the difference between localisation and localization? The former is how people in the United Kingdom would spell it, while the latter is how people across the Atlantic would. While this might seem like a minor difference, it is these small nuances that can transform a customer’s perception of your brand. Of course, when it comes to translation, sometimes a literal interpretation might not always make sense. That is why you need to ensure that when converting content into a new language, you make sure the meaning remains the same. Utilize the right formatsAnother important aspect of localization is ensuring that you are using the right format for things such as: Date and time Measurements Currency Telephone number formats Keyboard formats Punctuations and symbols Consider the designThe design and style are also a very important part of the localization process. This requires ensuring that the visuals match with the requirements of your target audience. This includes everything from the photography and layout of the site to the colors and tone of the writing. More detailled information wanted, read this article about what is localization. Globalization versus localization, what comes first?When it comes to understanding what is meant by globalization versus localization, you should now have a clearer idea of what both terms mean. However, which one should you focus on first? While both options can help you to create a more inclusive and engaging piece of content, no matter whether it is a website, manual, or marketing material. Deciding which stage to focus on first will depend on who your target audience is. If you are solely looking to focus on one specific region, then opting just for localization can be the better option. However, typically, globalization is the first process to undertake as this will give you a clear and strong base to work from when you begin the localization process. When it comes to looking at the differences between the two, there are three key factors to remember: 1 - Localization is the process of focusing on a specific culture, location, or audience. Globalization is the process of looking at multiple cultures, locations, or audiences. 2 - Localization is a part of the wider globalization process, whereas globalization forms part of your overall business strategy. 3 - Globalization is often part of a larger long-term business strategy, while localization is often used for more short-term actions. The pros and cons of globalization versus localizationBoth the globalization or localization strategy can be a complex process, but they are an essential part of any customer service strategy for your business. Both options are able to provide companies with a wide range of benefits, but they do also have some drawbacks. Pros and cons of globalizationGlobalization is able to provide businesses with a wide range of benefits, helping them to reach a far greater audience. Not only can this help to increase revenue by expanding your customer base, but it is also able to significantly enhance your overall brand reputation and global image. This, in turn, can help to decrease dependence on a single market, ensuring your business is more resilient in the face of economic challenges. However, globalization can be a very time-consuming process and does require additional resources alongside the many challenges of expanding a business. Pros and cons of localizationIf you are looking to enter specific new markets, then localization is essential in helping to facilitate this. It can help to create significant brand loyalty from customers, improving their overall experience with your company. By building loyal customers, you will be able to increase revenue and secure a more competitive advantage in that market. Of course, just like globalization, localization does require significant investment in terms of time and resources. If not done correctly, it can also have a negative impact on your brand image, so it is always recommended you work with a professional partner who can help you. So which is right for you?When it comes to globalization versus localization, both strategies can help you to transform your business. While they might sound like two completely different methods, globalization and localization can work in tandem to help you successfully branch out into new markets and increase your revenue. Knowing which option will be right for you will depend on the overall strategy and the audience you are looking to reach. Whichever you choose, partnering with a professional translation and localization team from a translation management platform will help ensure that it is completed to the highest standards alongside reducing the time and resource investment that you need to make. Further to read (examples)If you want to read about real-world i18n localization examples from our client cases, check out our recent blog post on website localization. Read more about how software is affected from globalization and localization and what potential localization of software has in the &quot;what is software localization&quot; blog post.","raw":"---\ntitle: Globalization vs. Localization - What is the difference\ndescription: What is the difference between globalization and localization, what does each include and what are pros and cons.\n\ndate: 2021-09-15\ntags:\n  - localization\n  - globalization\n  - l10n\n  - g11n\n  - i18n\nthumbnail: globalization-vs-localization/globalization-vs-localization.webp\n\nlabel: globalization-vs-localization\nlang: en\n---\n\n![globalization vs localization](globalization-vs-localization.webp \"globalization vs localization\")\n\n\nDo you know what is meant by globalization versus localization? From the outside, these two terms could appear like complete opposites of each other. However, that is not quite the case, and they actually go hand-in-hand, which is often where the confusion arises. \n\nTo help you understand the differences between globalization versus localization, we were thinking we could take a closer look at what they mean and why they are important.\n\n\n## What is globalization?\n\nBefore looking at the differences between the two, it is essential to understand what each term means. Globalization is often the process that needs to happen before content can be localized, although the process does not stop once localization begins. \n\nGlobalization is the process of adapting resources to ensure that they are able to meet the demands of various cultures. This ensures that the content is able to be easily accessed and used worldwide, and this can be done through multiple methods:\n\n\n### Language\nOne of the core aspects of globalization is ensuring that the language is suitable to meet multiple markets. While this is also an important aspect of localization, it requires a different approach. Globalization requires translating existing content to ensure that it can be read and accessed to multiple audiences in new localities.\n\n### Content\nAlongside ensuring the language is suitable for multiple viewers, globalization also examines the content being used. This requires thinking about every aspect of the design and style, ensuring that it is as appealing as possible to your target audience, no matter where they are based. \n\nThis can be a challenge; for example, while users read from left to right in the West, in East Asia and the Middle East, they tend to read from right to left. This often requires unique coding that allows websites to be more flexible to allow content to be adapted and ensuring the pages can support time, date, and number formats most commonly used in the reader’s location. \n\nGlobalization is all about thinking of the bigger picture and how customers around the world will be able to interact and engage with your content. \n\nAlso watch this interesting video from financial times <a href=\"https://www.youtube.com/watch?v=T9lgZper-W4\" title=\"Video: Globalisation to Localisation\">Video: Globalisation to Localisation</a>\n\n\n\n## What is localization?\nWhen it comes to understanding globalization versus localization, knowing the differences between the two is crucial. While globalization is the process of ensuring the content can meet multiple markets, localization is the process of guaranteeing your resources are focused on the requirements of one specific audience. \n\nEffective localization requires multiple factors, including:\n\n\n### Translations\nJust like globalization, one of the most important factors of localization is the language and translations you are using. For example, do you know the difference between localisation and localization? The former is how people in the United Kingdom would spell it, while the latter is how people across the Atlantic would. \n\nWhile this might seem like a minor difference, it is these small nuances that can transform a customer’s perception of your brand. Of course, when it comes to translation, sometimes a literal interpretation might not always make sense. That is why you need to ensure that when converting content into a new language, you make sure the meaning remains the same. \n\n\n### Utilize the right formats \nAnother important aspect of localization is ensuring that you are using the right format for things such as:\n-\tDate and time\n-\tMeasurements\n-\tCurrency\n-\tTelephone number formats\n-\tKeyboard formats\n-\tPunctuations and symbols\n\n\n### Consider the design \nThe design and style are also a very important part of the localization process. This requires ensuring that the visuals match with the requirements of your target audience. This includes everything from the photography and layout of the site to the colors and tone of the writing. \n\nMore detailled information wanted, read this article about <a href=\"/blog/localization/\" title=\"what is localization\">what is localization</a>.\n\n\n## Globalization versus localization, what comes first?\nWhen it comes to understanding what is meant by globalization versus localization, you should now have a clearer idea of what both terms mean. However, which one should you focus on first? While both options can help you to create a more inclusive and engaging piece of content, no matter whether it is a website, manual, or marketing material. \n\nDeciding which stage to focus on first will depend on who your target audience is. If you are solely looking to focus on one specific region, then opting just for localization can be the better option. However, typically, globalization is the first process to undertake as this will give you a clear and strong base to work from when you begin the localization process.  \n\n\nWhen it comes to looking at the differences between the two, there are three key factors to remember:\n\n1 - <b>Localization is the process of focusing on a specific culture, location, or audience</b>. Globalization is the process of looking at multiple cultures, locations, or audiences. \n\n2 - <b>Localization is a part of the wider globalization process</b>, whereas globalization forms part of your overall business strategy. \n\n3 - <b>Globalization is often part of a larger long-term business <a href=\"https://en.wikipedia.org/wiki/Global_strategy\" title=\"strategy\">strategy</a></b>, while localization is often used for more short-term actions.\n\n\n## The pros and cons of globalization versus localization \nBoth the globalization or <a href=\"/blog/localization-strategy\" title=\"localization strategy\">localization strategy</a> can be a complex process, but they are an essential part of any customer service strategy for your business. Both options are able to provide companies with a wide range of benefits, but they do also have some drawbacks. \n\n\n\n### Pros and cons of globalization \nGlobalization is able to provide businesses with a wide range of benefits, helping them to reach a far greater audience. Not only can this help to increase revenue by expanding your customer base, but it is also able to significantly enhance your overall brand reputation and global image. This, in turn, can help to decrease dependence on a single market, ensuring your business is more resilient in the face of economic challenges.\n\nHowever, globalization can be a very time-consuming process and does require additional resources alongside the many challenges of expanding a business.\n\n### Pros and cons of localization \nIf you are looking to enter specific new markets, then localization is essential in helping to facilitate this. It can help to create significant brand loyalty from customers, improving their overall experience with your company. By building loyal customers, you will be able to increase revenue and secure a more competitive advantage in that market.\n\nOf course, just like globalization, localization does require significant investment in terms of time and resources. If not done correctly, it can also have a negative impact on your brand image, so it is always recommended you work with a professional partner who can help you.\n\n\n## So which is right for you?\nWhen it comes to globalization versus localization, both strategies can help you to transform your business. While they might sound like two completely different methods, globalization and localization can work in tandem to help you successfully branch out into new markets and increase your revenue.\n\nKnowing which option will be right for you will depend on the overall strategy and the audience you are looking to reach. Whichever you choose, partnering with a professional translation and localization team from a <a href=\"/\" title=\"translation management platform\">translation management platform</a>  will help ensure that it is completed to the highest standards alongside reducing the time and resource investment that you need to make.\n\n## Further to read (examples)\nIf you want to read about real-world i18n localization examples from our client cases, check out our recent blog post on  <a href=\"../website-localization/\" title=\"website localization\">website localization</a>.\n\nRead more about how software is affected from globalization and localization and what potential localization of software has in the <a href=\"../what-is-software-localization/\" title=\"what is software localization\">\"what is software localization\"</a> blog post.\n","categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"globalization","slug":"globalization","permalink":"https://locize.com/blog/tags/globalization/"},{"name":"g11n","slug":"g11n","permalink":"https://locize.com/blog/tags/g11n/"}]},{"title":"These are the website internationalization best practices","slug":"website-internationalization-best-practices","date":"un11fin11","updated":"un00fin00","comments":true,"path":"website-internationalization-best-practices/","link":"","permalink":"https://locize.com/blog/website-internationalization-best-practices/","excerpt":"","text":"When it comes to internationalizing your website, this article should assist you in determining your best practices. This could be as a result of a strategic shift or if you want to start an international company or project this is for you. The process when your web app becomes international should not be a difficult task. Another article about website localization shows you the process of planning, and if you read further in this article we try to help you to avoid any mistake. If you&#39;re not sure what internatationalization is, check out our guide what is i18n. Make website internationalization easy with these couple of best practices: Best practices summary Use as little text as possible in your pictures Separate code from translating Consider different ways of pluralizing words Check to see if the layout can support longer or shorter text Make it easy to find strings Set character encoding to UTF-8 Consider the also the colors Choose the right localization translation service Best practices in detail1. Use as little text as possible in your pictures Because you will end up uploading several images for the same piece or web content, as it has to be translated during the localization process. If you don&#39;t have any text in your image, there&#39;s no need to modify anything when it comes to localizing your website. Another possibility is to separate the text from the image. You may create a layer that will be placed on top of the image. Alternatively, make picture files easily accessible. Sometimes even if there is no legible text you may want to adapt the art asset (i.e. an image) because of cultural reasons. There are some libraries that can help with this issue i.e. Fragment replacement for links and images. 2. Separate code from translating It seems logical to keep the code separate from the translation process. During the project, the developer may work freely without being interrupted by any colleagues. This way, you won&#39;t lose sight of the project and guarantee that no mistakes occur. This way you gather new content automatically and smoothly, posting it for translation, getting translations, and integrating them back into the product. A good localization management solution can really help here. All team members can collaboratively work in parallel. In this way, you can get to your objective in a faster way. When using locize as a localization management platform, this feature will be offered. 3. Consider different ways of pluralizing words Various languages have different grammatical rules for dealing with plural nouns and units. Ensure to offer a separate translation for each plural form in the language when localizing formatted strings that include variable quantities. In Polish, for example, imagine you have a singular and then a plural depending on whether the number of objects ends with 2, 3, 4, or any other digit. And each collection of things more than 20 requires a separate plural in Romanian. Locize recognizes and accurately estimates your progress in the various languages by taking into account the various pluralization laws. 4. Check to see if the layout can support longer or shorter text The fact is that translations can take longer than the original text and will break the layout. So check in advance that your translation approach can support different sizes of translations. Particularly in Europe, where various languages might have many more terms for the same statement. In this blog post, you will find a comparison of European languages with a table showing a very nice overview &quot;how the languages are different&quot;. You may use the locize review workflow to guarantee that changes to translations are accepted before they are published. Until one of the translation proposals is approved, the real value will remain unchanged. 5. Make it easy to find strings Strings should definitly not be directly in the code. Make it simple for developers to externalize their strings and include them in resource files from the beginning. This implies that any hard-coded string will appear in their original language, regardless of the user&#39;s language. You will never face such problems again if you use a translation management software such as locize. With the integrated search feature, translators may discover any string in seconds. 6. Set character encoding to UTF-8 Select an encoding that is compatible with all target languages. If you are unsure, simply select UTF-8. If you&#39;re wondering why UTF-8 is the greatest encoding, read on this FAQ about UTF-8. To distinguish assets meant for a certain region, utilize ISO 693-1 &amp; 3166-1 language and country codes to mark assets by locale. 7. Consider the also the colors In terms of user experience, the culture of your target consumer may make a significant difference. When creating your web design, consider which markets you want to target. You want to leave a favorable impression on your target clients, not something that will remind them of a terrible incident, political issue, or something similar. As a result, make it simple for your website to swap colors based on target country or region. 8. Choose the right localization translation service When choosing a localization translation service, there are two major topics: one that focuses on professional and long-term software localization, and the other that focuses on a rapid and transparent translation work. Topic 1: Use locize as localization platformThere are numerous ways to use locize for your localization-translation-service, such as managing all of your translations during a specific project such as a website, app, or video game. Planing and managing your localization project cuntinuously translating, while your project&#39;s development team adds new features. Allow in-house translators to manage translation without interfering with the development process. You may request a translation from a third party using the locize interface. Overall, locize is a very versatile solution for your company&#39;s or software&#39;s localization needs. Topic 2: Use a translation service providerBeside having the possibility to directly use a translation service provider from withing locize, you can use it also for sophisticated papers, product brochures, as well as for financial, legal, and technological topics. ConclusionIf you follow the best practices, you may create a seamless procedure and save money in the long run. In general, it is advisable to get assistance from an adviser who has extensive experience. Please do not hesitate to contact us if you have any questions. We&#39;re offering a free 14-day trial, so you may have a nice opportunity to try all features anyhow. Register today for a free trial period and begin your finest experience. You are a developerSo here you can find more information about how to integrate locize, like for javascript localization. There are also some dedicated articles about react localization.","raw":"---\ntitle: These are the website internationalization best practices\ndescription: What are the best practices for website internationalization?\n\ndate: 2021-08-16\ntags:\n  - website internationalization\n  - best practices\n  - web app translation\nthumbnail: website-internationalization-best-practices/website-internationalization-best-practices.webp\n\nlabel: website-internationalization-best-practices\nlang: en\n---\n\n![website internationalization best practices](website-internationalization-best-practices.webp \"website internationalization best practices\")\n\n\nWhen it comes to internationalizing your website, this article should assist you in determining your best practices. \n\nThis could be as a result of a strategic shift or if you want to start an international company or project this is for you. The process when your web app becomes international should not be a difficult task. \n\nAnother article about <a href=\"/blog/website-localization/\" title=\"website localization\">website localization</a> shows you the process of planning, and if you read further in this article we try to help you to avoid any mistake. If you're not sure what internatationalization is, check out our guide <a href=\"/blog/what-is-i18n/\" title=\"what is i18n\">what is i18n</a>. Make **website internationalization** easy with these couple of **best practices**:\n\n## Best practices summary\n  1. [Use as little text as possible in your pictures](#little-text)\n  2. [Separate code from translating](#separate)\n  3. [Consider different ways of pluralizing words](#plural)\n  4. [Check to see if the layout can support longer or shorter text](#layout)\n  5. [Make it easy to find strings](#find)\n  6. [Set character encoding to UTF-8](#encoding)\n  7. [Consider the also the colors](#colors)\n  8. [Choose the right localization translation service](#service)\n\n\n## Best practices in detail\n\n### 1. Use as little text as possible in your pictures <a name=\"little-text\"></a>\nBecause you will end up uploading several images for the same piece or web content, as it has to be translated during the localization process. If you don't have any text in your image, there's no need to modify anything when it comes to localizing your website. Another possibility is to separate the text from the image. You may create a layer that will be placed on top of the image. Alternatively, make picture files easily accessible.\nSometimes even if there is no legible text you may want to adapt the art asset (i.e. an image) because of cultural reasons. There are some libraries that can help with this issue i.e. [Fragment replacement for links and images](https://github.com/i18next/i18nextify#fragment-replacement-for-links-and-images).\n\n### 2. Separate code from translating <a name=\"separate\"></a>\nIt seems logical to keep the code separate from the translation process. During the project, the developer may work freely without being interrupted by any colleagues. This way, you won't lose sight of the project and guarantee that no mistakes occur. This way you gather new content automatically and smoothly, posting it for translation, getting translations, and integrating them back into the product.\nA good localization management solution can really help here. All team members can collaboratively work in parallel. In this way, you can get to your objective in a faster way.\nWhen using locize as a <a href=\"https://locize.com/\" title=\"localization management platform\">localization management platform</a>, this feature will be offered.\n\n### 3. Consider different ways of pluralizing words <a name=\"plural\"></a>\nVarious languages have different grammatical rules for dealing with plural nouns and units. Ensure to offer a separate translation for each plural form in the language when localizing formatted strings that include variable quantities. In Polish, for example, imagine you have a singular and then a plural depending on whether the number of objects ends with 2, 3, 4, or any other digit. And each collection of things more than 20 requires a separate plural in Romanian. Locize recognizes and accurately estimates your progress in the various languages by taking into account the various pluralization laws.\n\n![plurals](locize_plurals.webp \"plurals\")\n\n### 4. Check to see if the layout can support longer or shorter text <a name=\"layout\"></a>\nThe fact is that translations can take longer than the original text and will break the layout. So check in advance that your translation approach can support different sizes of translations. Particularly in Europe, where various languages might have many more terms for the same statement. In this <a href=\"https://www.inter-contact.de/en/blog/text-length-languages?dt=1629440931092\" title=\"blog post\">blog post</a>, you will find a comparison of European languages with a table showing a very nice overview \"how the languages are different\". You may use the <a href=\"https://docs.locize.com/whats-inside/review-workflow\" title=\"locize review workflow\">locize review workflow</a> to guarantee that changes to translations are accepted before they are published. Until one of the translation proposals is approved, the real value will remain unchanged.\n\n### 5. Make it easy to find strings <a name=\"find\"></a>\nStrings should definitly not be directly in the code. Make it simple for developers to externalize their strings and include them in resource files from the beginning. This implies that any hard-coded string will appear in their original language, regardless of the user's language. You will never face such problems again if you use a translation management software such as locize. With the integrated search feature, translators may discover any string in seconds.\n\n### 6. Set character encoding to UTF-8 <a name=\"encoding\"></a>\nSelect an encoding that is compatible with all target languages. If you are unsure, simply select UTF-8. If you're wondering [why UTF-8 is the greatest encoding](../is-your-software-ready-for-localization/#encoding), read on this <a href=\"https://www.w3.org/International/questions/qa-choosing-encodings.en\" title=\"FAQ about UTF-8\">FAQ about UTF-8</a>. To distinguish assets meant for a certain region, utilize ISO 693-1 & 3166-1 language and country codes to mark assets by locale.\n\n### 7. Consider the also the colors <a name=\"colors\"></a>\nIn terms of user experience, the culture of your target consumer may make a significant difference. When creating your web design, consider which markets you want to target. You want to leave a favorable impression on your target clients, not something that will remind them of a terrible incident, political issue, or something similar. As a result, make it simple for your website to swap colors based on target country or region.\n\n### 8. Choose the right localization translation service <a name=\"service\"></a>\nWhen choosing a <a href=\"https://locize.com/services.html\" title=\"localization translation service\">localization translation service</a>, there are two major topics: one that focuses on professional and long-term software localization, and the other that focuses on a rapid and transparent translation work.\n\n##### Topic 1: Use locize as <a href=\"https://locize.com\" title=\"localization platform\">localization platform</a>\nThere are numerous ways to use locize for your localization-translation-service, such as managing all of your translations during a specific project such as a website, app, or video game. Planing and managing your localization project cuntinuously translating, while your project's development team adds new features. Allow [in-house translators to manage translation](https://docs.locize.com/guides-tips-and-tricks/working-with-translators) without interfering with the development process. You may request a translation from a [third party](/services.html#translationservices) using the locize interface. Overall, locize is a very versatile solution for your company's or software's localization needs.\n\n##### Topic 2: Use a <a href=\"/services.html#translationservices\" title=\"translation marketplace\">translation service provider</a>\nBeside having the possibility to directly use a translation service provider from withing locize, you can use it also for sophisticated papers, product brochures, as well as for financial, legal, and technological topics.\n\n## Conclusion\nIf you follow the best practices, you may create a seamless procedure and save money in the long run. In general, it is advisable to get assistance from an adviser who has extensive experience. Please do not hesitate to [contact us](mailto:support@locize.com) if you have any questions. \nWe're offering a free 14-day trial, so you may have a nice opportunity to try all features anyhow. <a href=\"https://www.locize.app/register\" title=\"Register today\">Register today</a> for a free trial period and begin your finest experience. \n\n### You are a developer\nSo [here](https://docs.locize.com/integration/instrumenting-your-code) you can find more information about how to integrate locize, like for <a href=\"https://locize.com/javascript-localization.html\" title=\"javascript localization\">javascript localization</a>. There are also some dedicated articles about <a href=\"../react-i18next/\" title=\"react localization\">react localization</a>.\n","categories":[],"tags":[{"name":"website internationalization","slug":"website-internationalization","permalink":"https://locize.com/blog/tags/website-internationalization/"},{"name":"best practices","slug":"best-practices","permalink":"https://locize.com/blog/tags/best-practices/"},{"name":"web app translation","slug":"web-app-translation","permalink":"https://locize.com/blog/tags/web-app-translation/"}]},{"title":"How does server side internationalization (i18n) look like?","slug":"how-does-server-side-internationalization-look-like","date":"un11fin11","updated":"un33fin33","comments":true,"path":"how-does-server-side-internationalization-look-like/","link":"","permalink":"https://locize.com/blog/how-does-server-side-internationalization-look-like/","excerpt":"","text":"You may already know how to properly internationalize a client side application, like described in this React based tutorial, this Angular based tutorial or this Vue based tutorial. In this blog post we will shed light on the server side. Why do I need to handle i18n in my application&#39;s backend? Think of all user faced content not directly rendered in your browser... For example you&#39;re building a command line interface (CLI)? You&#39;re sending some emails? Or you&#39;re using server side rendering (SSR)? etc. Let&#39;s check that out...We will show some examples that uses i18next as i18n framework. If you&#39;re curious to know why we suggest i18next, have a look at this page. Command line interface (CLI) Let&#39;s start with something simple: a verry small CLI app. For this example let&#39;s use commander, originally created by TJ Holowaychuk. We are defining a sayhi command with optional language and name parameters that should respond with a salutation in the appropriate language. 12345678910111213141516171819202122232425262728#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;)program .command(&#x27;sayhi&#x27;) .alias(&#x27;s&#x27;) .option(&#x27;-l, --language &lt;lng&gt;&#x27;, &#x27;by default the system language is used&#x27;) .option(&#x27;-n, --name &lt;name&gt;&#x27;, &#x27;your name&#x27;) .action((options) =&gt; &#123; // options.language =&gt; optional language // options.name =&gt; optional name // TODO: log the salutation to the console... &#125;) .on(&#x27;--help&#x27;, () =&gt; &#123; console.log(&#x27; Examples:&#x27;) console.log() console.log(&#x27; $ mycli sayhi&#x27;) console.log(&#x27; $ mycli sayhi --language de&#x27;) console.log(&#x27; $ mycli sayhi --language de --name John&#x27;) console.log() &#125;)program.parse(process.argv)if (!process.argv.slice(2).length) &#123; program.outputHelp()&#125; Ok, now let&#39;s create a new i18n.js file and setup i18next accordingly: 12345678910111213141516171819const i18next = require(&#x27;i18next&#x27;)// if no language parameter is passed, let&#x27;s try to use the node.js system&#x27;s localeconst systemLocale = Intl.DateTimeFormat().resolvedOptions().localei18next .init(&#123; fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: require(&#x27;./locales/en/translation.json&#x27;) &#125;, de: &#123; translation: require(&#x27;./locales/de/translation.json&#x27;) &#125; &#125; &#125;)module.exports = (lng) =&gt; i18next.getFixedT(lng || systemLocale) And also our translation resources: 1234567891011// locales/en/translations.json&#123; &quot;salutation&quot;: &quot;Hello World!&quot;, &quot;salutationWithName&quot;: &quot;Hello &#123;&#123;name&#125;&#125;!&quot;&#125;// locales/de/translations.json&#123; &quot;salutation&quot;: &quot;Hallo Welt!&quot;, &quot;salutationWithName&quot;: &quot;Hallo &#123;&#123;name&#125;&#125;!&quot;&#125; Now we can use the i18n.js export like that: 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const i18n = require(&#x27;../i18n.js&#x27;)program .command(&#x27;sayhi&#x27;) .alias(&#x27;s&#x27;) .option(&#x27;-l, --language &lt;lng&gt;&#x27;, &#x27;by default the system language is used&#x27;) .option(&#x27;-n, --name &lt;name&gt;&#x27;, &#x27;your name&#x27;) .action((options) =&gt; &#123; const t = i18n(options.language) if (options.name) &#123; console.log(t(&#x27;salutationWithName&#x27;, &#123; name: options.name &#125;)) &#125; else &#123; console.log(t(&#x27;salutation&#x27;)) &#125; &#125;) .on(&#x27;--help&#x27;, () =&gt; &#123; console.log(&#x27; Examples:&#x27;) console.log() console.log(&#x27; $ mycli sayhi&#x27;) console.log(&#x27; $ mycli sayhi --language de&#x27;) console.log(&#x27; $ mycli sayhi --language de --name John&#x27;) console.log() &#125;)program.parse(process.argv)if (!process.argv.slice(2).length) &#123; program.outputHelp()&#125; Ok, what&#39;s the result? 1234567891011## if we execute the cli command without any parameters...mycli sayhi## result: Hello World!## if we execute the cli command with a language parameter...mycli sayhi --language de## result: Hallo Welt!## if we execute the cli command with a language parameter and a name parameter...mycli sayhi --language de --name John## result: Hallo John! Easy, isn&#39;t it? If you don&#39;t bundle your CLI app in a single executable, for example by using pkg, you can also i.e. use the i18next-fs-backend to dynamically load your translations, for example like this: 12345678910111213141516171819202122232425const i18next = require(&#x27;i18next&#x27;)const Backend = require(&#x27;i18next-fs-backend&#x27;)const &#123; join &#125; = require(&#x27;path&#x27;)const &#123; readdirSync, lstatSync &#125; = require(&#x27;fs&#x27;)// if no language parameter is passed, let&#x27;s try to use the node.js system&#x27;s localeconst systemLocale = Intl.DateTimeFormat().resolvedOptions().localeconst localesFolder = join(__dirname, &#x27;./locales&#x27;)i18next .use(Backend) .init(&#123; initImmediate: false, // setting initImediate to false, will load the resources synchronously fallbackLng: &#x27;en&#x27;, preload: readdirSync(localesFolder).filter((fileName) =&gt; &#123; const joinedPath = join(localesFolder, fileName) return lstatSync(joinedPath).isDirectory() &#125;), backend: &#123; loadPath: join(localesFolder, &#x27;&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125; &#125;)module.exports = (lng) =&gt; i18next.getFixedT(lng || systemLocale) 🧑‍💻 A code example can be found here. A possible next step...A possible next step could be to professionalize the translation management. This means the translations would be &quot;managed&quot; (add new languages, new translations etc...) in a translation management system (TMS), like locize and synchronized with your code. To see how this could look like, check out Step 1 in this tutorial. Generate Emails Another typical server side use case that requires internationalization is the generation of emails. To achieve this goal, you usually need to transform some raw data to html content (or text) to be shown in the user&#39;s preferred language. In this example we will use pug (formerly known as &quot;Jade&quot;, and also originally created by TJ Holowaychuk) to define some templates that should be filled with the data needed in the email, and mjml to actually design the email content. Let&#39;s create a new mail.js file, which we can use, to accomplish this. 1234567891011121314import pug from &#x27;pug&#x27;import mjml2html from &#x27;mjml&#x27;export default (data) =&gt; &#123; // first let&#x27;s compile and render the mail template that will include the data needed to show in the mail content const mjml = pug.renderFile(&#x27;./mailTemplate.pug&#x27;, data) // then transform the mjml syntax to normal html const &#123; html, errors &#125; = mjml2html(mjml) if (errors &amp;&amp; errors.length &gt; 0) throw new Error(errors[0].message) // and return the html, if there where no errors return html&#125; The mailTemplate.pug could look like this: 123456789101112131415161718192021mjml mj-body(background-color=&#x27;#F4F4F4&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27;) mj-section(background-color=&#x27;#024b3f&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-image(align=&#x27;center&#x27; padding=&#x27;10px 25px&#x27; src=&#x27;https://raw.githubusercontent.com/i18next/i18next/master/assets/i18next-ecosystem.jpg&#x27;) mj-section(background-color=&#x27;#ffffff&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-section(background-color=&#x27;#ffffff&#x27; background-repeat=&#x27;repeat&#x27; background-size=&#x27;auto&#x27; padding=&#x27;20px 0px 20px 0px&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-text(align=&#x27;center&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;20px&#x27; line-height=&#x27;28px&#x27; padding=&#x27;0px 25px 0px 25px&#x27;) span=t(&#x27;greeting&#x27;, &#123; name: name || &#x27;there&#x27; &#125;) br br mj-text(align=&#x27;center&#x27; color=&#x27;#55575d&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;16px&#x27; line-height=&#x27;28px&#x27; padding=&#x27;0px 25px 0px 25px&#x27;) =t(&#x27;text&#x27;) mj-section(background-color=&#x27;#024b3f&#x27; background-repeat=&#x27;repeat&#x27; padding=&#x27;20px 0&#x27; text-align=&#x27;center&#x27; vertical-align=&#x27;top&#x27;) mj-column mj-text(align=&#x27;center&#x27; color=&#x27;#ffffff&#x27; font-family=&#x27;Arial, sans-serif&#x27; font-size=&#x27;13px&#x27; line-height=&#x27;22px&#x27; padding=&#x27;10px 25px&#x27;) =t(&#x27;ending&#x27;)&amp;nbsp; a(style=&#x27;color:#ffffff&#x27; href=&#x27;https://www.i18next.com&#x27;) b www.i18next.com Now let&#39;s define some translations... 12345678910111213// locales/en/translations.json&#123; &quot;greeting&quot;: &quot;Hi &#123;&#123;name&#125;&#125;!&quot;, &quot;text&quot;: &quot;You were invited to try i18next.&quot;, &quot;ending&quot;: &quot;Internationalized with&quot;&#125;// locales/de/translations.json&#123; &quot;greeting&quot;: &quot;Hallo &#123;&#123;name&#125;&#125;!&quot;, &quot;text&quot;: &quot;Du bist eingeladen worden i18next auszuprobieren.&quot;, &quot;ending&quot;: &quot;Internationalisiert mit&quot;&#125; ...and use them in an i18n.js file: 12345678910111213141516171819202122232425import &#123; dirname, join &#125; from &#x27;path&#x27;import &#123; readdirSync, lstatSync &#125; from &#x27;fs&#x27;import &#123; fileURLToPath &#125; from &#x27;url&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-fs-backend&#x27;const __dirname = dirname(fileURLToPath(import.meta.url))const localesFolder = join(__dirname, &#x27;./locales&#x27;)i18next .use(Backend) // you can also use any other i18next backend, like i18next-http-backend or i18next-locize-backend .init(&#123; // debug: true, initImmediate: false, // setting initImediate to false, will load the resources synchronously fallbackLng: &#x27;en&#x27;, preload: readdirSync(localesFolder).filter((fileName) =&gt; &#123; const joinedPath = join(localesFolder, fileName) return lstatSync(joinedPath).isDirectory() &#125;), backend: &#123; loadPath: join(localesFolder, &#x27;&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125; &#125;)export default i18next So finally, all the above can be used like that: 123456789import mail from &#x27;./mail.js&#x27;import i18next from &#x27;./i18n.js&#x27;const html = mail(&#123; t: i18next.t, name: &#x27;John&#x27;&#125;)// that html now can be sent via some mail provider... This is how the resulting html could look like: 🧑‍💻 A code example can be found here. Server Side Rendering (SSR) We will try 2 different SSR examples, a classic one using Fastify with pug and a more trendy one using Next.js. Fastify with Pug example For this example we will use my favorite http framework Fastify (created by Matteo Collina and Tomas Della Vedova), but any other framework will also work. This time we will use a different i18next module, i18next-http-middleware. It can be used for all Node.js web frameworks, like express or Fastify, but also for Deno web frameworks, like abc or ServestJS. As already said, here we will use Fastify, my favorite 😉. Let&#39;s again start with the i18n.js file: 1234567891011121314151617181920212223242526import &#123; dirname, join &#125; from &#x27;path&#x27;import &#123; readdirSync, lstatSync &#125; from &#x27;fs&#x27;import &#123; fileURLToPath &#125; from &#x27;url&#x27;import i18next from &#x27;i18next&#x27;import Backend from &#x27;i18next-fs-backend&#x27;import i18nextMiddleware from &#x27;i18next-http-middleware&#x27;const __dirname = dirname(fileURLToPath(import.meta.url))const localesFolder = join(__dirname, &#x27;../locales&#x27;)i18next .use(i18nextMiddleware.LanguageDetector) // the language detector, will automatically detect the users language, by some criteria... like the query parameter ?lng=en or http header, etc... .use(Backend) // you can also use any other i18next backend, like i18next-http-backend or i18next-locize-backend .init(&#123; initImmediate: false, // setting initImediate to false, will load the resources synchronously fallbackLng: &#x27;en&#x27;, preload: readdirSync(localesFolder).filter((fileName) =&gt; &#123; const joinedPath = join(localesFolder, fileName) return lstatSync(joinedPath).isDirectory() &#125;), backend: &#123; loadPath: join(localesFolder, &#x27;&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;) &#125; &#125;)export &#123; i18next, i18nextPlugin: i18nextMiddleware.plugin &#125; And our translation resources... 1234567891011121314151617181920212223242526272829// locales/en/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Hello World!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Server is listening on port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125;// locales/de/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Hallo Welt!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Der server lauscht auf dem Port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125;// locales/it/translations.json&#123; &quot;home&quot;: &#123; &quot;title&quot;: &quot;Ciao Mondo!&quot; &#125;, &quot;server&quot;: &#123; &quot;started&quot;: &quot;Il server sta aspettando sul port &#123;&#123;port&#125;&#125;.&quot; &#125;&#125; A simple pug template: 1234567891011html head title i18next - fastify with pug body h1=t(&#x27;home.title&#x27;) div a(href=&quot;/?lng=en&quot;) english | &amp;nbsp; | &amp;nbsp; a(href=&quot;/?lng=it&quot;) italiano | &amp;nbsp; | &amp;nbsp; a(href=&quot;/?lng=de&quot;) deutsch Our &quot;main&quot; file app.js: 1234567891011121314151617181920212223242526import fastify from &#x27;fastify&#x27;import pov from &#x27;point-of-view&#x27;import pug from &#x27;pug&#x27;import &#123; i18next, i18nextPlugin &#125; from &#x27;./lib/i18n.js&#x27;const port = process.env.PORT || 8080const app = fastify()app.register(pov, &#123; engine: &#123; pug &#125; &#125;)app.register(i18nextPlugin, &#123; i18next &#125;)app.get(&#x27;/raw&#x27;, (request, reply) =&gt; &#123; reply.send(request.t(&#x27;home.title&#x27;))&#125;)app.get(&#x27;/&#x27;, (request, reply) =&gt; &#123; reply.view(&#x27;/views/index.pug&#x27;)&#125;)app.listen(port, (err) =&gt; &#123; if (err) return console.error(err) // if you like you can also internationalize your log statements ;-) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port &#125;)) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;de&#x27; &#125;)) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;it&#x27; &#125;))&#125;) Now start the app and check what language you&#39;re seeing... If you check the console output you&#39;ll also see something like this: 1234node app.js## Server is listening on port 8080.## Der server lauscht auf dem Port 8080.## Il server sta aspettando sul port 8080. Yes, if you like, you can also internationalize your log statements 😁 🧑‍💻 A code example can be found here. A possible next step...Do you wish to manage your translations in a translation management system (TMS), like locize? Just use this cli to synchronize the translations with your code. To see how this could look like check out Step 1 in this tutorial. Alternatively, use i18next-locize-backend instead of the i18next-fs-backend. If you&#39;re running your code in a serverless environment, make sure you read this advice first! btw: Did you know, you can easily adapt your Fastify app to be used in AWS Lambda AND locally. This can be achieved with the help of aws-lambda-fastify. Just create a new lambda.js that imports your modified app.js file: 1234// lambda.jsimport awsLambdaFastify from &#x27;aws-lambda-fastify&#x27;import app from &#x27;./app.js&#x27;export const handler = awsLambdaFastify(app) make sure your Fastify app is exported... (export default app) And only start to listen on a port, if not executed in AWS Lambda (import.meta.url === &#39;file://$&#123;process.argv[1]&#125;&#39; or require.main === module for CommonJS) 123456789101112131415161718192021222324252627282930313233// app.jsimport fastify from &#x27;fastify&#x27;import pov from &#x27;point-of-view&#x27;import pug from &#x27;pug&#x27;import &#123; i18next, i18nextPlugin &#125; from &#x27;./lib/i18n.js&#x27;const port = process.env.PORT || 8080const app = fastify()app.register(pov, &#123; engine: &#123; pug &#125; &#125;)app.register(i18nextPlugin, &#123; i18next &#125;)app.get(&#x27;/raw&#x27;, (request, reply) =&gt; &#123; reply.send(request.t(&#x27;home.title&#x27;))&#125;)app.get(&#x27;/&#x27;, (request, reply) =&gt; &#123; reply.view(&#x27;/views/index.pug&#x27;)&#125;)if (import.meta.url === `file://$&#123;process.argv[1]&#125;`) &#123; // called directly (node app.js) app.listen(port, (err) =&gt; &#123; if (err) return console.error(err) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port &#125;)) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;de&#x27; &#125;)) console.log(i18next.t(&#x27;server.started&#x27;, &#123; port, lng: &#x27;it&#x27; &#125;)) &#125;)&#125; else &#123; // imported as a module, i.e. when executed in AWS Lambda&#125;export default app 😎 Cool, right? Next.js example Now it&#39;s time for Next.js... When it comes to internationalization of Next.js apps one of the most popular choices is next-i18next. It is based on react-i18next and users of next-i18next by default simply need to include their translation content as JSON files and don&#39;t have to worry about much else. Here you&#39;ll find a simple example. You just need a next-i18next.config.js file that provides the configuration for next-i18next and wrapping your app with the appWithTranslation function, which allows to use the t (translate) function in your components via hooks. 123456// _app.jsimport &#123; appWithTranslation &#125; from &#x27;next-i18next&#x27;const MyApp = (&#123; Component, pageProps &#125;) =&gt; &lt;Component &#123;...pageProps&#125; /&gt;export default appWithTranslation(MyApp) 123456789101112131415161718192021222324252627// index.jsimport &#123; useTranslation &#125; from &#x27;next-i18next&#x27;import &#123; serverSideTranslations &#125; from &#x27;next-i18next/serverSideTranslations&#x27;// This is an async function that you need to include on your page-level components, via either getStaticProps or getServerSideProps (depending on your use case)const Homepage = () =&gt; &#123; const &#123; t &#125; = useTranslation(&#x27;common&#x27;) return ( &lt;&gt; &lt;main&gt; &lt;p&gt; &#123;t(&#x27;description&#x27;)&#125; &lt;/p&gt; &lt;/main&gt; &lt;/&gt; )&#125;export const getStaticProps = async (&#123; locale &#125;) =&gt; (&#123; props: &#123; ...await serverSideTranslations(locale, [&#x27;common&#x27;]), // Will be passed to the page component as props &#125;,&#125;)export default Homepage By default, next-i18next expects your translations to be organized as such: 1234567.└── public └── locales ├── en | └── common.json └── de └── common.json A demo of how such an app looks like when it is deployed, can be found here. This looks really simple, right? Manage the translations outside of the codeTo best manage the translations there are 3 different approaches: POSSIBILITY 1: live translation downloadWhen using locize, you can configure your next-i18next project to load the translations from the CDN (on server and client side). Such a configuration could look like this: 12345678910111213141516171819// next-i18next.config.jsmodule.exports = &#123; i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;], &#125;, backend: &#123; projectId: &#x27;d3b405cf-2532-46ae-adb8-99e88d876733&#x27;, // apiKey: &#x27;myApiKey&#x27;, // to not add the api-key in production, used for saveMissing feature referenceLng: &#x27;en&#x27; &#125;, use: [ require(&#x27;i18next-locize-backend/cjs&#x27;) ], ns: [&#x27;common&#x27;, &#x27;footer&#x27;, &#x27;second-page&#x27;], // the namespaces needs to be listed here, to make sure they got preloaded serializeConfig: false, // because of the custom use i18next plugin // debug: true, // saveMissing: true, // to not saveMissing to true for production&#125; Here you&#39;ll find more information and an example on how this looks like. There is also the possibility to cache the translations locally thanks to i18next-chained-backend. Here you can find more information about this option. If you&#39;re deploying your Next.js app in a serverless environment, consider to use the second possibility... More information about the reason for this can be found here. POSSIBILITY 2: bundle translations and keep in syncIf you&#39;re not sure, choose this way. This option will not change the configuration of your &quot;normal&quot; next-i18next project: 1234567// next-i18next.config.jsmodule.exports = &#123; i18n: &#123; defaultLocale: &#x27;en&#x27;, locales: [&#x27;en&#x27;, &#x27;de&#x27;], &#125;&#125; Just download or sync your local translations before &quot;deploying&quot; your app. Here you&#39;ll find more information and an example on how this looks like. You can, for example, run an npm script (or similar), which will use the cli to download the translations from locize into the appropriate folder next-i18next is looking in to (i.e. ./public/locales). This way the translations are bundled in your app and you will not generate any CDN downloads during runtime. i.e. locize download --project-id=d3b405cf-2532-46ae-adb8-99e88d876733 --ver=latest --clean=true --path=./public/locales Best approach: optimized for server and client side Here you&#39;ll find a blog post on how to best use next-i18next with client side translation download and SEO optimization. There&#39;s also an i18next crash course video. 🎉🥳 Conclusion 🎊🎁As you see i18n is also important on server side. I hope you’ve learned a few new things about server side internationalization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try i18next and also locize. 👍 { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"What is i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\" } },{ \"@type\": \"Question\", \"name\": \"What is server side internationalization (i18n)?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Server side internationalization is the process of adapting your application's backend to support multiple languages. This ensures that all user-facing content, including emails, command line interfaces (CLIs), server-side rendered sites, etc. are translated into the user's preferred language.\" } },{ \"@type\": \"Question\", \"name\": \"Why is it important to handle i18n in the backend?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"It's important to handle i18n in the backend because some user-facing content is not directly rendered in the browser, such as emails and CLIs. Without proper internationalization in the backend, this content will not be translated into the user's preferred language.\" } },{ \"@type\": \"Question\", \"name\": \"What is the example i18n framework used in the text?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"The example i18n framework used in the text is i18next.\" } },{ \"@type\": \"Question\", \"name\": \"Can you use i18next for CLI apps?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, you can use i18next for CLI apps. The text provides an example of how to use i18next to translate a small CLI app that greets the user in the appropriate language.\" } },{ \"@type\": \"Question\", \"name\": \"Can you use i18next for email generation?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, you can use i18next for email generation. The text provides an example of how to use i18next to translate the raw data into HTML content in the user's preferred language to be used in an email.\" } }] }","raw":"---\ntitle: How does server side internationalization (i18n) look like?\ndescription: How does server side internationalization (i18n) look like? CLI, webserver, mail generation, server side rendered sites, Next.js, etc...\n\ndate: 2021-06-28 08:23:00\ntags:\n  - server\n  - serverside\n  - backend\n  - cli\n  - mail\n  - i18n\n  - i18next\n  - internationalization\n  - translation\n  - next\n  - react\nthumbnail: how-does-server-side-internationalization-look-like/server_side_backend.jpg\n\nlabel: how-does-server-side-internationalization-look-like\nlang: en\n---\n\n![server side internationalization next](server_side_backend.jpg \"Server Side Internationalization\")\n\nYou may already know how to properly internationalize a client side application, like described in this [React based tutorial](../react-i18next/), this [Angular based tutorial](../angular-i18next/) or this [Vue based tutorial](../give-vue-i18n-more-superpowers/).\n\nIn this blog post we will shed light on the server side.\n\n> Why do I need to handle i18n in my application's backend?\n\nThink of all user faced content not directly rendered in your browser...\n\n- For example you're building a [command line interface (CLI)](#cli)?\n- You're [sending some emails](#email)?\n- Or you're using [server side rendering (SSR)](#ssr)?\n- etc.\n\n## Let's check that out...\n\nWe will show some examples that uses [i18next](https://www.i18next.com) as i18n framework. If you're curious to know why we suggest i18next, have a look at [this page](https://locize.com/i18next.html).\n\n\n## Command line interface (CLI) <a name=\"cli\"></a>\n\nLet's start with something simple: a verry small CLI app. For this example let's use [commander](https://github.com/tj/commander.js), originally created by [TJ Holowaychuk](https://twitter.com/tjholowaychuk).\nWe are defining a `sayhi` command with optional language and name parameters that should respond with a salutation in the appropriate language.\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander')\n\nprogram\n  .command('sayhi')\n  .alias('s')\n  .option('-l, --language <lng>', 'by default the system language is used')\n  .option('-n, --name <name>', 'your name')\n  .action((options) => {\n    // options.language => optional language\n    // options.name => optional name\n    // TODO: log the salutation to the console...\n  })\n  .on('--help', () => {\n    console.log('  Examples:')\n    console.log()\n    console.log('    $ mycli sayhi')\n    console.log('    $ mycli sayhi --language de')\n    console.log('    $ mycli sayhi --language de --name John')\n    console.log()\n  })\n\nprogram.parse(process.argv)\n\nif (!process.argv.slice(2).length) {\n  program.outputHelp()\n}\n```\n\nOk, now let's create a new `i18n.js` file and setup i18next accordingly:\n\n```javascript\nconst i18next = require('i18next')\n\n// if no language parameter is passed, let's try to use the node.js system's locale\nconst systemLocale = Intl.DateTimeFormat().resolvedOptions().locale\n\ni18next\n  .init({\n    fallbackLng: 'en',\n    resources: {\n      en: {\n        translation: require('./locales/en/translation.json')\n      },\n      de: {\n        translation: require('./locales/de/translation.json')\n      }\n    }\n  })\n\nmodule.exports = (lng) => i18next.getFixedT(lng || systemLocale)\n```\n\nAnd also our translation resources:\n\n```javascript\n// locales/en/translations.json\n{\n  \"salutation\": \"Hello World!\",\n  \"salutationWithName\": \"Hello {{name}}!\"\n}\n\n// locales/de/translations.json\n{\n  \"salutation\": \"Hallo Welt!\",\n  \"salutationWithName\": \"Hallo {{name}}!\"\n}\n```\n\nNow we can use the `i18n.js` export like that:\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander')\nconst i18n = require('../i18n.js')\n\nprogram\n  .command('sayhi')\n  .alias('s')\n  .option('-l, --language <lng>', 'by default the system language is used')\n  .option('-n, --name <name>', 'your name')\n  .action((options) => {\n    const t = i18n(options.language)\n    if (options.name) {\n      console.log(t('salutationWithName', { name: options.name }))\n    } else {\n      console.log(t('salutation'))\n    }\n  })\n  .on('--help', () => {\n    console.log('  Examples:')\n    console.log()\n    console.log('    $ mycli sayhi')\n    console.log('    $ mycli sayhi --language de')\n    console.log('    $ mycli sayhi --language de --name John')\n    console.log()\n  })\n\nprogram.parse(process.argv)\n\nif (!process.argv.slice(2).length) {\n  program.outputHelp()\n}\n```\n\nOk, what's the result?\n\n```sh\n## if we execute the cli command without any parameters...\nmycli sayhi\n## result: Hello World!\n\n## if we execute the cli command with a language parameter...\nmycli sayhi --language de\n## result: Hallo Welt!\n\n## if we execute the cli command with a language parameter and a name parameter...\nmycli sayhi --language de --name John\n## result: Hallo John!\n```\n\n**Easy, isn't it?**\n\nIf you don't bundle your CLI app in a single executable, for example by using [pkg](https://github.com/vercel/pkg), you can also i.e. use the [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend) to dynamically load your translations, for example like this:\n\n```javascript\nconst i18next = require('i18next')\nconst Backend = require('i18next-fs-backend')\nconst { join } = require('path')\nconst { readdirSync, lstatSync } = require('fs')\n\n// if no language parameter is passed, let's try to use the node.js system's locale\nconst systemLocale = Intl.DateTimeFormat().resolvedOptions().locale\n\nconst localesFolder = join(__dirname, './locales')\n\ni18next\n  .use(Backend)\n  .init({\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    fallbackLng: 'en',\n    preload: readdirSync(localesFolder).filter((fileName) => {\n      const joinedPath = join(localesFolder, fileName)\n      return lstatSync(joinedPath).isDirectory()\n    }),\n    backend: {\n      loadPath: join(localesFolder, '{{lng}}/{{ns}}.json')\n    }\n  })\n\nmodule.exports = (lng) => i18next.getFixedT(lng || systemLocale)\n```\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-cli-app-example).*\n\n### A possible next step...\n\nA possible next step could be to professionalize the translation management.\nThis means the translations would be \"managed\" (add new languages, new translations etc...) in a translation management system (TMS), like [locize](https://www.locize.com) and synchronized with your code. To see how this could look like, check out [**Step 1** in this tutorial](https://github.com/locize/react-tutorial#step-1---keep-existing-code-setup-but-synchronize-with-locize).\n\n\n## Generate Emails <a name=\"email\"></a>\n\nAnother typical server side use case that requires internationalization is the generation of emails.\n\nTo achieve this goal, you usually need to transform some raw data to html content (or text) to be shown in the user's preferred language.\n\nIn this example we will use [pug](https://pugjs.org) (formerly known as \"Jade\", and also originally created by [TJ Holowaychuk](https://twitter.com/tjholowaychuk)) to define some templates that should be filled with the data needed in the email, and [mjml](https://mjml.io) to actually design the email content.\n\nLet's create a new `mail.js` file, which we can use, to accomplish this.\n\n```javascript\nimport pug from 'pug'\nimport mjml2html from 'mjml'\n\nexport default (data) => {\n  // first let's compile and render the mail template that will include the data needed to show in the mail content\n  const mjml = pug.renderFile('./mailTemplate.pug', data)\n  \n  // then transform the mjml syntax to normal html\n  const { html, errors } = mjml2html(mjml)\n  if (errors && errors.length > 0) throw new Error(errors[0].message)\n\n  // and return the html, if there where no errors\n  return html\n}\n```\n\nThe `mailTemplate.pug` could look like this:\n\n```jade\nmjml\n  mj-body(background-color='#F4F4F4' color='#55575d' font-family='Arial, sans-serif')\n    mj-section(background-color='#024b3f' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n        mj-image(align='center' padding='10px 25px' src='https://raw.githubusercontent.com/i18next/i18next/master/assets/i18next-ecosystem.jpg')\n    mj-section(background-color='#ffffff' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n    mj-section(background-color='#ffffff' background-repeat='repeat' background-size='auto' padding='20px 0px 20px 0px' text-align='center' vertical-align='top')\n      mj-column\n        mj-text(align='center' color='#55575d' font-family='Arial, sans-serif' font-size='20px' line-height='28px' padding='0px 25px 0px 25px')\n          span=t('greeting', { name: name || 'there' })\n          br\n          br\n        mj-text(align='center' color='#55575d' font-family='Arial, sans-serif' font-size='16px' line-height='28px' padding='0px 25px 0px 25px')\n          =t('text')\n    mj-section(background-color='#024b3f' background-repeat='repeat' padding='20px 0' text-align='center' vertical-align='top')\n      mj-column\n        mj-text(align='center' color='#ffffff' font-family='Arial, sans-serif' font-size='13px' line-height='22px' padding='10px 25px')\n          =t('ending')&nbsp;\n          a(style='color:#ffffff' href='https://www.i18next.com')\n            b www.i18next.com\n```\n\nNow let's define some translations...\n\n```javascript\n// locales/en/translations.json\n{\n  \"greeting\": \"Hi {{name}}!\",\n  \"text\": \"You were invited to try i18next.\",\n  \"ending\": \"Internationalized with\"\n}\n\n// locales/de/translations.json\n{\n  \"greeting\": \"Hallo {{name}}!\",\n  \"text\": \"Du bist eingeladen worden i18next auszuprobieren.\",\n  \"ending\": \"Internationalisiert mit\"\n}\n```\n\n...and use them in an `i18n.js` file:\n\n```javascript\nimport { dirname, join } from 'path'\nimport { readdirSync, lstatSync } from 'fs'\nimport { fileURLToPath } from 'url'\nimport i18next from 'i18next'\nimport Backend from 'i18next-fs-backend'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst localesFolder = join(__dirname, './locales')\n\ni18next\n  .use(Backend) // you can also use any other i18next backend, like i18next-http-backend or i18next-locize-backend\n  .init({\n    // debug: true,\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    fallbackLng: 'en',\n    preload: readdirSync(localesFolder).filter((fileName) => {\n      const joinedPath = join(localesFolder, fileName)\n      return lstatSync(joinedPath).isDirectory()\n    }),\n    backend: {\n      loadPath: join(localesFolder, '{{lng}}/{{ns}}.json')\n    }\n  })\n\nexport default i18next\n```\n\nSo finally, all the above can be used like that:\n\n```javascript\nimport mail from './mail.js'\n\nimport i18next from './i18n.js'\n\nconst html = mail({\n  t: i18next.t,\n  name: 'John'\n})\n// that html now can be sent via some mail provider...\n```\n\nThis is how the resulting html could look like:\n\n![mail preview](mail_preview.jpg)\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-fs-backend/blob/master/example/fastify/app.js#L14-L19).*\n\n\n## Server Side Rendering (SSR) <a name=\"ssr\"></a>\n\nWe will try 2 different SSR examples, a classic one using [Fastify with pug](#pug) and a more trendy one using [Next.js](#nextjs).\n\n### Fastify with Pug example <a name=\"pug\"></a>\n\nFor this example we will use my favorite http framework [Fastify](https://www.fastify.io) (created by [Matteo Collina](https://twitter.com/matteocollina) and [Tomas Della Vedova](https://twitter.com/delvedor)), but any other framework will also work.\n\nThis time we will use a different i18next module, [i18next-http-middleware](https://github.com/i18next/i18next-http-middleware).\nIt can be used for all Node.js web frameworks, like [express](https://expressjs.com) or [Fastify](https://www.fastify.io), but also for [Deno](../i18n-for-deno-with-i18next) web frameworks, like [abc](https://github.com/zhmushan/abc) or [ServestJS](https://github.com/keroxp/servest).\n\nAs already said, here we will use [Fastify](https://www.fastify.io), my favorite 😉.\n\nLet's again start with the `i18n.js` file:\n\n```javascript\nimport { dirname, join } from 'path'\nimport { readdirSync, lstatSync } from 'fs'\nimport { fileURLToPath } from 'url'\nimport i18next from 'i18next'\nimport Backend from 'i18next-fs-backend'\nimport i18nextMiddleware from 'i18next-http-middleware'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst localesFolder = join(__dirname, '../locales')\n\ni18next\n  .use(i18nextMiddleware.LanguageDetector) // the language detector, will automatically detect the users language, by some criteria... like the query parameter ?lng=en or http header, etc...\n  .use(Backend) // you can also use any other i18next backend, like i18next-http-backend or i18next-locize-backend\n  .init({\n    initImmediate: false, // setting initImediate to false, will load the resources synchronously\n    fallbackLng: 'en',\n    preload: readdirSync(localesFolder).filter((fileName) => {\n      const joinedPath = join(localesFolder, fileName)\n      return lstatSync(joinedPath).isDirectory()\n    }),\n    backend: {\n      loadPath: join(localesFolder, '{{lng}}/{{ns}}.json')\n    }\n  })\n\nexport { i18next, i18nextPlugin: i18nextMiddleware.plugin }\n```\n\nAnd our translation resources...\n\n```javascript\n// locales/en/translations.json\n{\n  \"home\": {\n    \"title\": \"Hello World!\"\n  },\n  \"server\": {\n    \"started\": \"Server is listening on port {{port}}.\"\n  }\n}\n\n// locales/de/translations.json\n{\n  \"home\": {\n    \"title\": \"Hallo Welt!\"\n  },\n  \"server\": {\n    \"started\": \"Der server lauscht auf dem Port {{port}}.\"\n  }\n}\n\n// locales/it/translations.json\n{\n  \"home\": {\n    \"title\": \"Ciao Mondo!\"\n  },\n  \"server\": {\n    \"started\": \"Il server sta aspettando sul port {{port}}.\"\n  }\n}\n```\n\nA simple pug template:\n\n```jade\nhtml\n  head\n    title i18next - fastify with pug\n  body\n    h1=t('home.title')\n    div\n      a(href=\"/?lng=en\") english\n      | &nbsp; | &nbsp;\n      a(href=\"/?lng=it\") italiano\n      | &nbsp; | &nbsp;\n      a(href=\"/?lng=de\") deutsch\n```\n\nOur \"main\" file `app.js`:\n\n```javascript\nimport fastify from 'fastify'\nimport pov from 'point-of-view'\nimport pug from 'pug'\nimport { i18next, i18nextPlugin } from './lib/i18n.js'\n\nconst port = process.env.PORT || 8080\n\nconst app = fastify()\napp.register(pov, { engine: { pug } })\napp.register(i18nextPlugin, { i18next })\n\napp.get('/raw', (request, reply) => {\n  reply.send(request.t('home.title'))\n})\n\napp.get('/', (request, reply) => {\n  reply.view('/views/index.pug')\n})\n\napp.listen(port, (err) => {\n  if (err) return console.error(err)\n  // if you like you can also internationalize your log statements ;-)\n  console.log(i18next.t('server.started', { port }))\n  console.log(i18next.t('server.started', { port, lng: 'de' }))\n  console.log(i18next.t('server.started', { port, lng: 'it' }))\n})\n```\n\nNow start the app and check what language you're seeing...\n![pug fastify](pug_fastify.jpg)\n\nIf you check the console output you'll also see something like this:\n\n```sh\nnode app.js\n## Server is listening on port 8080.\n## Der server lauscht auf dem Port 8080.\n## Il server sta aspettando sul port 8080.\n```\n\n*Yes, if you like, you can also internationalize your log statements 😁*\n\n*🧑‍💻 A code example can be found [here](https://github.com/i18next/i18next-fs-backend/tree/master/example/fastify).*\n\n#### A possible next step...\n\nDo you wish to manage your translations in a translation management system (TMS), like [locize](https://www.locize.com)?\n\nJust use [this cli](https://github.com/locize/locize-cli) to synchronize the translations with your code. To see how this could look like check out [**Step 1** in this tutorial](https://github.com/locize/react-tutorial#step-1---keep-existing-code-setup-but-synchronize-with-locize).\n\nAlternatively, use [i18next-locize-backend](https://github.com/locize/i18next-locize-backend) instead of the [i18next-fs-backend](https://github.com/i18next/i18next-fs-backend).\nIf you're running your code in a serverless environment, make sure you [read this advice first](https://github.com/locize/i18next-locize-backend#important-advice-for-serverless-environments---aws-lambda-google-cloud-functions-azure-functions-etc)!\n\n**btw: Did you know, you can easily adapt your Fastify app to be used in [AWS Lambda](https://aws.amazon.com/lambda/) AND locally.**\n\nThis can be achieved with the help of [aws-lambda-fastify](https://github.com/fastify/aws-lambda-fastify).\nJust create a new `lambda.js` that imports your modified `app.js` file:\n\n```javascript\n// lambda.js\nimport awsLambdaFastify from 'aws-lambda-fastify'\nimport app from './app.js'\nexport const handler = awsLambdaFastify(app)\n```\n\nmake sure your Fastify app is exported... (`export default app`)\nAnd only start to listen on a port, if not executed in AWS Lambda (`import.meta.url === 'file://${process.argv[1]}'` or `require.main === module` for CommonJS)\n\n```javascript\n// app.js\nimport fastify from 'fastify'\nimport pov from 'point-of-view'\nimport pug from 'pug'\nimport { i18next, i18nextPlugin } from './lib/i18n.js'\n\nconst port = process.env.PORT || 8080\n\nconst app = fastify()\napp.register(pov, { engine: { pug } })\napp.register(i18nextPlugin, { i18next })\n\napp.get('/raw', (request, reply) => {\n  reply.send(request.t('home.title'))\n})\n\napp.get('/', (request, reply) => {\n  reply.view('/views/index.pug')\n})\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  // called directly (node app.js)\n  app.listen(port, (err) => {\n    if (err) return console.error(err)\n    console.log(i18next.t('server.started', { port }))\n    console.log(i18next.t('server.started', { port, lng: 'de' }))\n    console.log(i18next.t('server.started', { port, lng: 'it' }))\n  })\n} else {\n  // imported as a module, i.e. when executed in AWS Lambda\n}\n\nexport default app\n```\n\n**😎 Cool, right?**\n\n\n### Next.js example <a name=\"nextjs\"></a>\n\nNow it's time for [Next.js](https://nextjs.org)...\n\nWhen it comes to internationalization of Next.js apps one of the most popular choices is [next-i18next](https://github.com/i18next/next-i18next). It is based on [react-i18next](https://react.i18next.com) and users of [next-i18next](https://github.com/i18next/next-i18next) by default simply need to include their translation content as JSON files and don't have to worry about much else.\n\n[Here](https://github.com/i18next/next-i18next/tree/master/examples/simple) you'll find a simple example.\n\nYou just need a `next-i18next.config.js` file that provides the configuration for `next-i18next` and wrapping your app with the `appWithTranslation` function, which allows to use the `t` (translate) function in your components via hooks.\n\n```javascript\n// _app.js\nimport { appWithTranslation } from 'next-i18next'\n\nconst MyApp = ({ Component, pageProps }) => <Component {...pageProps} />\n\nexport default appWithTranslation(MyApp)\n```\n\n```javascript\n// index.js\nimport { useTranslation } from 'next-i18next'\nimport { serverSideTranslations } from 'next-i18next/serverSideTranslations'\n// This is an async function that you need to include on your page-level components, via either getStaticProps or getServerSideProps (depending on your use case)\n\nconst Homepage = () => {\n  const { t } = useTranslation('common')\n\n  return (\n    <>\n      <main>\n        <p>\n          {t('description')}\n        </p>\n      </main>\n    </>\n  )\n}\n\nexport const getStaticProps = async ({ locale }) => ({\n  props: {\n    ...await serverSideTranslations(locale, ['common']),\n    // Will be passed to the page component as props\n  },\n})\n\nexport default Homepage\n```\n\nBy default, `next-i18next` expects your translations to be organized as such:\n\n```\n.\n└── public\n    └── locales\n        ├── en\n        |   └── common.json\n        └── de\n            └── common.json\n```\n\nA demo of how such an app looks like when it is deployed, can be found [here](https://next.i18next.com).\n\n[![next i18next demo](next-i18next_demo.jpg)](https://next.i18next.com)\n\n**This looks really simple, right?**\n\n### Manage the translations outside of the code\n\nTo best manage the translations there are 3 different approaches:\n\n### POSSIBILITY 1: live translation download\n\nWhen using [locize](https://www.locize.com), you can configure your next-i18next project to load the translations from the [CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network) (on server and client side).\n\nSuch a configuration could look like this:\n\n```javascript\n// next-i18next.config.js\nmodule.exports = {\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de'],\n  },\n  backend: {\n    projectId: 'd3b405cf-2532-46ae-adb8-99e88d876733',\n    // apiKey: 'myApiKey', // to not add the api-key in production, used for saveMissing feature\n    referenceLng: 'en'\n  },\n  use: [\n    require('i18next-locize-backend/cjs')\n  ],\n  ns: ['common', 'footer', 'second-page'], // the namespaces needs to be listed here, to make sure they got preloaded\n  serializeConfig: false, // because of the custom use i18next plugin\n  // debug: true,\n  // saveMissing: true, // to not saveMissing to true for production\n}\n```\n\n[Here](https://github.com/locize/next-i18next-locize#possibility-2-config-for-locize-live-download-usage) you'll find more information and an example on how this looks like.\n\nThere is also the possibility to cache the translations locally thanks to [i18next-chained-backend](https://github.com/i18next/i18next-chained-backend). [Here](https://github.com/locize/next-i18next-locize#optional-server-side-caching-to-filesystem) you can find more information about this option.\n\n*If you're deploying your Next.js app in a serverless environment, consider to use the second possibility...*\n*More information about the reason for this can be found [here](https://github.com/locize/i18next-locize-backend#important-advice-for-serverless-environments---aws-lambda-google-cloud-functions-azure-functions-etc).*\n\n\n### POSSIBILITY 2: bundle translations and keep in sync\n\n**If you're not sure, choose this way.**\n\nThis option will not change the configuration of your \"normal\" next-i18next project:\n\n```javascript\n// next-i18next.config.js\nmodule.exports = {\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'de'],\n  }\n}\n```\n\nJust download or sync your local translations before \"deploying\" your app.\n\n[Here](https://github.com/locize/next-i18next-locize#possibility-2-bundle-translations-with-app) you'll find more information and an example on how this looks like.\n\nYou can, for example, run an [npm script](https://github.com/locize/next-i18next-locize/blob/main/package.json#L6) (or similar), which will use the [cli](https://github.com/locize/locize-cli) to download the translations from locize into the appropriate folder next-i18next is looking in to (i.e. `./public/locales`). This way the translations are bundled in your app and you will not generate any CDN downloads during runtime.\n\ni.e. `locize download --project-id=d3b405cf-2532-46ae-adb8-99e88d876733 --ver=latest --clean=true --path=./public/locales`\n\n#### Best approach: optimized for server and client side\n\n[![next-i18next](../next-i18next/next-i18next.jpg)](../next-i18next/)\n[Here](../next-i18next/) you'll find a blog post on how to best use next-i18next with client side translation download and SEO optimization.\n\n---\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Conclusion 🎊🎁\n\nAs you see i18n is also important on server side.\n\nI hope you’ve learned a few new things about server side internationalization and modern localization workflows.\n\nSo if you want to take your i18n topic to the next level, it's worth to try [i18next](https://www.i18next.com) and also [locize](https://www.locize.com).\n\n👍\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is server side internationalization (i18n)?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Server side internationalization is the process of adapting your application's backend to support multiple languages. This ensures that all user-facing content, including emails, command line interfaces (CLIs), server-side rendered sites, etc. are translated into the user's preferred language.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Why is it important to handle i18n in the backend?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"It's important to handle i18n in the backend because some user-facing content is not directly rendered in the browser, such as emails and CLIs. Without proper internationalization in the backend, this content will not be translated into the user's preferred language.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is the example i18n framework used in the text?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"The example i18n framework used in the text is i18next.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Can you use i18next for CLI apps?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, you can use i18next for CLI apps. The text provides an example of how to use i18next to translate a small CLI app that greets the user in the appropriate language.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Can you use i18next for email generation?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, you can use i18next for email generation. The text provides an example of how to use i18next to translate the raw data into HTML content in the user's preferred language to be used in an email.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"backend","slug":"backend","permalink":"https://locize.com/blog/tags/backend/"},{"name":"server","slug":"server","permalink":"https://locize.com/blog/tags/server/"},{"name":"serverside","slug":"serverside","permalink":"https://locize.com/blog/tags/serverside/"},{"name":"cli","slug":"cli","permalink":"https://locize.com/blog/tags/cli/"},{"name":"mail","slug":"mail","permalink":"https://locize.com/blog/tags/mail/"},{"name":"next","slug":"next","permalink":"https://locize.com/blog/tags/next/"}]},{"title":"Angular Localization - Unleash the full power of i18next","slug":"angular-i18next","date":"un11fin11","updated":"un66fin66","comments":true,"path":"angular-i18next/","link":"","permalink":"https://locize.com/blog/angular-i18next/","excerpt":"","text":"Let&#39;s talk about internationalization (i18n) for Angular (not AngularJS, not Angular 2, just Angular 😉). When it comes to JavaScript localization, one of the most popular frameworks is i18next. One of the most famous Angular extension for i18next is angular-i18next. It was created back in April 2017 by Sergey Romanchuk. TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher Separate translations from code How does this look like? save missing translations 👀 but there&#39;s more... 🎉🥳 Congratulations 🎊🎁 So first of all: &quot;Why i18next?&quot; i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it... Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic Angular, before jumping to angular-i18next. Getting started Take your own Angular project or create a new one, i.e. with the Angular cli. npx @angular/cli new my-app To simplify let&#39;s remove the &quot;generated&quot; content of the angular-cli: We are going to adapt the app to detect the language according to the user’s preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: i18next angular-i18next i18next-browser-languagedetector npm install i18next angular-i18next i18next-browser-languagedetector Let&#39;s modify our app.module.ts to integrate and initialize the i18next config: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import &#123; APP_INITIALIZER, NgModule, LOCALE_ID &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat &#125; from &#x27;angular-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;const i18nextOptions = &#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; &quot;welcome&quot;: &quot;Welcome to Your Angular App&quot; &#125; &#125;, de: &#123; translation: &#123; &quot;welcome&quot;: &quot;Willkommen zu Deiner Vue.js App&quot; &#125; &#125; &#125;, interpolation: &#123; format: I18NextModule.interpolationFormat(defaultInterpolationFormat) &#125;&#125;;export function appInit(i18next: ITranslationService) &#123; return () =&gt; &#123; let promise: Promise&lt;I18NextLoadResult&gt; = i18next .use(LocizeApi) .use&lt;any&gt;(LanguageDetector) .init(i18nextOptions); return promise; &#125;;&#125;export function localeIdFactory(i18next: ITranslationService) &#123; return i18next.language;&#125;export const I18N_PROVIDERS = [ &#123; provide: APP_INITIALIZER, useFactory: appInit, deps: [I18NEXT_SERVICE], multi: true &#125;, &#123; provide: LOCALE_ID, deps: [I18NEXT_SERVICE], useFactory: localeIdFactory &#125;,];@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, I18NextModule.forRoot() ], providers: [ I18N_PROVIDERS ], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; Ok, now let&#39;s update the app.component.html: 123456789101112&lt;!-- Toolbar --&gt;&lt;div class=&quot;toolbar&quot; role=&quot;banner&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;welcome&#x27; | i18next &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;content&quot; role=&quot;main&quot;&gt; &lt;!-- Highlight Card --&gt; &lt;div class=&quot;card highlight-card card-small&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;welcome&#x27; | i18next &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; You should now see something like this: Nice! So let&#39;s add an additional text, with an interpolated unescaped value: 123456789101112131415&lt;!-- Toolbar --&gt;&lt;div class=&quot;toolbar&quot; role=&quot;banner&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;welcome&#x27; | i18next &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;content&quot; role=&quot;main&quot;&gt; &lt;!-- Highlight Card --&gt; &lt;div class=&quot;card highlight-card card-small&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;welcome&#x27; | i18next &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;br /&gt; &lt;p&gt;&#123;&#123; &#x27;descr&#x27; | i18next: &#123; url: &#x27;https://github.com/Romanchuk/angular-i18next&#x27; &#125; &#125;&#125;&lt;/p&gt;&lt;/div&gt; Do not forget to add the new key also to the resources: 123456789101112131415161718192021const i18nextOptions = &#123; debug: true, fallbackLng: &#x27;en&#x27;, resources: &#123; en: &#123; translation: &#123; &quot;welcome&quot;: &quot;Welcome to Your Angular App&quot;, &quot;descr&quot;: &quot;For a guide and recipes on how to configure / customize this project, check out &#123;&#123;-url&#125;&#125;.&quot; &#125; &#125;, de: &#123; translation: &#123; &quot;welcome&quot;: &quot;Willkommen zu Deiner Vue.js App&quot;, &quot;descr&quot;: &quot;Eine Anleitung und Rezepte für das Konfigurieren / Anpassen dieses Projekts findest du in &#123;&#123;-url&#125;&#125;.&quot; &#125; &#125; &#125;, interpolation: &#123; format: I18NextModule.interpolationFormat(defaultInterpolationFormat) &#125;&#125;; Does it work? - Of course! And thanks to the language-detector, you can also try to switch the language with the query parameter ?lng=de: Language Switcher We like to offer the possibility to change the language via some sort of language switcher. So let&#39;s add a footer section in our app.component.html file: 12345678&lt;!-- Footer --&gt;&lt;footer&gt; &lt;ng-template ngFor let-lang [ngForOf]=&quot;languages&quot; let-i=&quot;index&quot;&gt; &lt;span *ngIf=&quot;i !== 0&quot;&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt; &lt;a *ngIf=&quot;language !== lang&quot; href=&quot;javascript:void(0)&quot; class=&quot;link lang-item &#123;&#123;lang&#125;&#125;&quot; (click)=&quot;changeLanguage(lang)&quot;&gt;&#123;&#123; lang.toUpperCase() &#125;&#125;&lt;/a&gt; &lt;span *ngIf=&quot;language === lang&quot; class=&quot;current lang-item &#123;&#123;lang&#125;&#125;&quot;&gt;&#123;&#123; lang.toUpperCase() &#125;&#125;&lt;/span&gt; &lt;/ng-template&gt;&lt;/footer&gt; And we need also to update the app.components.ts file: 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Component, Inject &#125; from &#x27;@angular/core&#x27;;import &#123; I18NEXT_SERVICE, ITranslationService &#125; from &#x27;angular-i18next&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.less&#x27;]&#125;)export class AppComponent &#123; language: string = &#x27;en&#x27;; languages: string[] = [&#x27;en&#x27;, &#x27;de&#x27;]; constructor( @Inject(I18NEXT_SERVICE) private i18NextService: ITranslationService ) &#123;&#125; ngOnInit() &#123; this.i18NextService.events.initialized.subscribe((e) =&gt; &#123; if (e) &#123; this.updateState(this.i18NextService.language); &#125; &#125;); &#125; changeLanguage(lang: string)&#123; if (lang !== this.i18NextService.language) &#123; this.i18NextService.changeLanguage(lang).then(x =&gt; &#123; this.updateState(lang); document.location.reload(); &#125;); &#125; &#125; private updateState(lang: string) &#123; this.language = lang; &#125;&#125; 🥳 Awesome, you&#39;ve just created your first language switcher! Thanks to i18next-browser-languagedetector now it tries to detect the browser language and automatically use that language if you&#39;ve provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language. Separate translations from code Having the translations in our code works, but is not that suitable to work with, for translators. Let&#39;s separate the translations from the code and pleace them in dedicated json files. i18next-locize-backend will help us to do so. What is locize? How does this look like? First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by importing the individual json files or via API or by using the CLI. npm install i18next-locize-backend Adapt the app.modules.ts file to use the i18next-locize-backend and make sure you copy the project-id from within your locize project: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123; APP_INITIALIZER, NgModule, LOCALE_ID &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat &#125; from &#x27;angular-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import LocizeApi from &#x27;i18next-locize-backend&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;const i18nextOptions = &#123; debug: true, fallbackLng: &#x27;en&#x27;, backend: &#123; projectId: &#x27;your-locize-project-id&#x27; &#125;, interpolation: &#123; format: I18NextModule.interpolationFormat(defaultInterpolationFormat) &#125;&#125;;export function appInit(i18next: ITranslationService) &#123; return () =&gt; &#123; let promise: Promise&lt;I18NextLoadResult&gt; = i18next .use(LocizeApi) .use&lt;any&gt;(LanguageDetector) .init(i18nextOptions); return promise; &#125;;&#125;export function localeIdFactory(i18next: ITranslationService) &#123; return i18next.language;&#125;export const I18N_PROVIDERS = [ &#123; provide: APP_INITIALIZER, useFactory: appInit, deps: [I18NEXT_SERVICE], multi: true &#125;, &#123; provide: LOCALE_ID, deps: [I18NEXT_SERVICE], useFactory: localeIdFactory &#125;,];@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, I18NextModule.forRoot() ], providers: [ I18N_PROVIDERS ], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; The app looks still the same, but the translations are now completely separated from the app and can be managed and released separately. save missing translations Thanks to the use of the saveMissing functionality, new keys gets added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options and make sure you copy the api-key from within your locize project: 123456789101112const i18nextOptions = &#123; debug: true, saveMissing: true, // do not use the saveMissing functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production fallbackLng: &#x27;en&#x27;, backend: &#123; projectId: &#x27;my-locize-project-id&#x27;, apiKey: &#x27;my-api-key&#x27; // used for handleMissing functionality, do not add your api-key in a production build &#125;, interpolation: &#123; format: I18NextModule.interpolationFormat(defaultInterpolationFormat) &#125;&#125;; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;p&gt;&#123;&#123; &#x27;cool&#x27; | i18next: &#123; defaultValue: &#x27;This is very cool!&#x27; &#125; &#125;&#125;&lt;/p&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation: npm install locize-lastused locize use them in app.modules.ts: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import &#123; APP_INITIALIZER, NgModule, LOCALE_ID &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat &#125; from &#x27;angular-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import LocizeApi from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;const locizeOptions = &#123; projectId: &#x27;my-locize-project-id&#x27;, apiKey: &#x27;my-api-key&#x27; // used for handleMissing functionality, do not add your api-key in a production buildyour&#125;;const i18nextOptions = &#123; debug: true, fallbackLng: &#x27;en&#x27;, saveMissing: true, // do not use the saveMissing functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production backend: locizeOptions, locizeLastUsed: locizeOptions, interpolation: &#123; format: I18NextModule.interpolationFormat(defaultInterpolationFormat) &#125;&#125;;export function appInit(i18next: ITranslationService) &#123; return () =&gt; &#123; let promise: Promise&lt;I18NextLoadResult&gt; = i18next // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused // do not use the lastused functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production .use(LastUsed) // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(LocizeApi) .use&lt;any&gt;(LanguageDetector) .init(i18nextOptions); return promise; &#125;;&#125;export function localeIdFactory(i18next: ITranslationService) &#123; return i18next.language;&#125;export const I18N_PROVIDERS = [ &#123; provide: APP_INITIALIZER, useFactory: appInit, deps: [I18NEXT_SERVICE], multi: true &#125;, &#123; provide: LOCALE_ID, deps: [I18NEXT_SERVICE], useFactory: localeIdFactory &#125;,];@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, I18NextModule.forRoot() ], providers: [ I18N_PROVIDERS ], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; Automatic machine translation: Last used translations filter: InContext Editor: Caching: Merging versions: 🧑‍💻 The complete code can be found here. There&#39;s also an i18next crash course video. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18next, angular-i18next and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍","raw":"---\ntitle: Angular Localization - Unleash the full power of i18next\ndescription: A step-by-step guide how to implement angular-i18next into your application.\n\ndate: 2021-06-14\ntags:\n  - i18next\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - translation\n  - angular\nthumbnail: angular-i18next/title.jpg\nredirect_from:\n- /unleash-the-full-power-of-angular-i18next\n\nlabel: angular-i18next\nlang: en\n---\n\n![angular localization](title.jpg \"locize © inweso GmbH\")\n\nLet's talk about internationalization (i18n) for Angular (not AngularJS, not Angular 2, just Angular 😉).\n\nWhen it comes to JavaScript localization, one of the most popular frameworks is [i18next](https://www.i18next.com). One of the most famous Angular extension for i18next is [angular-i18next](https://github.com/Romanchuk/angular-i18next/).\nIt was created back in April 2017 by [Sergey Romanchuk](https://github.com/Romanchuk).\n\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [Separate translations from code](#separate)\n      - [How does this look like?](#how-look)\n      - [save missing translations](#save-missing)\n      - [👀 but there's more...](#more)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology ([React](../react-i18next/), Angular, [Vue](../i18next-vue/), ...).*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic Angular, before jumping to [angular-i18next](https://github.com/Romanchuk/angular-i18next/).\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own Angular project or create a new one, i.e. with [the Angular cli](https://angular.io/guide/setup-local#install-the-angular-cli).\n\n`npx @angular/cli new my-app`\n\n*To simplify let's remove the \"generated\" content of the angular-cli:*\n![angular cli](app_0.jpg \"locize © inweso GmbH\")\n\nWe are going to adapt the app to detect the language according to the user’s preference.\nAnd we will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [i18next](https://www.i18next.com)\n- [angular-i18next](https://github.com/Romanchuk/angular-i18next/)\n- [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector)\n\n`npm install i18next angular-i18next i18next-browser-languagedetector`\n\n\nLet's modify our `app.module.ts` to integrate and initialize the i18next config:\n```javascript\nimport { APP_INITIALIZER, NgModule, LOCALE_ID } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat  } from 'angular-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\nimport { AppComponent } from './app.component';\n\nconst i18nextOptions = {\n  debug: true,\n  fallbackLng: 'en',\n  resources: {\n    en: {\n        translation: {\n            \"welcome\": \"Welcome to Your Angular App\"\n        }\n    },\n    de: {\n        translation: {\n            \"welcome\": \"Willkommen zu Deiner Vue.js App\"\n        }\n    }\n  },\n  interpolation: {\n    format: I18NextModule.interpolationFormat(defaultInterpolationFormat)\n  }\n};\n\nexport function appInit(i18next: ITranslationService) {\n  return () => {\n    let promise: Promise<I18NextLoadResult> = i18next\n      .use(LocizeApi)\n      .use<any>(LanguageDetector)\n      .init(i18nextOptions);\n    return promise;\n  };\n}\n\nexport function localeIdFactory(i18next: ITranslationService)  {\n  return i18next.language;\n}\n\nexport const I18N_PROVIDERS = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInit,\n    deps: [I18NEXT_SERVICE],\n    multi: true\n  },\n  {\n    provide: LOCALE_ID,\n    deps: [I18NEXT_SERVICE],\n    useFactory: localeIdFactory\n  },\n];\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    I18NextModule.forRoot()\n  ],\n  providers: [\n    I18N_PROVIDERS\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\nOk, now let's update the `app.component.html`:\n```html\n<!-- Toolbar -->\n<div class=\"toolbar\" role=\"banner\">\n  <span>{{ 'welcome' | i18next }}</span>\n</div>\n\n<div class=\"content\" role=\"main\">\n\n  <!-- Highlight Card -->\n  <div class=\"card highlight-card card-small\">\n    <span>{{ 'welcome' | i18next }}</span>\n  </div>\n</div>\n```\n\nYou should now see something like this:\n![app 1](app_1.jpg \"locize © inweso GmbH\")\n\n\nNice! So let's add an additional text, with an [interpolated unescaped](https://www.i18next.com/translation-function/interpolation#unescape) value:\n```html\n<!-- Toolbar -->\n<div class=\"toolbar\" role=\"banner\">\n  <span>{{ 'welcome' | i18next }}</span>\n</div>\n\n<div class=\"content\" role=\"main\">\n\n  <!-- Highlight Card -->\n  <div class=\"card highlight-card card-small\">\n    <span>{{ 'welcome' | i18next }}</span>\n  </div>\n\n  <br />\n  <p>{{ 'descr' | i18next: { url: 'https://github.com/Romanchuk/angular-i18next' } }}</p>\n</div>\n```\n\nDo not forget to add the new key also to the resources:\n```javascript\nconst i18nextOptions = {\n  debug: true,\n  fallbackLng: 'en',\n  resources: {\n    en: {\n        translation: {\n            \"welcome\": \"Welcome to Your Angular App\",\n            \"descr\": \"For a guide and recipes on how to configure / customize this project, check out {{-url}}.\"\n        }\n    },\n    de: {\n        translation: {\n            \"welcome\": \"Willkommen zu Deiner Vue.js App\",\n            \"descr\": \"Eine Anleitung und Rezepte für das Konfigurieren / Anpassen dieses Projekts findest du in {{-url}}.\"\n        }\n    }\n  },\n  interpolation: {\n    format: I18NextModule.interpolationFormat(defaultInterpolationFormat)\n  }\n};\n```\n\nDoes it work? - Of course!\n![app 2](app_2.jpg \"locize © inweso GmbH\")\n\n\nAnd thanks to the language-detector, you can also try to switch the language with the query parameter `?lng=de`:\n![language detector](app_3.jpg \"locize © inweso GmbH\")\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nWe like to offer the possibility to change the language via some sort of language switcher.\n\nSo let's add a footer section in our `app.component.html` file:\n```html\n<!-- Footer -->\n<footer>\n    <ng-template ngFor let-lang [ngForOf]=\"languages\" let-i=\"index\">\n        <span *ngIf=\"i !== 0\">&nbsp;|&nbsp;</span>\n        <a *ngIf=\"language !== lang\" href=\"javascript:void(0)\" class=\"link lang-item {{lang}}\" (click)=\"changeLanguage(lang)\">{{ lang.toUpperCase() }}</a>\n        <span *ngIf=\"language === lang\" class=\"current lang-item {{lang}}\">{{ lang.toUpperCase() }}</span>\n    </ng-template>\n</footer>\n```\n\nAnd we need also to update the `app.components.ts` file:\n```javascript\nimport { Component, Inject } from '@angular/core';\nimport { I18NEXT_SERVICE, ITranslationService } from 'angular-i18next';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.less']\n})\nexport class AppComponent {\n  language: string = 'en';\n  languages: string[] = ['en', 'de'];\n\n  constructor(\n    @Inject(I18NEXT_SERVICE) private i18NextService: ITranslationService\n  )\n  {}\n\n  ngOnInit() {\n    this.i18NextService.events.initialized.subscribe((e) => {\n      if (e) {\n        this.updateState(this.i18NextService.language);\n      }\n    });\n  }\n\n  changeLanguage(lang: string){\n    if (lang !== this.i18NextService.language) {\n      this.i18NextService.changeLanguage(lang).then(x => {\n        this.updateState(lang);\n        document.location.reload();\n      });\n    }\n  }\n\n  private updateState(lang: string) {\n    this.language = lang;\n  }\n}\n```\n\n![app 4](app_4.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\nThanks to [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) now it tries to detect the browser language and automatically use that language if you've provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language.\n\n\n### Separate translations from code <a name=\"separate\"></a>\n\nHaving the translations in our code works, but is not that suitable to work with, for translators.\nLet's separate the translations from the code and pleace them in dedicated json files.\n\n[i18next-locize-backend](https://github.com/locize/i18next-locize-backend) will help us to do so.\n\n> [What is locize?](../react-i18next/#for-sure)\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations) or by using the [CLI](https://github.com/locize/locize-cli).\n\n`npm install i18next-locize-backend`\n\nAdapt the `app.modules.ts` file to use the i18next-locize-backend and make sure you copy the project-id from within your locize project:\n\n```javascript\nimport { APP_INITIALIZER, NgModule, LOCALE_ID } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat  } from 'angular-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport LocizeApi from 'i18next-locize-backend';\n\nimport { AppComponent } from './app.component';\n\nconst i18nextOptions = {\n  debug: true,\n  fallbackLng: 'en',\n  backend: {\n    projectId: 'your-locize-project-id'\n  },\n  interpolation: {\n    format: I18NextModule.interpolationFormat(defaultInterpolationFormat)\n  }\n};\n\nexport function appInit(i18next: ITranslationService) {\n  return () => {\n    let promise: Promise<I18NextLoadResult> = i18next\n      .use(LocizeApi)\n      .use<any>(LanguageDetector)\n      .init(i18nextOptions);\n    return promise;\n  };\n}\n\nexport function localeIdFactory(i18next: ITranslationService)  {\n  return i18next.language;\n}\n\nexport const I18N_PROVIDERS = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInit,\n    deps: [I18NEXT_SERVICE],\n    multi: true\n  },\n  {\n    provide: LOCALE_ID,\n    deps: [I18NEXT_SERVICE],\n    useFactory: localeIdFactory\n  },\n];\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    I18NextModule.forRoot()\n  ],\n  providers: [\n    I18N_PROVIDERS\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\nThe app looks still the same, but the translations are now completely separated from the app and can be managed and released separately.\n![](app_4.jpg \"locize © inweso GmbH\")\n\n\n#### save missing translations <a name=\"save-missing\"></a>\n\nThanks to the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys gets added to locize automatically, while developing the app.\n\nJust pass `saveMissing: true` in the i18next options and make sure you copy the api-key from within your locize project:\n\n```javascript\nconst i18nextOptions = {\n  debug: true,\n  saveMissing: true, // do not use the saveMissing functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production\n  fallbackLng: 'en',\n  backend: {\n    projectId: 'my-locize-project-id',\n    apiKey: 'my-api-key' // used for handleMissing functionality, do not add your api-key in a production build\n  },\n  interpolation: {\n    format: I18NextModule.interpolationFormat(defaultInterpolationFormat)\n  }\n};\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<p>{{ 'cool' | i18next: { defaultValue: 'This is very cool!' } }}</p>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation:\n![locize autotranslate](locize_autotranslate.jpg \"locize © inweso GmbH\")\n\n`npm install locize-lastused locize`\n\nuse them in `app.modules.ts`:\n\n```javascript\nimport { APP_INITIALIZER, NgModule, LOCALE_ID } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { I18NEXT_SERVICE, I18NextModule, I18NextLoadResult, ITranslationService, defaultInterpolationFormat  } from 'angular-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport LocizeApi from 'i18next-locize-backend';\nimport LastUsed from 'locize-lastused';\nimport { locizePlugin } from 'locize';\n\nimport { AppComponent } from './app.component';\n\nconst locizeOptions = {\n  projectId: 'my-locize-project-id',\n  apiKey: 'my-api-key' // used for handleMissing functionality, do not add your api-key in a production buildyour\n};\n\nconst i18nextOptions = {\n  debug: true,\n  fallbackLng: 'en',\n  saveMissing: true, // do not use the saveMissing functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production\n  backend: locizeOptions,\n  locizeLastUsed: locizeOptions,\n  interpolation: {\n    format: I18NextModule.interpolationFormat(defaultInterpolationFormat)\n  }\n};\n\nexport function appInit(i18next: ITranslationService) {\n  return () => {\n    let promise: Promise<I18NextLoadResult> = i18next\n      // locize-lastused\n      // sets a timestamp of last access on every translation segment on locize\n      // -> safely remove the ones not being touched for weeks/months\n      // https://github.com/locize/locize-lastused\n      // do not use the lastused functionality in production: https://docs.locize.com/guides-tips-and-tricks/going-production\n      .use(LastUsed)\n      // locize-editor\n      // InContext Editor of locize\n      .use(locizePlugin)\n      // i18next-locize-backend\n      // loads translations from your project, saves new keys to it (saveMissing: true)\n      // https://github.com/locize/i18next-locize-backend\n      .use(LocizeApi)\n      .use<any>(LanguageDetector)\n      .init(i18nextOptions);\n    return promise;\n  };\n}\n\nexport function localeIdFactory(i18next: ITranslationService)  {\n  return i18next.language;\n}\n\nexport const I18N_PROVIDERS = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInit,\n    deps: [I18NEXT_SERVICE],\n    multi: true\n  },\n  {\n    provide: LOCALE_ID,\n    deps: [I18NEXT_SERVICE],\n    useFactory: localeIdFactory\n  },\n];\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    I18NextModule.forRoot()\n  ],\n  providers: [\n    I18N_PROVIDERS\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![locize autotranslate](locize_autotranslate.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![react localization](../react-i18next/last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![in context](in_context.jpg \"locize © inweso GmbH\")\n\n[Caching](https://docs.locize.com/more/caching):\n\n![react localization caching](../react-i18next/caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](../react-i18next/overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code can be found [here](https://github.com/locize/locize-angular-example).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [i18next](https://www.i18next.com), [angular-i18next](https://github.com/Romanchuk/angular-i18next/) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth to try [locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"angular","slug":"angular","permalink":"https://locize.com/blog/tags/angular/"}]},{"title":"Give vue-i18n more superpowers❕","slug":"give-vue-i18n-more-superpowers","date":"un22fin22","updated":"un66fin66","comments":true,"path":"give-vue-i18n-more-superpowers/","link":"","permalink":"https://locize.com/blog/give-vue-i18n-more-superpowers/","excerpt":"","text":"It’s joyful to work with Vue.js. The design is elegant and the robust first-party additions which can be coupled with, make building browser apps a pleasure. The most famous i18n plugin for the progressive JavaScript framework Vue.js is probably Vue I18n. Kazuya, thank you for this great i18n plugin! TOC New versions So how does a basic vue-i18n setup look like? Let&#39;s get into it... Is it possible to make a vue-18n setup even better? Prerequisites Getting started Language Switcher Component interpolation and directive Where are the additional superpowers? How does this look like? save missing translations 👀 but there&#39;s more... 🎉🥳 Congratulations 🎊🎁 New versions Beside templates, directives, data binding, event handling, etc... with v3 Vue.js is now introducing also Composition API, Teleport, Fragments... and Suspense. The appropriate version to Vue.js v3 for Vue I18n is v9. So how does a basic vue-i18n setup look like? Let&#39;s get into it...Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic Vue.js, before jumping to vue-i18n. Getting started Take your own Vue.js project or create a new one, i.e. with the vue create cli command. 12npx @vue/cli create vue-starter-project## select vue 3 preset Let&#39;s install the vue-i18n dependency: npm install vue-i18n Let&#39;s prepare the main.js file: 123456789101112131415161718192021222324import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;;import App from &#x27;./App.vue&#x27;export const i18n = createI18n(&#123; locale: &#x27;en&#x27;, // set locale fallbackLocale: &#x27;en&#x27;, // set fallback locale messages: &#123; en: &#123; message: &#123; welcome: &#x27;Welcome to Your Vue.js App&#x27; &#125; &#125;, de: &#123; message: &#123; welcome: &#x27;Willkommen zu Deiner Vue.js App&#x27; &#125; &#125; &#125; // If you need to specify other options, you can set other options // ...&#125;)createApp(App).use(i18n).mount(&#x27;#app&#x27;) Now let&#39;s create a first component TranslationShowCase.vue: 1234567891011&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&quot;welcome&quot;) &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;&#125;&lt;/script&gt; ...and use that component in App.vue: 1234567891011121314151617181920212223242526&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;TranslationShowCase /&gt;&lt;/template&gt;&lt;script&gt;import TranslationShowCase from &#x27;./components/TranslationShowCase.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; TranslationShowCase &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; You should now see something like this: Language Switcher Now we will create a language switcher to make the content change between different languages. 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&quot;welcome&quot;) &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;div&gt; &lt;a v-if=&quot;$i18n.locale !== &#x27;de&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;de&#x27;)&quot;&gt;DE&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;de&#x27;&quot;&gt;DE&lt;/strong&gt; &amp;nbsp;|&amp;nbsp; &lt;a v-if=&quot;$i18n.locale !== &#x27;en&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;en&#x27;)&quot;&gt;EN&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;en&#x27;&quot;&gt;EN&lt;/strong&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;, methods: &#123; changeLanguage(lang) &#123; this.$i18n.locale = lang &#125; &#125;&#125;&lt;/script&gt; 🥳 Awesome, you&#39;ve just created your first language switcher! Component interpolation and directive Now let&#39;s try component interpolation and the translation directive: 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&quot;welcome&quot;) &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; &lt;i18n-t keypath=&quot;descr&quot; tag=&quot;label&quot; for=&quot;doc&quot;&gt; &lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot;&gt;&#123;&#123; $t(&#x27;doc&#x27;) &#125;&#125;&lt;/a&gt; &lt;/i18n-t&gt; &lt;/p&gt; &lt;div&gt; &lt;div&gt; &lt;span v-t=&quot;&#123;path:&#x27;end&#x27;&#125;&quot; /&gt; &lt;!-- can also be written like: &lt;i v-t=&quot;&#x27;end&#x27;&quot; /&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;div&gt; &lt;a v-if=&quot;$i18n.locale !== &#x27;de&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;de&#x27;)&quot;&gt;DE&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;de&#x27;&quot;&gt;DE&lt;/strong&gt; &amp;nbsp;|&amp;nbsp; &lt;a v-if=&quot;$i18n.locale !== &#x27;en&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;en&#x27;)&quot;&gt;EN&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;en&#x27;&quot;&gt;EN&lt;/strong&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;, methods: &#123; changeLanguage(lang) &#123; this.$i18n.locale = lang &#125; &#125;&#125;&lt;/script&gt; ...and add the new keys to your translations: 123456789101112131415161718192021222324252627282930import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import App from &#x27;./App.vue&#x27;export const i18n = createI18n(&#123; locale: &#x27;en&#x27;, // set locale fallbackLocale: &#x27;en&#x27;, // set fallback locale messages: &#123; en: &#123; message: &#123; welcome: &#x27;Welcome to Your Vue.js App&#x27;, descr: &#x27;For a guide and recipes on how to configure / customize this project, check out the &#123;0&#125;.&#x27;, doc: &#x27;vue-cli documentation&#x27;, end: &#x27;have fun!&#x27; &#125; &#125;, de: &#123; message: &#123; welcome: &#x27;Willkommen zu Deiner Vue.js App&#x27;, descr: &#x27;Eine Anleitung und Rezepte für das Konfigurieren / Anpassen dieses Projekts findest du in der &#123;0&#125;.&#x27;, doc: &#x27;vue-cli Dokumentation&#x27;, end: &#x27;habe Spass!&#x27; &#125; &#125; &#125; // If you need to specify other options, you can set other options // ...&#125;)createApp(App).use(i18n).mount(&#x27;#app&#x27;) This should be the result: Where are the additional superpowers? Let&#39;s meet locizer... locizer is a lightweight module to access data from your locize project and use that inside your application. What is locize? How does this look like? First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by importing the individual json files or via API or by using the CLI. Having the translations in your code file works, but is not that suitable to work with, for translators. Using locize separates the translations from the code. Having imported all translations should look like this: Done so, we&#39;re going to install locizer. npm install locizer Let&#39;s create a dedicated i18n.js file: 12345678910111213141516171819202122232425import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import locizer from &#x27;locizer&#x27;const namespace = &#x27;messages&#x27; // your namespace name added in locizelocizer.init(&#123; projectId: &#x27;your-locize-project-id&#x27;&#125;)export const i18n = createI18n(&#123; locale: locizer.lng, // locizer.lng is the language detected in your browser. fallbackLocale: &#x27;en&#x27; // set fallback locale // If you need to specify other options, you can set other options // ...&#125;)// called from within setup hook in App.vueexport const loadMessagesPromise = new Promise((resolve, reject) =&gt; &#123; locizer.loadAll(namespace, (err, messages) =&gt; &#123; if (err) return reject(err); Object.keys(messages).forEach((l) =&gt; &#123; i18n.global.setLocaleMessage(l, messages[l]) &#125;) resolve(messages) &#125;)&#125;) The translations are now loaded asynchronously, that&#39;s why we export the loadMessagesPromise and use it in your App.vue: 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;TranslationShowCase /&gt;&lt;/template&gt;&lt;script&gt;import &#123; loadMessagesPromise &#125; from &#x27;./i18n&#x27;import TranslationShowCase from &#x27;./components/TranslationShowCase.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; TranslationShowCase &#125;, // used in combination with Suspense. // useful when translations are not in-memory... async setup() &#123; await loadMessagesPromise return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; Additionally, we make use of the new Suspense functionality of Vue.js. Let&#39;s create a new file: i.e. Suspenser.vue: 123456789101112131415161718192021&lt;template&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;App /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;span&gt;Loading...&lt;/span&gt; &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt;import App from &#x27;./App.vue&#x27;export default &#123; name: &#x27;Suspenser&#x27;, components: &#123; App &#125;&#125;&lt;/script&gt; And use that in your main.js file: 12345import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; i18n &#125; from &#x27;./i18n&#x27;import App from &#x27;./Suspenser.vue&#x27;createApp(App).use(i18n).mount(&#x27;#app&#x27;) Now, as long your translations gets loaded you&#39;ll see the fallback template: If your browser is configured with german language, you may now have seen the language automatically was set to german by default. This is because of the language detection feature of locizer. You can configure the language detection with other options By default the language detection also is looking for the query parameter lng, so you can also type this url to test this: http://localhost:8080/?lng=de save missing translations I wish newly added keys in the code, would automatically be saved to locize. Your wish is my command! Extend the i18n.js file with the locize api-key and the handleMissing function: 123456789101112131415161718192021222324252627282930313233import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import locizer from &#x27;locizer&#x27;const namespace = &#x27;messages&#x27; // your namespace name added in locizeconst apiKey = &#x27;my-api-key&#x27; // used for handleMissing functionality, do not add your api-key in a production buildlocizer.init(&#123; projectId: &#x27;your-locize-project-id&#x27;, apiKey&#125;)export const i18n = createI18n(&#123; locale: locizer.lng, // locizer.lng is the language detected in your browser. fallbackLocale: &#x27;en&#x27; // set fallback locale // If you need to specify other options, you can set other options // ...&#125;)// called from within setup hook in App.vueexport const loadMessagesPromise = new Promise((resolve, reject) =&gt; &#123; locizer.loadAll(namespace, (err, messages) =&gt; &#123; if (err) return reject(err); Object.keys(messages).forEach((l) =&gt; &#123; i18n.global.setLocaleMessage(l, messages[l]) &#125;) resolve(messages) &#125;)&#125;)export function handleMissing (locale, key) &#123; if (!apiKey) return if (locale !== locizer.referenceLng) return locizer.add(namespace, key, key)&#125; And use it in the component: 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;TranslationShowCase /&gt;&lt;/template&gt;&lt;script&gt;import &#123; useI18n &#125; from &#x27;vue-i18n&#x27;import &#123; loadMessagesPromise, handleMissing &#125; from &#x27;./i18n&#x27;import TranslationShowCase from &#x27;./components/TranslationShowCase.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; TranslationShowCase &#125;, // used in combination with Suspense. // useful when translations are not in-memory... async setup() &#123; useI18n().setMissingHandler(handleMissing) await loadMessagesPromise return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; Now, if you add a new key in your templates, &lt;h2&gt;&#123;&#123; $t(\"How are you?\") &#125;&#125;&lt;/h2&gt;: 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; $t(&quot;welcome&quot;) &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; $t(&quot;How are you?&quot;) &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;p&gt; &lt;i18n-t keypath=&quot;descr&quot; tag=&quot;label&quot; for=&quot;doc&quot;&gt; &lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot;&gt;&#123;&#123; $t(&#x27;doc&#x27;) &#125;&#125;&lt;/a&gt; &lt;/i18n-t&gt; &lt;/p&gt; &lt;div&gt; &lt;div&gt; &lt;span v-t=&quot;&#123;path:&#x27;end&#x27;&#125;&quot; /&gt; &lt;!-- can also be written like: &lt;i v-t=&quot;&#x27;end&#x27;&quot; /&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;div&gt; &lt;a v-if=&quot;$i18n.locale !== &#x27;de&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;de&#x27;)&quot;&gt;DE&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;de&#x27;&quot;&gt;DE&lt;/strong&gt; &amp;nbsp;|&amp;nbsp; &lt;a v-if=&quot;$i18n.locale !== &#x27;en&#x27;&quot; v-on:click=&quot;changeLanguage(&#x27;en&#x27;)&quot;&gt;EN&lt;/a&gt; &lt;strong v-if=&quot;$i18n.locale === &#x27;en&#x27;&quot;&gt;EN&lt;/strong&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;TranslationShowCase&#x27;, methods: &#123; changeLanguage(lang) &#123; this.$i18n.locale = lang &#125; &#125;&#125;&lt;/script&gt; It gets automatically saved to locize: Lastly, with the help of the auto-machinetranslation workflow, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation: 👀 but there&#39;s more... Caching: Merging versions: 🧑‍💻 The code can be found here. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about Vue.js localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try locize. 👍","raw":"---\ntitle: Give vue-i18n more superpowers❕\n\ndate: 2021-06-08\ntags:\n  - vue\n  - vue-i18n\n  - i18n\n  - l10n\n  - locize\n  - localization\n  - internationalization\n  - translation\n\nthumbnail: give-vue-i18n-more-superpowers/title.jpg\nredirect_from:\n- /2021-06-08-give-vue-i18n-more-superpowers\n---\n\n![](title.jpg \"locize © inweso GmbH\")\n\nIt’s joyful to work with [Vue.js](https://vuejs.org/). The design is elegant and the robust first-party additions which can be coupled with, make building browser apps a pleasure.\n\nThe most famous i18n plugin for the progressive JavaScript framework [Vue.js](https://vuejs.org/) is probably [Vue I18n](https://vue-i18n.intlify.dev/).\n\n>[Kazuya](https://github.com/kazupon), thank you for this great i18n plugin!\n\n![](vue-i18n-stats.jpg \"locize © inweso GmbH\")\n\n### TOC\n  * [New versions](#new-versions)\n  * [So how does a basic vue-i18n setup look like? Let's get into it...](#start)\n  * Is it possible to make a vue-18n setup even better?\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n    - [Component interpolation and directive](#component-directive)\n    - [Where are the additional superpowers?](#superpowers)\n    - [How does this look like?](#how-look)\n    - [save missing translations](#save-missing)\n    - [👀 but there's more...](#more)\n    - [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n\n## New versions <a name=\"new-versions\"></a>\n\nBeside templates, directives, data binding, event handling, etc... with v3 Vue.js is now introducing also [Composition API](https://vuejs.org/api/composition-api-setup.html), [Teleport](https://vuejs.org/guide/built-ins/teleport.html), Fragments... and [Suspense](https://vuejs.org/guide/built-ins/suspense.html).\nThe appropriate version to Vue.js v3 for [Vue I18n](https://vue-i18n.intlify.dev/) is [v9](https://blog.intlify.dev/posts/vue-i18n-9.html).\n\n\n## So how does a basic vue-i18n setup look like? <a name=\"start\"></a>\n### Let's get into it...\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic Vue.js, before jumping to [vue-i18n](https://vue-i18n.intlify.dev/).\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own Vue.js project or create a new one, i.e. with [the vue create cli command](https://cli.vuejs.org/guide/creating-a-project.html#vue-create).\n\n```sh\nnpx @vue/cli create vue-starter-project\n## select vue 3 preset\n```\n\nLet's install the vue-i18n dependency:\n\n`npm install vue-i18n`\n\nLet's prepare the `main.js` file:\n\n```javascript\nimport { createApp } from 'vue'\nimport { createI18n } from 'vue-i18n';\nimport App from './App.vue'\n\nexport const i18n = createI18n({\n  locale: 'en', // set locale\n  fallbackLocale: 'en', // set fallback locale\n  messages: {\n    en: {\n      message: {\n        welcome: 'Welcome to Your Vue.js App'\n      }\n    },\n    de: {\n      message: {\n        welcome: 'Willkommen zu Deiner Vue.js App'\n      }\n    }\n  }\n  // If you need to specify other options, you can set other options\n  // ...\n})\n\ncreateApp(App).use(i18n).mount('#app')\n```\n\nNow let's create a first component `TranslationShowCase.vue`:\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t(\"welcome\") }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase'\n}\n</script>\n```\n\n...and use that component in `App.vue`:\n\n```javascript\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <TranslationShowCase />\n</template>\n\n<script>\nimport TranslationShowCase from './components/TranslationShowCase.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    TranslationShowCase\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\nYou should now see something like this:\n![](app_0.jpg \"locize © inweso GmbH\")\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nNow we will create a language switcher to make the content change between different languages.\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t(\"welcome\") }}</h1>\n  </div>\n  <hr />\n  <div>\n    <div>\n      <a v-if=\"$i18n.locale !== 'de'\" v-on:click=\"changeLanguage('de')\">DE</a>\n      <strong v-if=\"$i18n.locale === 'de'\">DE</strong>\n      &nbsp;|&nbsp;\n      <a v-if=\"$i18n.locale !== 'en'\" v-on:click=\"changeLanguage('en')\">EN</a>\n      <strong v-if=\"$i18n.locale === 'en'\">EN</strong>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase',\n  methods: {\n    changeLanguage(lang) {\n      this.$i18n.locale = lang\n    }\n  }\n}\n</script>\n```\n\n![](app_1.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\n### Component interpolation and directive <a name=\"component-directive\"></a>\n\nNow let's try [component interpolation](https://vue-i18n.intlify.dev/guide/advanced/component.html#basic-usage) and the [translation directive](https://vue-i18n.intlify.dev/api/directive.html#translationdirective):\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t(\"welcome\") }}</h1>\n  </div>\n  <p>\n    <i18n-t keypath=\"descr\" tag=\"label\" for=\"doc\">\n      <a href=\"https://cli.vuejs.org\" target=\"_blank\">{{ $t('doc') }}</a>\n    </i18n-t>\n  </p>\n  <div>\n    <div>\n      <span v-t=\"{path:'end'}\" /> <!-- can also be written like: <i v-t=\"'end'\" /> -->\n    </div>\n  </div>\n  <hr />\n  <div>\n    <div>\n      <a v-if=\"$i18n.locale !== 'de'\" v-on:click=\"changeLanguage('de')\">DE</a>\n      <strong v-if=\"$i18n.locale === 'de'\">DE</strong>\n      &nbsp;|&nbsp;\n      <a v-if=\"$i18n.locale !== 'en'\" v-on:click=\"changeLanguage('en')\">EN</a>\n      <strong v-if=\"$i18n.locale === 'en'\">EN</strong>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase',\n  methods: {\n    changeLanguage(lang) {\n      this.$i18n.locale = lang\n    }\n  }\n}\n</script>\n```\n\n...and add the new keys to your translations:\n\n```javascript\nimport { createApp } from 'vue'\nimport { createI18n } from 'vue-i18n'\nimport App from './App.vue'\n\nexport const i18n = createI18n({\n  locale: 'en', // set locale\n  fallbackLocale: 'en', // set fallback locale\n  messages: {\n    en: {\n      message: {\n        welcome: 'Welcome to Your Vue.js App',\n        descr: 'For a guide and recipes on how to configure / customize this project, check out the {0}.',\n        doc: 'vue-cli documentation',\n        end: 'have fun!'\n      }\n    },\n    de: {\n      message: {\n        welcome: 'Willkommen zu Deiner Vue.js App',\n        descr: 'Eine Anleitung und Rezepte für das Konfigurieren / Anpassen dieses Projekts findest du in der {0}.',\n        doc: 'vue-cli Dokumentation',\n        end: 'habe Spass!'\n      }\n    }\n  }\n  // If you need to specify other options, you can set other options\n  // ...\n})\n\ncreateApp(App).use(i18n).mount('#app')\n```\n\nThis should be the result:\n\n![](app_2.jpg \"locize © inweso GmbH\")\n\n\n### Where are the additional superpowers? <a name=\"superpowers\"></a>\n\nLet's meet [locizer](https://github.com/locize/locizer)...\n\n[locizer](https://github.com/locize/locizer) is a lightweight module to access data from your [locize](https://www.locize.com) project and use that inside your application.\n\n> [What is locize?](../react-i18next/#for-sure)\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations) or by using the [CLI](https://github.com/locize/locize-cli).\n\nHaving the translations in your code file works, but is not that suitable to work with, for translators.\nUsing locize separates the translations from the code.\n\nHaving imported all translations should look like this:\n![](locize_imported.jpg \"locize © inweso GmbH\")\n\nDone so, we're going to install [locizer](https://github.com/locize/locizer).\n\n`npm install locizer`\n\nLet's create a dedicated `i18n.js` file:\n\n```javascript\nimport { createI18n } from 'vue-i18n'\nimport locizer from 'locizer'\n\nconst namespace = 'messages' // your namespace name added in locize\nlocizer.init({\n  projectId: 'your-locize-project-id'\n})\n\nexport const i18n = createI18n({\n  locale: locizer.lng, // locizer.lng is the language detected in your browser.\n  fallbackLocale: 'en' // set fallback locale\n  // If you need to specify other options, you can set other options\n  // ...\n})\n\n// called from within setup hook in App.vue\nexport const loadMessagesPromise = new Promise((resolve, reject) => {\n  locizer.loadAll(namespace, (err, messages) => {\n    if (err) return reject(err);\n    Object.keys(messages).forEach((l) => {\n      i18n.global.setLocaleMessage(l, messages[l])\n    })\n    resolve(messages)\n  })\n})\n```\n\nThe translations are now loaded asynchronously, that's why we export the `loadMessagesPromise` and use it in your `App.vue`:\n\n```javascript\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <TranslationShowCase />\n</template>\n\n<script>\nimport { loadMessagesPromise } from './i18n'\nimport TranslationShowCase from './components/TranslationShowCase.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    TranslationShowCase\n  },\n  // used in combination with Suspense.\n  // useful when translations are not in-memory...\n  async setup() {\n    await loadMessagesPromise\n    return {}\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\nAdditionally, we make use of the new [Suspense](https://vuejs.org/guide/built-ins/suspense.html) functionality of Vue.js.\nLet's create a new file: i.e. `Suspenser.vue`:\n\n```javascript\n<template>\n  <Suspense>\n    <template #default>\n      <App />\n    </template>\n    <template #fallback>\n      <span>Loading...</span>\n    </template>\n  </Suspense>\n</template>\n\n<script>\nimport App from './App.vue'\n\nexport default {\n  name: 'Suspenser',\n  components: {\n    App\n  }\n}\n</script>\n```\n\nAnd use that in your `main.js` file:\n\n```javascript\nimport { createApp } from 'vue'\nimport { i18n } from './i18n'\nimport App from './Suspenser.vue'\n\ncreateApp(App).use(i18n).mount('#app')\n```\n\nNow, as long your translations gets loaded you'll see the fallback template:\n![](app_3.jpg \"locize © inweso GmbH\")\n\nIf your browser is configured with german language, you may now have seen the language automatically was set to german by default. This is because of the language detection feature of locizer. You can configure the language detection with other [options](https://github.com/locize/locizer#init-options)\nBy default the language detection also is looking for the query parameter lng, so you can also type this url to test this: http://localhost:8080/?lng=de\n![](app_2.jpg \"locize © inweso GmbH\")\n\n\n#### save missing translations <a name=\"save-missing\"></a>\n\n>I wish newly added keys in the code, would automatically be saved to locize.\n\n**Your wish is my command!**\n\nExtend the `i18n.js` file with the locize api-key and the handleMissing function:\n\n```javascript\nimport { createI18n } from 'vue-i18n'\nimport locizer from 'locizer'\n\nconst namespace = 'messages' // your namespace name added in locize\nconst apiKey = 'my-api-key' // used for handleMissing functionality, do not add your api-key in a production build\nlocizer.init({\n  projectId: 'your-locize-project-id',\n  apiKey\n})\n\nexport const i18n = createI18n({\n  locale: locizer.lng, // locizer.lng is the language detected in your browser.\n  fallbackLocale: 'en' // set fallback locale\n  // If you need to specify other options, you can set other options\n  // ...\n})\n\n// called from within setup hook in App.vue\nexport const loadMessagesPromise = new Promise((resolve, reject) => {\n  locizer.loadAll(namespace, (err, messages) => {\n    if (err) return reject(err);\n    Object.keys(messages).forEach((l) => {\n      i18n.global.setLocaleMessage(l, messages[l])\n    })\n    resolve(messages)\n  })\n})\n\nexport function handleMissing (locale, key) {\n  if (!apiKey) return\n  if (locale !== locizer.referenceLng) return\n  locizer.add(namespace, key, key)\n}\n```\n\nAnd use it in the component:\n\n```javascript\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <TranslationShowCase />\n</template>\n\n<script>\nimport { useI18n } from 'vue-i18n'\nimport { loadMessagesPromise, handleMissing } from './i18n'\nimport TranslationShowCase from './components/TranslationShowCase.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    TranslationShowCase\n  },\n  // used in combination with Suspense.\n  // useful when translations are not in-memory...\n  async setup() {\n    useI18n().setMissingHandler(handleMissing)\n    await loadMessagesPromise\n    return {}\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\nNow, if you add a new key in your templates, `<h2>{{ $t(\"How are you?\") }}</h2>`:\n\n```javascript\n<template>\n  <div class=\"hello\">\n    <h1>{{ $t(\"welcome\") }}</h1>\n    <h2>{{ $t(\"How are you?\") }}</h2>\n  </div>\n  <p>\n    <i18n-t keypath=\"descr\" tag=\"label\" for=\"doc\">\n      <a href=\"https://cli.vuejs.org\" target=\"_blank\">{{ $t('doc') }}</a>\n    </i18n-t>\n  </p>\n  <div>\n    <div>\n      <span v-t=\"{path:'end'}\" /> <!-- can also be written like: <i v-t=\"'end'\" /> -->\n    </div>\n  </div>\n  <hr />\n  <div>\n    <div>\n      <a v-if=\"$i18n.locale !== 'de'\" v-on:click=\"changeLanguage('de')\">DE</a>\n      <strong v-if=\"$i18n.locale === 'de'\">DE</strong>\n      &nbsp;|&nbsp;\n      <a v-if=\"$i18n.locale !== 'en'\" v-on:click=\"changeLanguage('en')\">EN</a>\n      <strong v-if=\"$i18n.locale === 'en'\">EN</strong>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TranslationShowCase',\n  methods: {\n    changeLanguage(lang) {\n      this.$i18n.locale = lang\n    }\n  }\n}\n</script>\n```\n\nIt gets automatically saved to locize:\n![](locize_missing.jpg \"locize © inweso GmbH\")\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation:\n![](locize_autotranslate.jpg \"locize © inweso GmbH\")\n\n![](app_4.jpg \"locize © inweso GmbH\")\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\n[Caching](https://docs.locize.com/more/caching):\n\n![](../react-i18next/caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![](../react-i18next/overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The code can be found [here](https://github.com/locize/locizer/tree/master/example/vue).*\n\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [Vue.js localization](https://vue-i18n.intlify.dev/) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth to try [locize](https://locize.com).\n\n\n## 👍\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"vue","slug":"vue","permalink":"https://locize.com/blog/tags/vue/"},{"name":"vue-i18n","slug":"vue-i18n","permalink":"https://locize.com/blog/tags/vue-i18n/"}]},{"title":"Best React Localization - Internationalize with i18next (a complete guide to react-i18next)","slug":"react-i18next","date":"un33fin33","updated":"un22fin22","comments":true,"path":"react-i18next/","link":"","permalink":"https://locize.com/blog/react-i18next/","excerpt":"","text":"Overcoming the language barrier for users who use your software is an important topic. English is no longer the universal language of the internet. As of March 2020, only 25.9% of internet users were English speakers. The chances are high that your users will skip past your website if non-localized. Therefore, without a multilingual website you might missing out on a large share of potential users. In the JavaScript ecosystem, there are a lot of internationalization frameworks. Here you can find some details about some JavaScript internationalization frameworks. In this article, we will be using the i18next framework to internationalize a React.js app. This step-by-step guide is for you if you&#39;re looking for a way to create an internationalized React.js app (with or without Create React App).Basically, we&#39;re going to answer the following question: &quot;How to use i18n in React?&quot; TOC So first of all: &quot;Why i18next?&quot; Let&#39;s get into it... Prerequisites Getting started Language Switcher How to get the current language? Interpolation and Pluralization Formatting Context Separate translations from code Multiple namespaces Better translation management For sure! How does this look like? save missing translations 👀 but there&#39;s more... 📦 Let&#39;s prepare for production 🚀 🎉🥳 Congratulations 🎊🎁 Streamline your i18next setup process with this step-by-step guide. Get your localization framework up and running in no time and ensure smooth language transitions for your users. Follow the instructions and avoid any setup complications for your next international project. So first of all: &quot;Why i18next?&quot; When it comes to React localization, one of the most popular is i18next with its react extension react-i18next, and for good reasons: i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (React, Angular, Vue, ...). ➡️ sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ➡️ mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ➡️ extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular i18n frameworks. ➡️ rich Here you can find more information about why i18next is special and how it works. Let&#39;s get into it (react-i18next)... Prerequisites Make sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic React.js, before jumping to react-i18next - the powerful React i18n framework. This react-i18next localization example is not intended to be a React beginner tutorial. Getting started Take your own React project or create a new one, i.e. with create-react-app. npx create-react-app my-app We are going to adapt the app to detect the language according to the user’s preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: i18next react-i18next i18next-browser-languagedetector npm install i18next react-i18next i18next-browser-languagedetector Let&#39;s prepare an i18n.js file: 12345678910111213141516171819202122232425262728import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; // here we will place our translations... &#125; &#125; &#125; &#125;);export default i18n; Let&#39;s import that file somewhere in our index.js file: For React &gt;= 18.0.0 use: 1234567891011121314import React from &#x27;react&#x27;;import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;// import i18n (needs to be bundled ;))import &#x27;./i18n&#x27;;const root = createRoot(document.getElementById(&#x27;root&#x27;))root.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;); For older React versions use: 1234567891011121314import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;// import i18n (needs to be bundled ;))import &#x27;./i18n&#x27;;ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;)); Now let&#39;s try to move some hard coded text out to the translations. We have used the Trans component for the first text and the useTranslation hook for the second text: 123456789101112131415161718192021222324252627282930import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;function App() &#123; const &#123; t &#125; = useTranslation(); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; There is some more effort necessary if you wish to use High-Order-Components (HOC). Another option in this situation is to use withTranslation HOC. The texts are now part of the translation resources: 12345678910111213141516171819202122232425262728293031import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; Language Switcher Now let&#39;s define a language switcher: 123456789101112131415161718192021222324252627282930313233343536373839404142import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.resolvedLanguage === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; i18n.changeLanguage(lng)&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; And also add some translations for the new language: 123456789101112131415161718192021222324252627282930313233343536373839import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;Ändere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; 🥳 Awesome, you&#39;ve just created your first language switcher! Thanks to i18next-browser-languagedetector now it tries to detect the browser language and automatically use that language if you&#39;ve provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language. How to get the current language? Since i18next v21 there is i18next.resolvedLanguage. It is set to the current resolved language and it can be used as primary used language, for example in a language switcher. If your detected language for example is en-US and you provided translations only for en (fallbackLng) instead i18next.resolvedLanguage will return en. i18next.language vs. i18next.languages vs. i18next.resolvedLanguage12345678910111213141516171819202122232425262728/* language */i18next.language;// Is set to the current detected or set language./* languages */i18next.languages;// Is set to an array of language codes that will be used to look up the translation value.// When the language is set, this array is populated with the new language codes.// Unless overridden, this array is populated with less-specific versions of that code for fallback purposes, followed by the list of fallback languages// initialize with fallback languagesi18next.init(&#123; fallbackLng: [&quot;es&quot;, &quot;fr&quot;, &quot;en-US&quot;, &quot;dev&quot;]&#125;);// change the languagei18next.changeLanguage(&quot;en-US-xx&quot;);// new language and its more generic forms, followed by fallbacksi18next.languages; // [&quot;en-US-xx&quot;, &quot;en-US&quot;, &quot;en&quot;, &quot;es&quot;, &quot;fr&quot;, &quot;dev&quot;]// change the language againi18next.changeLanguage(&quot;de-DE&quot;);// previous language is not retainedi18next.languages; // [&quot;de-DE&quot;, &quot;de&quot;, &quot;es&quot;, &quot;fr&quot;, &quot;en-US&quot;, &quot;dev&quot;]/* resolvedLanguage */i18next.resolvedLanguage;// Is set to the current resolved language.// It can be used as primary used language,// for example in a language switcher. Interpolation and Pluralization i18next goes beyond just providing the standard i18n features. But for sure it&#39;s able to handle plurals and interpolation. Let&#39;s count each time the language gets changed: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;import &#123; useState &#125; from &#x27;react&#x27;;const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); const [count, setCounter] = useState(0); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.resolvedLanguage === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; &#123; i18n.changeLanguage(lng); setCounter(count + 1); &#125;&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;i&gt;&#123;t(&#x27;counter&#x27;, &#123; count &#125;)&#125;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; ...and extending the translation resources: 12345678910111213141516171819202122232425262728293031323334353637383940414243import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;Ändere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27; &#125; &#125; &#125; &#125;);export default i18n; Based on the count value i18next will choose the correct plural form. Read more about pluralization and interpolation in the official i18next documentation. 💡 i18next is also able to handle languages with multiple plural forms, like arabic: 1234567891011121314151617181920// translation resources:&#123; &quot;key_zero&quot;: &quot;zero&quot;, &quot;key_one&quot;: &quot;singular&quot;, &quot;key_two&quot;: &quot;two&quot;, &quot;key_few&quot;: &quot;few&quot;, &quot;key_many&quot;: &quot;many&quot;, &quot;key_other&quot;: &quot;other&quot;&#125;// usage:t(&#x27;key&#x27;, &#123;count: 0&#125;); // -&gt; &quot;zero&quot;t(&#x27;key&#x27;, &#123;count: 1&#125;); // -&gt; &quot;singular&quot;t(&#x27;key&#x27;, &#123;count: 2&#125;); // -&gt; &quot;two&quot;t(&#x27;key&#x27;, &#123;count: 3&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 4&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 5&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 11&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 99&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 100&#125;); // -&gt; &quot;other&quot; Why are my plural keys not working? Are you seeing this warning in the development console (debug: true)? i18next::pluralResolver: Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling. With v21 i18next streamlined the suffix with the one used in the Intl API. In environments where the Intl.PluralRules API is not available (like older Android devices), you may need to polyfill the Intl.PluralRules API. In case it is not available it will fallback to the i18next JSON format v3 plural handling. And if your json is already using the new suffixes, your plural keys will probably not be shown. tldr; npm install intl-pluralrules 1import &#x27;intl-pluralrules&#x27; Formatting Now, let’s check out how we can use different date formats with the help of i18next and Luxon to handle date and time. npm install luxon We like to have a footer displaying the current date: 123456789101112import &#x27;./Footer.css&#x27;;const Footer = (&#123; t &#125;) =&gt; ( &lt;div className=&quot;Footer&quot;&gt; &lt;div&gt;&#123;t(&#x27;footer.date&#x27;, &#123; date: new Date() &#125;)&#125;&lt;/div&gt; &lt;/div&gt;);export default Footer;// imported in our App.js and used like this// &lt;Footer t=&#123;t&#125; /&gt; import luxon and define a format function, like documented in the documentation and add the new translation key: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, footer: &#123; date: &#x27;Today is &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;Ändere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, footer: &#123; date: &#x27;Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125; &#125; &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; 😎 Cool, now we have a language specific date formatting! English: German: Context What about a specific greeting message based on the current day time? i.e. morning, evening, etc. This is possible thanks to the context feature of i18next. Let&#39;s create a getGreetingTime function and use the result as context information for our footer translation: 1234567891011121314151617181920212223import &#123; DateTime &#125; from &#x27;luxon&#x27;;import &#x27;./Footer.css&#x27;;const getGreetingTime = (d = DateTime.now()) =&gt; &#123; const split_afternoon = 12; // 24hr time to split the afternoon const split_evening = 17; // 24hr time to split the evening const currentHour = parseFloat(d.toFormat(&#x27;hh&#x27;)); if (currentHour &gt;= split_afternoon &amp;&amp; currentHour &lt;= split_evening) &#123; return &#x27;afternoon&#x27;; &#125; else if (currentHour &gt;= split_evening) &#123; return &#x27;evening&#x27;; &#125; return &#x27;morning&#x27;;&#125;const Footer = (&#123; t &#125;) =&gt; ( &lt;div className=&quot;Footer&quot;&gt; &lt;div&gt;&#123;t(&#x27;footer.date&#x27;, &#123; date: new Date(), context: getGreetingTime() &#125;)&#125;&lt;/div&gt; &lt;/div&gt;);export default Footer; And add some context specific translations keys: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-http-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter_one: &#x27;Changed language just once&#x27;, counter_other: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, footer: &#123; date: &#x27;Today is &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_morning: &#x27;Good morning! Today is &#123;&#123;date, DATE_HUGE&#125;&#125; | Have a nice day!&#x27;, date_afternoon: &#x27;Good afternoon! It\\&#x27;s &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_evening: &#x27;Good evening! Today was the &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;Ändere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter_one: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_other: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, footer: &#123; date: &#x27;Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_morning: &#x27;Guten Morgen! Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125; | Wünsche einen schönen Tag!&#x27;, date_afternoon: &#x27;Guten Tag! Es ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_evening: &#x27;Guten Abend! Heute war &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125; &#125; &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; 😁 Yeah, It works! Separate translations from code Having the translations in our i18n.js file works, but is not that suitable to work with, for translators. Let&#39;s separate the translations from the code and pleace them in dedicated json files. Because this is a web application, i18next-http-backend will help us to do so. npm install i18next-http-backend Move the translations to the public folder: Adapt the i18n.js file to use the i18next-http-backend: 1234567891011121314151617181920212223242526272829303132333435363738import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-http-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125; &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; Now the translations are loaded asynchronously, so make sure you wrap your app with a Suspense component to prevent this error: Uncaught Error: App suspended while rendering, but no fallback UI was specified. 1234567891011121314import &#123; Suspense &#125; from &#x27;react&#x27;;function App() &#123; // your app&#x27;s code...&#125;// here app catches the suspense from page in case translations are not yet loadedexport default function WrappedApp() &#123; return ( &lt;Suspense fallback=&quot;...is loading&quot;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; Now your app looks still the same, but your translations are separated. If you want to support a new language, you just create a new folder and a new translation json file. This gives you the possibility to send the translations to some translators. Or if you&#39;re working with a translation management system you can just synchronize the files with a cli. 🧑‍💻 The code of this first part can be found here. Multiple namespaces 💡 btw: you can also have multiple translation files thanks to the namespaces feature of i18next One of the advantages of react-i18next is based on i18next, it supports the separation of translations into multiple files - which are called namespaces in i18next. In order to use multiple namespaces/translation files, you need to specify it when calling useTranslation: 123const &#123; t &#125; = useTranslation([&#x27;translation&#x27;, &#x27;common&#x27;]);// ...// t(&#x27;look.deep&#x27;, &#123; ns: &#x27;common&#x27; &#125;) withTranslation: 123withTranslation([&#x27;translation&#x27;, &#x27;common&#x27;])(MyComponent);// ...// t(&#x27;look.deep&#x27;, &#123; ns: &#x27;common&#x27; &#125;) or Translation: 12345&lt;Translation ns=&#123;[&#x27;translation&#x27;, &#x27;common&#x27;]&#125;&gt;&#123; (t) =&gt; &lt;p&gt;&#123;t(&#x27;look.deep&#x27;, &#123; ns: &#x27;common&#x27; &#125;)&#125;&lt;/p&gt;&#125;&lt;/Translation&gt; Better translation management By sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you. This is a traditional way. But be aware sending files around creates always an overhead. Does a better option exist? For sure! i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? How do you deploy translation changes without deploying your complete application? and a lot more... Looking for something like this❓ Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Profit from our content delivery network (CDN) Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... How does this look like? First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by using the cli or by importing the individual json files or via API. Done so, we&#39;re going to replace i18next-http-backend with i18next-locize-backend. npm install i18next-locize-backend After having imported the translations to locize, delete the locales folder: Adapt the i18n.js file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, backend: locizeOptions &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; i18next-locize-backend offers a functionality to retrieve the available languages directly from locize, let&#39;s use it: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;import &#123; useState, Suspense, useEffect &#125; from &#x27;react&#x27;;import Footer from &#x27;./Footer&#x27;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); const [count, setCounter] = useState(0); const [lngs, setLngs] = useState(&#123; en: &#123; nativeName: &#x27;English&#x27; &#125;&#125;); useEffect(() =&gt; &#123; i18n.services.backendConnector.backend.getLanguages((err, ret) =&gt; &#123; if (err) return // TODO: handle err... setLngs(ret); &#125;); &#125;, []); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.resolvedLanguage === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; &#123; i18n.changeLanguage(lng); setCounter(count + 1); &#125;&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;i&gt;&#123;t(&#x27;counter&#x27;, &#123; count &#125;)&#125;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;Footer t=&#123;t&#125; /&gt; &lt;/div&gt; );&#125;// here app catches the suspense from page in case translations are not yet loadedexport default function WrappedApp() &#123; return ( &lt;Suspense fallback=&quot;...is loading&quot;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; save missing translations Thanks to the use of the saveMissing functionality, new keys gets added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, backend: locizeOptions, saveMissing: true &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;div&gt;&#123;t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;)&#125;&lt;/div&gt; will result in locize like this: 👀 but there&#39;s more... Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see how the automatic machine translation workflow looks like! npm install locize-lastused locize use them in i18n.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused .use(LastUsed) // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: true &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; Automatic machine translation: Last used translations filter: InContext Editor: 📦 Let&#39;s prepare for production 🚀 Now, we prepare the app for going to production. First in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via API or via CLI. Lastly, enable Cache-Control max-age​ for that production version. Let&#39;s making use of the environment feature of react-scripts. Lets&#39; create a default environment file and one for development and one for production: .env: 1234567SKIP_PREFLIGHT_CHECK=trueREACT_APP_VERSION=$npm_package_version## locizeREACT_APP_LOCIZE_PROJECTID=0bbc223a-9aba-4a90-ab93-ab9d7bf7f780REACT_APP_LOCIZE_REFLNG=en .env.development: 12REACT_APP_LOCIZE_VERSION=latestREACT_APP_LOCIZE_APIKEY=aaad4141-54ba-4625-ae37-657538fe29e7 .env.production: 1REACT_APP_LOCIZE_VERSION=production Now let&#39;s adapt the i18n.js file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const isProduction = process.env.NODE_ENV === &#x27;production&#x27;;const locizeOptions = &#123; projectId: process.env.REACT_APP_LOCIZE_PROJECTID, apiKey: process.env.REACT_APP_LOCIZE_APIKEY, // YOU should not expose your apps API key to production!!! referenceLng: process.env.REACT_APP_LOCIZE_REFLNG, version: process.env.REACT_APP_LOCIZE_VERSION&#125;;if (!isProduction) &#123; // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused i18n.use(LastUsed);&#125;i18n // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default // format: (value, format, lng) =&gt; &#123; // legacy usage // if (value instanceof Date) &#123; // return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) // &#125; // return value; // &#125; &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: !isProduction // you should not use saveMissing in production &#125;);// new usagei18n.services.formatter.add(&#x27;DATE_HUGE&#x27;, (value, lng, options) =&gt; &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)&#125;);export default i18n; Now, during development, you&#39;ll continue to save missing keys and to make use of lastused feature. =&gt; npm run start And in production environment, saveMissing and lastused are disabled, and also the api-key is not exposed. =&gt; npm run build &amp;&amp; npm run serve Caching: Merging versions: 🧑‍💻 The complete code for this React example can be found here. And a TypeScript version here. Check also the code integration part in this YouTube video. There&#39;s also an i18next crash course video. There is also a Spanish translation of this blog post. 🎉🥳 Congratulations 🎊🎁 I hope you’ve learned a few new things about i18next, React.js localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth trying the localization management platform - locize. The founders of locize are also the creators of i18next. So by using locize you directly support the future of i18next. 👍 { \"@context\": \"https://schema.org\", \"@type\": \"FAQPage\", \"mainEntity\": [{ \"@type\": \"Question\", \"name\": \"Why i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Sustainability: i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend tech (React, Angular, Vue, ...). Maturity: Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. Extensibility: i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. Richness: There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.\" } },{ \"@type\": \"Question\", \"name\": \"How does i18next work?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"image\": \"https://locize.com/img/i18next_how_it_works.png\", \"text\": \"At first, i18next seems to be a simple key/translation dictionary, but in reality it is an elaborated and very extensible i18n framework with a lot of power. It offers translations to be provided from different sources, a language detection, plural form resolutions, caching, post processing, alternative i18n formats and more. You see it does not only offer the standard i18n features, like interpolation, formatting, etc. But the best thing about it is certainly the limitless ecosystem around i18next. We don't know of any other i18n framework with such a large community. That's why we like i18next that much!\" } },{ \"@type\": \"Question\", \"name\": \"What is i18next and how does it work?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"image\": \"https://locize.com/img/i18next_how_it_works.png\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop. At first, i18next seems to be a simple key/translation dictionary, but in reality it is an elaborated and very extensible i18n framework with a lot of power. It offers translations to be provided from different sources, a language detection, plural form resolutions, caching, post processing, alternative i18n formats and more. You see it does not only offer the standard i18n features, like interpolation, formatting, etc. But the best thing about it is certainly the limitless ecosystem around i18next. We don't know of any other i18n framework with such a large community. That's why we like i18next that much!\" } },{ \"@type\": \"Question\", \"name\": \"What is i18next?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\" } },{ \"@type\": \"Question\", \"name\": \"What are the benefits of using i18next over other internationalization libraries?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Lightweight and flexible: i18next is a small library that doesn't require a lot of setup and can be easily integrated with other libraries and frameworks. Support for multiple languages: i18next supports a wide range of languages and provides a simple way to switch between them on the fly. Easy to use API: i18next provides a simple and intuitive API for translating and formatting strings, dates, and numbers. Pluralization and gender handling: i18next provides built-in support for handling pluralization and gender in different languages. Good performance: i18next is designed for performance and provides caching mechanisms to minimize the number of lookups. Active community: i18next has a large and active community of developers who contribute to the library and provide support for new features and bug fixes.\" } },{ \"@type\": \"Question\", \"name\": \"Can i18next be integrated with popular frontend frameworks like React, Vue, and Angular?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, i18next can be integrated with popular frontend frameworks such as React, Vue, and Angular. There are official packages for each framework and community-supported packages available for integration.\" } },{ \"@type\": \"Question\", \"name\": \"Can i18next be used for server-side rendering and how does it impact performance?\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Yes, i18next can be used for server-side rendering. Using i18next on the server-side can improve the performance of your website by allowing you to pre-render the internationalized content, which can then be served to the user's browser.\" } }] }","raw":"---\ntitle: Best React Localization - Internationalize with i18next (a complete guide to react-i18next)\ndescription: Integrate i18next seamlessly into your React applications. Follow this easily with this ✅ step-by-step guide.\n\ndate: 2021-04-14\ntags:\n  - i18next\n  - react\n  - react-i18next\n  - locize\n  - l10n\n  - i18n\n  - localization\n  - internationalization\n  - translation\nthumbnail: react-i18next/react-localization.jpg\nredirect_from:\n- /2021-04-14-how-to-internationalize-react-i18next\n- /how-to-internationalize-react-i18next\n\nlabel: react-i18next\nlang: en\n---\n\n![React Localization made easy with this step-by-step guide using i18next ✅](react-localization.jpg \"React Localization example\")\n\nOvercoming the language barrier for users who use your software is an important topic.\nEnglish is no longer the universal language of the internet.\nAs of [March 2020](https://www.internetworldstats.com/stats7.htm), only 25.9% of internet users were English speakers.\nThe chances are high that your users will skip past your website if non-localized.\nTherefore, without a multilingual website you might missing out on a large share of potential users.\n\nIn the JavaScript ecosystem, there are a lot of internationalization frameworks. [Here](https://medium.com/@jamuhl/i18n-frameworks-the-unfair-showdown-8d436cd6f470) you can find some details about some JavaScript internationalization frameworks.\nIn this article, we will be using the [i18next](https://www.i18next.com) framework to internationalize a [React.js](https://reactjs.org) app. This step-by-step guide is for you if you're looking for a way to create an internationalized React.js app (with or without Create React App).</br><div style=\"margin-top: -25px;\">Basically, we're going to answer the following question: <h2 style=\"display: inline; font-size: 18px;\">\"How to use i18n in React?\"</h2></div>\n\n### TOC\n  * [So first of all: \"Why i18next?\"](#why-i18next)\n  * [Let's get into it...](#start)\n    - [Prerequisites](#prerequisites)\n    - [Getting started](#getting-started)\n    - [Language Switcher](#language-switcher)\n      - [How to get the current language?](#current-language)\n    - [Interpolation and Pluralization](#interpolation-pluralization)\n    - [Formatting](#formatting)\n    - [Context](#context)\n    - [Separate translations from code](#separate)\n      - [Multiple namespaces](#multiple-namespaces)\n    - [Better translation management](#better-translation-management)\n      - [For sure!](#for-sure)\n      - [How does this look like?](#how-look)\n      - [save missing translations](#save-missing)\n      - [👀 but there's more...](#more)\n      - [📦 Let's prepare for production 🚀](#production)\n  * [🎉🥳 Congratulations 🎊🎁](#congratulations)\n\n\n>Streamline your i18next setup process with this step-by-step guide. Get your localization framework up and running in no time and ensure smooth language transitions for your users. Follow the instructions and avoid any setup complications for your next international project.\n\n## So first of all: \"Why i18next?\" <a name=\"why-i18next\"></a>\n\nWhen it comes to React localization, one of the most popular is [i18next](https://www.i18next.com) with its react extension [react-i18next](https://react.i18next.com), and for good reasons:\n\n*i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend technology (React, [Angular](../angular-i18next/), [Vue](../i18next-vue/), ...).*\n<br />\n**➡️ sustainable**\n\n\n*Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next.*\n<br />\n**➡️ mature**\n\n\n*i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... [the possibilities are endless](https://www.i18next.com/overview/supported-frameworks).*\n<br />\n**➡️ extensible**\n\n\n*There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.*\n<br />\n**➡️ rich**\n\n\n[Here](https://www.i18next.com/overview/comparison-to-others) you can find more information about why i18next is special and [how it works](https://locize.com/i18next.html#how-does-i18next-work).\n\n\n## Let's get into it <small style=\"font-size: 0.65em;\">(react-i18next)</small>... <a name=\"start\"></a>\n\n### Prerequisites <a name=\"prerequisites\"></a>\n\nMake sure you have Node.js and npm installed. It's best, if you have some experience with simple HTML, JavaScript and basic React.js, before jumping to [react-i18next](https://react.i18next.com) - the powerful **React i18n** framework. This react-i18next localization example is not intended to be a React beginner tutorial.\n\n\n### Getting started <a name=\"getting-started\"></a>\n\nTake your own React project or create a new one, i.e. with [create-react-app](https://create-react-app.dev).\n\n`npx create-react-app my-app`\n\n![learn react logo](app_0.jpg \"locize © inweso GmbH\")\n\nWe are going to adapt the app to detect the language according to the user’s preference.\nAnd we will create a language switcher to make the content change between different languages.\n\nLet's install some i18next dependencies:\n\n- [i18next](https://www.i18next.com)\n- [react-i18next](https://react.i18next.com)\n- [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector)\n\n`npm install i18next react-i18next i18next-browser-languagedetector`\n\nLet's prepare an `i18n.js` file:\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\ni18n\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    resources: {\n      en: {\n        translation: {\n          // here we will place our translations...\n        }\n      }\n    }\n  });\n\nexport default i18n;\n```\n\nLet's import that file somewhere in our `index.js` file:\n\nFor React >= 18.0.0 use:\n\n```javascript\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\n// import i18n (needs to be bundled ;))\nimport './i18n';\n\nconst root = createRoot(document.getElementById('root'))\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\nFor older React versions use:\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// import i18n (needs to be bundled ;))\nimport './i18n';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nNow let's try to move some hard coded text out to the translations.\n\nWe have used the [Trans component](https://react.i18next.com/latest/trans-component) for the first text and the [useTranslation hook](https://react.i18next.com/latest/usetranslation-hook) for the second text:\n\n```javascript\nimport logo from './logo.svg';\nimport './App.css';\nimport { useTranslation, Trans } from 'react-i18next';\n\nfunction App() {\n  const { t } = useTranslation();\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          <Trans i18nKey=\"description.part1\">\n            Edit <code>src/App.js</code> and save to reload.\n          </Trans>\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {t('description.part2')}\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n```\nThere is some more effort necessary if you wish to use High-Order-Components (HOC). Another option in this situation is to use [withTranslation HOC](https://react.i18next.com/latest/withtranslation-hoc).\n\nThe texts are now part of the translation resources:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\ni18n\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    resources: {\n      en: {\n        translation: {\n          description: {\n            part1: 'Edit <1>src/App.js</1> and save to reload.',\n            part2: 'Learn React'\n          }\n        }\n      }\n    }\n  });\n\nexport default i18n;\n```\n\n\n### Language Switcher <a name=\"language-switcher\"></a>\n\nNow let's define a language switcher:\n\n```javascript\nimport logo from './logo.svg';\nimport './App.css';\nimport { useTranslation, Trans } from 'react-i18next';\n\nconst lngs = {\n  en: { nativeName: 'English' },\n  de: { nativeName: 'Deutsch' }\n};\n\nfunction App() {\n  const { t, i18n } = useTranslation();\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <div>\n          {Object.keys(lngs).map((lng) => (\n            <button key={lng} style={{ fontWeight: i18n.resolvedLanguage === lng ? 'bold' : 'normal' }} type=\"submit\" onClick={() => i18n.changeLanguage(lng)}>\n              {lngs[lng].nativeName}\n            </button>\n          ))}\n        </div>\n        <p>\n          <Trans i18nKey=\"description.part1\">\n            Edit <code>src/App.js</code> and save to reload.\n          </Trans>\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {t('description.part2')}\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n```\n\nAnd also add some translations for the new language:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\ni18n\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    resources: {\n      en: {\n        translation: {\n          description: {\n            part1: 'Edit <1>src/App.js</1> and save to reload.',\n            part2: 'Learn React'\n          }\n        }\n      },\n      de: {\n        translation: {\n          description: {\n            part1: 'Ändere <1>src/App.js</1> und speichere um neu zu laden.',\n            part2: 'Lerne React'\n          }\n        }\n      }\n    }\n  });\n\nexport default i18n;\n```\n\n![react language switcher](app_1.jpg \"locize © inweso GmbH\")\n\n**🥳 Awesome, you've just created your first language switcher!**\n\nThanks to [i18next-browser-languagedetector](https://github.com/i18next/i18next-browser-languageDetector) now it tries to detect the browser language and automatically use that language if you've provided the translations for it. The manually selected language in the language switcher is persisted in the localStorage, next time you visit the page, that language is used as preferred language.\n\n#### How to get the current language? <a name=\"current-language\"></a>\n\nSince i18next v21 there is [`i18next.resolvedLanguage`](https://www.i18next.com/overview/api#resolvedlanguage).\nIt is set to the current resolved language and it can be used as primary used language, for example in a language switcher.\n\nIf your detected language for example is `en-US` and you provided translations only for `en` *(fallbackLng)* instead `i18next.resolvedLanguage` will return `en`.\n\n##### i18next.language vs. i18next.languages vs. i18next.resolvedLanguage\n\n```javascript\n/* language */\ni18next.language;\n// Is set to the current detected or set language.\n\n/* languages */\ni18next.languages;\n// Is set to an array of language codes that will be used to look up the translation value.\n// When the language is set, this array is populated with the new language codes.\n// Unless overridden, this array is populated with less-specific versions of that code for fallback purposes, followed by the list of fallback languages\n\n// initialize with fallback languages\ni18next.init({\n  fallbackLng: [\"es\", \"fr\", \"en-US\", \"dev\"]\n});\n// change the language\ni18next.changeLanguage(\"en-US-xx\");\n// new language and its more generic forms, followed by fallbacks\ni18next.languages; // [\"en-US-xx\", \"en-US\", \"en\", \"es\", \"fr\", \"dev\"]\n// change the language again\ni18next.changeLanguage(\"de-DE\");\n// previous language is not retained\ni18next.languages; // [\"de-DE\", \"de\", \"es\", \"fr\", \"en-US\", \"dev\"]\n\n/* resolvedLanguage */\ni18next.resolvedLanguage;\n// Is set to the current resolved language.\n// It can be used as primary used language,\n// for example in a language switcher.\n```\n\n### Interpolation and Pluralization <a name=\"interpolation-pluralization\"></a>\n\ni18next goes beyond just providing the standard i18n features.\nBut for sure it's able to handle [plurals](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation).\n\nLet's count each time the language gets changed:\n\n```javascript\nimport logo from './logo.svg';\nimport './App.css';\nimport { useTranslation, Trans } from 'react-i18next';\nimport { useState } from 'react';\n\nconst lngs = {\n  en: { nativeName: 'English' },\n  de: { nativeName: 'Deutsch' }\n};\n\nfunction App() {\n  const { t, i18n } = useTranslation();\n  const [count, setCounter] = useState(0);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <div>\n          {Object.keys(lngs).map((lng) => (\n            <button key={lng} style={{ fontWeight: i18n.resolvedLanguage === lng ? 'bold' : 'normal' }} type=\"submit\" onClick={() => {\n              i18n.changeLanguage(lng);\n              setCounter(count + 1);\n            }}>\n              {lngs[lng].nativeName}\n            </button>\n          ))}\n        </div>\n        <p>\n          <i>{t('counter', { count })}</i>\n        </p>\n        <p>\n          <Trans i18nKey=\"description.part1\">\n            Edit <code>src/App.js</code> and save to reload.\n          </Trans>\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {t('description.part2')}\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n...and extending the translation resources:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\ni18n\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    resources: {\n      en: {\n        translation: {\n          description: {\n            part1: 'Edit <1>src/App.js</1> and save to reload.',\n            part2: 'Learn React'\n          },\n          counter_one: 'Changed language just once',\n          counter_other: 'Changed language already {{count}} times'\n        }\n      },\n      de: {\n        translation: {\n          description: {\n            part1: 'Ändere <1>src/App.js</1> und speichere um neu zu laden.',\n            part2: 'Lerne React'\n          },\n          counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n          counter_other: 'Die Sprache wurde {{count}} mal gewechselt'\n        }\n      }\n    }\n  });\n\nexport default i18n;\n```\n\nBased on the count value i18next will choose the correct plural form.\nRead more about [pluralization](https://www.i18next.com/translation-function/plurals) and [interpolation](https://www.i18next.com/translation-function/interpolation) in the [official i18next documentation](https://www.i18next.com/).\n\n![react pluralization](app_2.jpg \"locize © inweso GmbH\")\n\n*💡 i18next is also able to handle languages with multiple plural forms, like arabic:*\n\n```javascript\n// translation resources:\n{\n  \"key_zero\": \"zero\",\n  \"key_one\": \"singular\",\n  \"key_two\": \"two\",\n  \"key_few\": \"few\",\n  \"key_many\": \"many\",\n  \"key_other\": \"other\"\n}\n\n// usage:\nt('key', {count: 0}); // -> \"zero\"\nt('key', {count: 1}); // -> \"singular\"\nt('key', {count: 2}); // -> \"two\"\nt('key', {count: 3}); // -> \"few\"\nt('key', {count: 4}); // -> \"few\"\nt('key', {count: 5}); // -> \"few\"\nt('key', {count: 11}); // -> \"many\"\nt('key', {count: 99}); // -> \"many\"\nt('key', {count: 100}); // -> \"other\"\n```\n\n#### Why are my plural keys not working? <a name=\"pluralsv4\"></a>\n\nAre you seeing this warning in the development console (`debug: true`)?\n\n> i18next::pluralResolver: Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\n\nWith [v21](https://www.i18next.com/misc/migration-guide#v20.x.x-to-v21.0.0) i18next streamlined the suffix with the one used in the [Intl API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules/PluralRules).\nIn environments where the [Intl.PluralRules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/PluralRules) API  is not available (like older Android devices), you may need to [polyfill](https://github.com/eemeli/intl-pluralrules) the [Intl.PluralRules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/PluralRules) API.\nIn case it is not available it will fallback to the [i18next JSON format v3](https://www.i18next.com/misc/json-format#i-18-next-json-v3) plural handling. And if your json is already using the new suffixes, your plural keys will probably not be shown.\n\n*tldr;*\n\n`npm install intl-pluralrules`\n\n```javascript\nimport 'intl-pluralrules'\n```\n\n\n### Formatting <a name=\"formatting\"></a>\n\nNow, let’s check out how we can use different date formats with the help of [i18next](https://www.i18next.com) and [Luxon](https://moment.github.io/luxon) to handle date and time.\n\n`npm install luxon`\n\nWe like to have a footer displaying the current date:\n\n```javascript\nimport './Footer.css';\n\nconst Footer = ({ t }) => (\n  <div className=\"Footer\">\n    <div>{t('footer.date', { date: new Date() })}</div>\n  </div>\n);\n\nexport default Footer;\n\n// imported in our App.js and used like this\n// <Footer t={t} />\n```\n\nimport luxon and define a format function, like documented in the [documentation](https://www.i18next.com/translation-function/formatting) and add the new translation key:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport { DateTime } from 'luxon';\n\ni18n\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    resources: {\n      en: {\n        translation: {\n          description: {\n            part1: 'Edit <1>src/App.js</1> and save to reload.',\n            part2: 'Learn React'\n          },\n          counter_one: 'Changed language just once',\n          counter_other: 'Changed language already {{count}} times',\n          footer: {\n            date: 'Today is {{date, DATE_HUGE}}'\n          }\n        }\n      },\n      de: {\n        translation: {\n          description: {\n            part1: 'Ändere <1>src/App.js</1> und speichere um neu zu laden.',\n            part2: 'Lerne React'\n          },\n          counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n          counter_other: 'Die Sprache wurde {{count}} mal gewechselt',\n          footer: {\n            date: 'Heute ist {{date, DATE_HUGE}}'\n          }\n        }\n      }\n    }\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\n**😎 Cool, now we have a language specific date formatting!**\n\nEnglish:\n![react english](app_3.jpg \"locize © inweso GmbH\")\n\nGerman:\n![react german](app_4.jpg \"locize © inweso GmbH\")\n\n\n### Context <a name=\"context\"></a>\n\nWhat about a specific greeting message based on the current day time? i.e. morning, evening, etc.\nThis is possible thanks to the [context](https://www.i18next.com/translation-function/context) feature of i18next.\n\nLet's create a `getGreetingTime` function and use the result as context information for our footer translation:\n\n```javascript\nimport { DateTime } from 'luxon';\nimport './Footer.css';\n\nconst getGreetingTime = (d = DateTime.now()) => {\n\tconst split_afternoon = 12; // 24hr time to split the afternoon\n\tconst split_evening = 17; // 24hr time to split the evening\n\tconst currentHour = parseFloat(d.toFormat('hh'));\n\t\n\tif (currentHour >= split_afternoon && currentHour <= split_evening) {\n\t\treturn 'afternoon';\n\t} else if (currentHour >= split_evening) {\n\t\treturn 'evening';\n  }\n\treturn 'morning';\n}\n\nconst Footer = ({ t }) => (\n  <div className=\"Footer\">\n    <div>{t('footer.date', { date: new Date(), context: getGreetingTime() })}</div>\n  </div>\n);\n\nexport default Footer;\n```\n\nAnd add some context specific translations keys:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-http-backend';\nimport { DateTime } from 'luxon';\n\ni18n\n  // i18next-http-backend\n  // loads translations from your server\n  // https://github.com/i18next/i18next-http-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    resources: {\n      en: {\n        translation: {\n          description: {\n            part1: 'Edit <1>src/App.js</1> and save to reload.',\n            part2: 'Learn React'\n          },\n          counter_one: 'Changed language just once',\n          counter_other: 'Changed language already {{count}} times',\n          footer: {\n            date: 'Today is {{date, DATE_HUGE}}',\n            date_morning: 'Good morning! Today is {{date, DATE_HUGE}} | Have a nice day!',\n            date_afternoon: 'Good afternoon! It\\'s {{date, DATE_HUGE}}',\n            date_evening: 'Good evening! Today was the {{date, DATE_HUGE}}'\n          }\n        }\n      },\n      de: {\n        translation: {\n          description: {\n            part1: 'Ändere <1>src/App.js</1> und speichere um neu zu laden.',\n            part2: 'Lerne React'\n          },\n          counter_one: 'Die Sprache wurde erst ein mal gewechselt',\n          counter_other: 'Die Sprache wurde {{count}} mal gewechselt',\n          footer: {\n            date: 'Heute ist {{date, DATE_HUGE}}',\n            date_morning: 'Guten Morgen! Heute ist {{date, DATE_HUGE}} | Wünsche einen schönen Tag!',\n            date_afternoon: 'Guten Tag! Es ist {{date, DATE_HUGE}}',\n            date_evening: 'Guten Abend! Heute war {{date, DATE_HUGE}}'\n          }\n        }\n      }\n    }\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\n**😁 Yeah, It works!**\n\n![react translations](app_5.jpg \"locize © inweso GmbH\")\n\n\n### Separate translations from code <a name=\"separate\"></a>\n\nHaving the translations in our `i18n.js` file works, but is not that suitable to work with, for translators.\nLet's separate the translations from the code and pleace them in dedicated json files.\n\nBecause this is a web application, [i18next-http-backend](https://github.com/i18next/i18next-http-backend) will help us to do so.\n\n`npm install i18next-http-backend`\n\nMove the translations to the public folder:\n\n![public locales](public_locales.jpg \"locize © inweso GmbH\")\n\nAdapt the `i18n.js` file to use the `i18next-http-backend`:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-http-backend';\nimport { DateTime } from 'luxon';\n\ni18n\n  // i18next-http-backend\n  // loads translations from your server\n  // https://github.com/i18next/i18next-http-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    }\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\nNow the translations are loaded asynchronously, so make sure you wrap your app with a [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) component to prevent this error: `Uncaught Error: App suspended while rendering, but no fallback UI was specified.`\n\n```javascript\nimport { Suspense } from 'react';\n\nfunction App() {\n  // your app's code...\n}\n\n// here app catches the suspense from page in case translations are not yet loaded\nexport default function WrappedApp() {\n  return (\n    <Suspense fallback=\"...is loading\">\n      <App />\n    </Suspense>\n  );\n}\n```\n\nNow your app looks still the same, but your translations are separated.\nIf you want to support a new language, you just create a new folder and a new translation json file.\nThis gives you the possibility to send the translations to some translators.\nOr if you're working with a translation management system you can just [synchronize the files with a cli](https://github.com/locize/react-tutorial#use-the-locize-cli).\n\n\n*🧑‍💻 The code of this first part can be found [here](https://github.com/locize/react-i18next-example-app/tree/i18next).*\n\n#### Multiple namespaces <a name=\"multiple-namespaces\"></a>\n\n*💡 btw: you can also have [multiple translation files](https://react.i18next.com/guides/multiple-translation-files) thanks to the [namespaces](https://www.i18next.com/principles/namespaces) feature of i18next*\n\nOne of the advantages of react-i18next is based on i18next, it supports the separation of translations into multiple files - which are called namespaces in i18next.\n\nIn order to use multiple namespaces/translation files, you need to specify it when calling [`useTranslation`](https://react.i18next.com/latest/usetranslation-hook):\n```javascript\nconst { t } = useTranslation(['translation', 'common']);\n// ...\n// t('look.deep', { ns: 'common' })\n```\n\n[`withTranslation`](https://react.i18next.com/latest/withtranslation-hoc):\n```javascript\nwithTranslation(['translation', 'common'])(MyComponent);\n// ...\n// t('look.deep', { ns: 'common' })\n```\n\nor [`Translation`](https://react.i18next.com/latest/translation-render-prop):\n```javascript\n<Translation ns={['translation', 'common']}>\n{\n  (t) => <p>{t('look.deep', { ns: 'common' })}</p>\n}\n</Translation>\n```\n\n### Better translation management <a name=\"better-translation-management\"></a>\n\nBy sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you.\nThis is a traditional way. But be aware sending files around creates always an overhead.\n\n> Does a better option exist?\n\n#### For sure! <a name=\"for-sure\"></a>\n\n[i18next](https://www.i18next.com) helps to get the application translated, and this is great - but there is more to it.\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- How do you deploy translation changes without deploying your complete application?\n- and a lot more...\n\n**Looking for something like this❓**\n\n- [Easy to integrate](https://docs.locize.com/integration/instrumenting-your-code#i-18-next)\n- Continuous deployment? [Continuous localization](https://locize.com/how-it-works.html#continouslocalization)!\n- Manage the translation files with ease\n- [Order professional translations](https://docs.locize.com/guides-tips-and-tricks/working-with-translators)\n- Analytics & Statistics\n- [Profit from our content delivery network (CDN)](https://docs.locize.com/whats-inside/cdn-content-delivery-network)\n- [Versioning of your translations](https://docs.locize.com/more/versioning)\n- [Automatic and On-Demand Machine Translation](https://docs.locize.com/whats-inside/auto-machine-translation)\n- [Riskfree: Take your data with you](https://docs.locize.com/more/general-questions/how-is-locize-different-from-the-alternatives#service-lock-in)\n- [Transparent and fair pricing](https://locize.com/pricing.html)\n- and a lot more...\n\n![transform the localization process](transform_your_localization_process_small.jpg \"locize © inweso GmbH\")\n\n#### How does this look like? <a name=\"how-look\"></a>\n\nFirst you need to signup at [locize](https://locize.app/register) and [login](https://docs.locize.com/integration/getting-started/create-a-user-account).\nThen [create a new project](https://docs.locize.com/integration/getting-started/add-a-new-project) in locize and add your translations. You can add your translations either by using the [cli](https://github.com/locize/react-tutorial#use-the-locize-cli) or by [importing the individual json files](https://docs.locize.com/more/general-questions/how-to-import-translations-from-a-file) or via [API](https://docs.locize.com/integration/api#update-remove-translations).\n\nDone so, we're going to replace [i18next-http-backend](https://github.com/i18next/i18next-http-backend) with [i18next-locize-backend](https://github.com/locize/i18next-locize-backend).\n\n`npm install i18next-locize-backend`\n\nAfter having imported the translations to locize, delete the locales folder:\n\n![public locales removed](public_locales_removed.jpg \"locize © inweso GmbH\")\n\nAdapt the `i18n.js` file to use the `i18next-locize-backend` and make sure you copy the project-id and api-key from within your locize project:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-locize-backend';\nimport { DateTime } from 'luxon';\n\nconst locizeOptions = {\n  projectId: '0bbc223a-9aba-4a90-ab93-ab9d7bf7f780',\n  apiKey: 'aaad4141-54ba-4625-ae37-657538fe29e7', // YOU should not expose your apps API key to production!!!\n  referenceLng: 'en',\n};\n\ni18n\n  // i18next-locize-backend\n  // loads translations from your project, saves new keys to it (saveMissing: true)\n  // https://github.com/locize/i18next-locize-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    backend: locizeOptions\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\n[i18next-locize-backend](https://github.com/locize/i18next-locize-backend) offers a functionality to retrieve the available languages directly from locize, let's use it:\n\n```javascript\nimport logo from './logo.svg';\nimport './App.css';\nimport { useTranslation, Trans } from 'react-i18next';\nimport { useState, Suspense, useEffect } from 'react';\nimport Footer from './Footer'\n\nfunction App() {\n  const { t, i18n } = useTranslation();\n  const [count, setCounter] = useState(0);\n\n  const [lngs, setLngs] = useState({ en: { nativeName: 'English' }});\n\n  useEffect(() => {\n    i18n.services.backendConnector.backend.getLanguages((err, ret) => {\n      if (err) return // TODO: handle err...\n      setLngs(ret);\n    });\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <div>\n          {Object.keys(lngs).map((lng) => (\n            <button key={lng} style={{ fontWeight: i18n.resolvedLanguage === lng ? 'bold' : 'normal' }} type=\"submit\" onClick={() => {\n              i18n.changeLanguage(lng);\n              setCounter(count + 1);\n            }}>\n              {lngs[lng].nativeName}\n            </button>\n          ))}\n        </div>\n        <p>\n          <i>{t('counter', { count })}</i>\n        </p>\n        <p>\n          <Trans i18nKey=\"description.part1\">\n            Edit <code>src/App.js</code> and save to reload.\n          </Trans>\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {t('description.part2')}\n        </a>\n      </header>\n      <Footer t={t} />\n    </div>\n  );\n}\n\n// here app catches the suspense from page in case translations are not yet loaded\nexport default function WrappedApp() {\n  return (\n    <Suspense fallback=\"...is loading\">\n      <App />\n    </Suspense>\n  );\n}\n```\n\n#### save missing translations <a name=\"save-missing\"></a>\n\nThanks to the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys gets added to locize automatically, while developing the app.\n\nJust pass `saveMissing: true` in the i18next options:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-locize-backend';\nimport { DateTime } from 'luxon';\n\nconst locizeOptions = {\n  projectId: '0bbc223a-9aba-4a90-ab93-ab9d7bf7f780',\n  apiKey: 'aaad4141-54ba-4625-ae37-657538fe29e7', // YOU should not expose your apps API key to production!!!\n  referenceLng: 'en',\n};\n\ni18n\n  // i18next-locize-backend\n  // loads translations from your project, saves new keys to it (saveMissing: true)\n  // https://github.com/locize/i18next-locize-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    backend: locizeOptions,\n    saveMissing: true\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\nEach time you'll use a new key, it will be sent to locize, i.e.:\n\n```javascript\n<div>{t('new.key', 'this will be added automatically')}</div>\n```\n\nwill result in locize like this:\n\n![missing key](missing_key.jpg \"locize © inweso GmbH\")\n\n\n#### 👀 but there's more... <a name=\"more\"></a>\n\nThanks to the [locize-lastused](https://github.com/locize/locize-lastused) plugin, you'll be able to [find and filter in locize which keys are used or not used anymore](https://docs.locize.com/guides-tips-and-tricks/unused-translations).\n\nWith the help of the [locize](https://github.com/locize/locize) plugin, you'll be able to use your app within the locize [InContext Editor](https://docs.locize.com/more/incontext-editor).\n\nLastly, with the help of the [auto-machinetranslation workflow](https://docs.locize.com/whats-inside/auto-machine-translation) and the use of the [saveMissing functionality](https://www.i18next.com/overview/configuration-options#missing-keys), new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation.\n\n*Check out this [video](https://youtu.be/VfxBpSXarlU) to see how the automatic machine translation workflow looks like!*\n\n{% youtube VfxBpSXarlU %}\n\n`npm install locize-lastused locize`\n\nuse them in `i18n.js`:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-locize-backend';\nimport LastUsed from 'locize-lastused';\nimport { locizePlugin } from 'locize';\nimport { DateTime } from 'luxon';\n\nconst locizeOptions = {\n  projectId: '0bbc223a-9aba-4a90-ab93-ab9d7bf7f780',\n  apiKey: 'aaad4141-54ba-4625-ae37-657538fe29e7', // YOU should not expose your apps API key to production!!!\n  referenceLng: 'en',\n};\n\ni18n\n  // locize-lastused\n  // sets a timestamp of last access on every translation segment on locize\n  // -> safely remove the ones not being touched for weeks/months\n  // https://github.com/locize/locize-lastused\n  .use(LastUsed)\n  // locize-editor\n  // InContext Editor of locize\n  .use(locizePlugin)\n  // i18next-locize-backend\n  // loads translations from your project, saves new keys to it (saveMissing: true)\n  // https://github.com/locize/i18next-locize-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    backend: locizeOptions,\n    locizeLastUsed: locizeOptions,\n    saveMissing: true\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\n[Automatic machine translation](https://docs.locize.com/whats-inside/auto-machine-translation):\n\n![missing key auto](missing_key_auto_mt.jpg \"locize © inweso GmbH\")\n\n[Last used translations filter]((https://docs.locize.com/guides-tips-and-tricks/unused-translations)):\n\n![i18next last used](last_used.jpg \"locize © inweso GmbH\")\n\n[InContext Editor](https://docs.locize.com/more/incontext-editor):\n\n![i18next incontext](in_context.jpg \"locize © inweso GmbH\")\n\n\n#### 📦 Let's prepare for production 🚀 <a name=\"production\"></a>\n\nNow, we prepare the app for [going to production](https://docs.locize.com/guides-tips-and-tricks/going-production).\n\nFirst in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via [API](https://docs.locize.com/integration/api#publish-version) or via [CLI](https://github.com/locize/locize-cli#publish-version).\nLastly, [enable Cache-Control max-age​](https://docs.locize.com/more/caching) for that production version.\n\nLet's making use of the [environment feature of react-scripts](https://create-react-app.dev/docs/adding-custom-environment-variables/).\n\nLets' create a default environment file and one for development and one for production:\n\n`.env`:\n```\nSKIP_PREFLIGHT_CHECK=true\n\nREACT_APP_VERSION=$npm_package_version\n\n## locize\nREACT_APP_LOCIZE_PROJECTID=0bbc223a-9aba-4a90-ab93-ab9d7bf7f780\nREACT_APP_LOCIZE_REFLNG=en\n```\n\n`.env.development`:\n```\nREACT_APP_LOCIZE_VERSION=latest\nREACT_APP_LOCIZE_APIKEY=aaad4141-54ba-4625-ae37-657538fe29e7\n```\n\n`.env.production`:\n```\nREACT_APP_LOCIZE_VERSION=production\n```\n\nNow let's adapt the `i18n.js` file:\n\n```javascript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Backend from 'i18next-locize-backend';\nimport LastUsed from 'locize-lastused';\nimport { locizePlugin } from 'locize';\nimport { DateTime } from 'luxon';\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nconst locizeOptions = {\n  projectId: process.env.REACT_APP_LOCIZE_PROJECTID,\n  apiKey: process.env.REACT_APP_LOCIZE_APIKEY, // YOU should not expose your apps API key to production!!!\n  referenceLng: process.env.REACT_APP_LOCIZE_REFLNG,\n  version: process.env.REACT_APP_LOCIZE_VERSION\n};\n\nif (!isProduction) {\n  // locize-lastused\n  // sets a timestamp of last access on every translation segment on locize\n  // -> safely remove the ones not being touched for weeks/months\n  // https://github.com/locize/locize-lastused\n  i18n.use(LastUsed);\n}\n\ni18n\n  // locize-editor\n  // InContext Editor of locize\n  .use(locizePlugin)\n  // i18next-locize-backend\n  // loads translations from your project, saves new keys to it (saveMissing: true)\n  // https://github.com/locize/i18next-locize-backend\n  .use(Backend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    debug: true,\n    fallbackLng: 'en',\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n      // format: (value, format, lng) => { // legacy usage\n      //   if (value instanceof Date) {\n      //     return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format])\n      //   }\n      //   return value;\n      // }\n    },\n    backend: locizeOptions,\n    locizeLastUsed: locizeOptions,\n    saveMissing: !isProduction // you should not use saveMissing in production\n  });\n\n// new usage\ni18n.services.formatter.add('DATE_HUGE', (value, lng, options) => {\n  return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime.DATE_HUGE)\n});\n\nexport default i18n;\n```\n\nNow, during development, you'll continue to save missing keys and to make use of lastused feature. => `npm run start`\n\nAnd in production environment, saveMissing and lastused are disabled, and also the api-key is not exposed. => `npm run build && npm run serve`\n\n\n[Caching](https://docs.locize.com/more/caching):\n\n![i18next caching](caching.jpg \"locize © inweso GmbH\")\n\n[Merging versions](https://docs.locize.com/more/versioning#merging-versions):\n\n![overwrite version](overwrite_version.jpg \"locize © inweso GmbH\")\n\n*🧑‍💻 The complete code for this React example can be found [here](https://github.com/locize/react-i18next-example-app). And a TypeScript version [here](https://github.com/locize/react-i18next-example-app-ts).*\n\n*Check also the [code integration part](https://www.youtube.com/watch?v=ds-yEEYP1Ks&t=423s) in this [YouTube video](https://www.youtube.com/watch?v=ds-yEEYP1Ks).*\n\nThere's also an [i18next crash course video](https://youtu.be/SA_9i4TtxLQ).\n{% youtube SA_9i4TtxLQ %}\n\nThere is also a [Spanish translation of this blog post](https://www.ibidem-translations.com/edu/translate-react-i18next-app/).\n\n## 🎉🥳 Congratulations 🎊🎁 <a name=\"congratulations\"></a>\n\nI hope you’ve learned a few new things about [i18next](https://www.i18next.com), [React.js localization](https://react.i18next.com) and [modern localization workflows](https://locize.com).\n\nSo if you want to take your i18n topic to the next level, it's worth trying the [localization management platform - locize](https://locize.com).\n\nThe founders of [locize](https://locize.com) are also the creators of [i18next](https://www.i18next.com). So by using [locize](https://locize.com) you directly support the future of [i18next](https://www.i18next.com).\n\n## 👍\n\n<script type=\"application/ld+json\">\n  {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"FAQPage\",\n    \"mainEntity\": [{\n      \"@type\": \"Question\",\n      \"name\": \"Why i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Sustainability: i18next was created in late 2011. It's older than most of the libraries you will use nowadays, including your main frontend tech (React, Angular, Vue, ...). Maturity: Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. Extensibility: i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. Richness: There is a plenty of features and possibilities you'll get with i18next compared to other regular i18n frameworks.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"How does i18next work?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"image\": \"https://locize.com/img/i18next_how_it_works.png\",\n        \"text\": \"At first, i18next seems to be a simple key/translation dictionary, but in reality it is an elaborated and very extensible i18n framework with a lot of power. It offers translations to be provided from different sources, a language detection, plural form resolutions, caching, post processing, alternative i18n formats and more. You see it does not only offer the standard i18n features, like interpolation, formatting, etc. But the best thing about it is certainly the limitless ecosystem around i18next. We don't know of any other i18n framework with such a large community. That's why we like i18next that much!\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next and how does it work?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"image\": \"https://locize.com/img/i18next_how_it_works.png\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop. At first, i18next seems to be a simple key/translation dictionary, but in reality it is an elaborated and very extensible i18n framework with a lot of power. It offers translations to be provided from different sources, a language detection, plural form resolutions, caching, post processing, alternative i18n formats and more. You see it does not only offer the standard i18n features, like interpolation, formatting, etc. But the best thing about it is certainly the limitless ecosystem around i18next. We don't know of any other i18n framework with such a large community. That's why we like i18next that much!\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What is i18next?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"i18next is an internationalization-framework written in and for JavaScript. But it's much more than that. i18next goes beyond just providing the standard i18n features such as (plurals, context, interpolation, format). It provides you with a complete solution to localize your product from web to mobile and desktop.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"What are the benefits of using i18next over other internationalization libraries?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Lightweight and flexible: i18next is a small library that doesn't require a lot of setup and can be easily integrated with other libraries and frameworks. Support for multiple languages: i18next supports a wide range of languages and provides a simple way to switch between them on the fly. Easy to use API: i18next provides a simple and intuitive API for translating and formatting strings, dates, and numbers. Pluralization and gender handling: i18next provides built-in support for handling pluralization and gender in different languages. Good performance: i18next is designed for performance and provides caching mechanisms to minimize the number of lookups. Active community: i18next has a large and active community of developers who contribute to the library and provide support for new features and bug fixes.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Can i18next be integrated with popular frontend frameworks like React, Vue, and Angular?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, i18next can be integrated with popular frontend frameworks such as React, Vue, and Angular. There are official packages for each framework and community-supported packages available for integration.\"\n      }\n    },{\n      \"@type\": \"Question\",\n      \"name\": \"Can i18next be used for server-side rendering and how does it impact performance?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"Yes, i18next can be used for server-side rendering. Using i18next on the server-side can improve the performance of your website by allowing you to pre-render the internationalized content, which can then be served to the user's browser.\"\n      }\n    }]\n  }\n</script>\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"}]},{"title":"What's new in locize","slug":"new-locize","date":"un33fin33","updated":"un00fin00","comments":true,"path":"new-locize/","link":"","permalink":"https://locize.com/blog/new-locize/","excerpt":"","text":"A lot of work may be virtual now, but that doesn’t mean we’ve slowed down! In fact, we spent the last months working on a new locize version with a bunch of fabulous updates. Here&#39;s a run-down of some of the most important tweaks that make a huge difference. Modernized UIFirst of all, you will notice locize looks different. The layout is a little less angular and a little more rounded. There are more icons and more charts. This makes it look friendlier, simpler, and tidier. The layout is composed by different cards. Each card has optional additional functionality in the top right corder. Different partsThe application was rewritten from the ground up and now splits into two major parts. Project pagesThe project pages consists of details and actions about your versions, languages, namespaces, etc. There&#39;s also an optional card about your orders and another card about your branched projects (crowdbased) We moved everything related to the development to a dedicated page, containing development settings, api keys and relevant metrics. There&#39;s also the possibility to configure a webhook or integrate slack. CAT pagesThe other major part is the new computer aided translation tool – short CAT. The new CAT tool comes with three separate views, for: Global overviewWith global imports and exports, add, copy or delete keys, search and filter. TranslationFocus on translating, assisted by machine translation (MT), smart translation memory (TM), consistency checks, and more. InContext editingThe InContext Editor just needs a little script (locize or locizify) added to your site, so it can exchange information (clicked text, saved changes, etc.). Find more information in the documentationNew featuresThe new locize app does not only come with a new fresh look – but also brings you a ton of new awesome features, like the review workflow or the key history. ReviewYou can enable the review workflow for specific languages. This way each time someone changes a translation, it will start a review workflow. The actual value will not be changed until someone will accept one of the translation proposals. HistoryThe last translation changes are audited per key. SummaryTo make it short – every aspect of the old experience was analyzed and improved to give you an even better experience. The only thing we did not change was the price. You get all the new features without any increase of costs. If you got any questions, feedback or suggestions – we would love to hear from you at support@locize.com.","raw":"---\ntitle: What's new in locize\n\ndate: 2020-12-02\ntags:\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - translation\nthumbnail: new-locize/title.jpg\nredirect_from:\n- /2020-12-02-new-locize\n---\n\n![what is new in locize](title.jpg \"locize © inweso GmbH\")\n\nA lot of work may be virtual now, but that doesn’t mean we’ve slowed down! In fact, we spent the last months working on a new locize version with a bunch of fabulous updates. Here's a run-down of some of the most important tweaks that make a huge difference.\n\n## Modernized UI\nFirst of all, you will notice locize looks different. The layout is a little less angular and a little more rounded.\nThere are more icons and more charts. This makes it look friendlier, simpler, and tidier.\n![overview](overview.jpg \"locize © inweso GmbH\")\n\nThe layout is composed by different cards. Each card has optional additional functionality in the top right corder.\n![card](card.jpg \"locize © inweso GmbH\")\n\n\n## Different parts\nThe application was rewritten from the ground up and now splits into two major parts.\n\n### Project pages\nThe project pages consists of details and actions about your versions, languages, namespaces, etc.\n\nThere's also an optional card about your orders and another card about your branched projects (crowdbased)\n![orders](orders.jpg \"locize © inweso GmbH\")\n![branches](branches.jpg \"locize © inweso GmbH\")\n\nWe moved everything related to the development to a dedicated page, containing development settings, api keys and relevant metrics. There's also the possibility to configure a webhook or integrate slack.\n![dev](dev.jpg \"locize © inweso GmbH\")\n\n### CAT pages\nThe other major part is the new computer aided translation tool – short CAT. The new CAT tool comes with three separate views, for:\n\n### Global overview\nWith global imports and exports, add, copy or delete keys, search and filter.\n![cat-overview](cat-overview.jpg \"locize © inweso GmbH\")\n\n#### Translation\nFocus on translating, assisted by machine translation (MT), smart translation memory (TM), consistency checks, and more.\n![translation](translation.jpg \"locize © inweso GmbH\")\n\n#### InContext editing\nThe InContext Editor just needs a little script ([locize](https://github.com/locize/locize) or [locizify](https://github.com/locize/locizify)) added to your site, so it can exchange information (clicked text, saved changes, etc.).\n![in context editor](incontext.jpg \"locize © inweso GmbH\")\n\n#### [Find more information in the documentation](https://docs.locize.com/different-views)\n\n\n## New features\nThe new locize app does not only come with a new fresh look – but also brings you a ton of new awesome features, like the review workflow or the key history.\n\n### Review\nYou can enable the review workflow for specific languages.\n![set review](set-review.jpg \"locize © inweso GmbH\")\n\nThis way each time someone changes a translation, it will start a review workflow.\nThe actual value will not be changed until someone will accept one of the translation proposals.\n![review](review.jpg \"locize © inweso GmbH\")\n\n### History\nThe last translation changes are audited per key.\n![history](history.jpg \"locize © inweso GmbH\")\n\n\n## Summary\nTo make it short – every aspect of the old experience was analyzed and improved to give you an even better experience.\n\nThe only thing we did not change was the price.\n\nYou get all the new features without any increase of costs.\n\n\n\n*If you got any questions, feedback or suggestions – we would love to hear from you at [support@locize.com](mailto:support@locize.com).*","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"}]},{"title":"A tale of the last 10 years in web development","slug":"a-tale-of-the-last-10-years-in-web-development","date":"un22fin22","updated":"un11fin11","comments":true,"path":"a-tale-of-the-last-10-years-in-web-development/","link":"","permalink":"https://locize.com/blog/a-tale-of-the-last-10-years-in-web-development/","excerpt":"","text":"This is a work of fiction. Names, characters, businesses, places, events, locales, and incidents depicted in this story are either the products of my imagination or used in a fictitious manner. Any resemblance to actual persons, living or dead, or actual events is purely coincidental. An IntroductionThis story is based on a true story of each of us. Over the past 10 years, many web developers have experienced such a journey. Starting from jQuery, passing through Angular, using React and streak Vue. When reading, “darker areas” of the beginnings of single page applications (SPA) are undergone. This can cause unwanted nervous muscle twitches from the past. For risks and side effects read the package leaflet (there is none) and consult your doctor or pharmacist (I don’t know if they could understand). Once upon a time, in spring 2008 in a small company in Sheffield, there was a software developer called Dorian. He was working on a desktop application built with Microsoft .NET.Not far from there, in Rotherham, Shaun worked in a similar company as web developer.Both companies were very similar and sometimes even had the same customers. So it happened that the top management of both companies met and they merged.Patty, who had been promoted to development manager, had the task to assemble a new web development team. After she had already inducted Shaun into her team, she also found Dorian and noticed a possible team change.She beat him an offer and Dorian joined straight the team in Rotherham.For Dorian, professional development with Javascript was something new. He’d learned Javascript during his studies, but he’d used it rather than animate a website.Shaun, on the other hand, even showed him how to handle node.js and linux and mac. Dorian had always only worked with Windows so far. And from Javascript in the backend he was quite astonished and surprised.Patty saw the first weeks relaxed and felt that she was uniting these two, the right thing. Soon it was time to productively implement a new web application. Together, they decided to try to use node.js in the backend and jQuery in the frontend.They did choose jQuery because the support of the community was great, it made DOM manipulation painless, played well with AJAX, made basic animation a piece of cake, had a lot of plug-ins, etc…Since the web application was not only for English speaking users, they used jquery-i18next as an internationalization (i18n) library. To see how this could look like click here. After about 3 to 4 years, the first signs of weakness of the web application began.There were overusing big/clever plugins, had big/complex files and polluted the global namespace.The heavy use of long chains of selectors (“ul#leftnav li p a.current“) made the code brittle.They started to lose track of what’s where because of the neat idea to use .data() to attach data to the DOM elements, to track the page state.Everything started being slow…Patty had new major features in the pipeline. But the team, which had problems to grow, recommended a refactoring phase.Quickly the team got support from 2 freelancers, Serge and Martina. Patty introduced the new ones as “the experts”.Serge and Martina had Angular know-how and persuaded everyone to replace the jQuery solution with Angular.Their arguments sounded promising:Instead of unobtrusive Javascript with selectors, now declarative templates.From semantic HTML, to semantic models. Instead of classic separation of concerns (HTML, CSS, JS), the usage of MVC pattern. No plug-ins but directives. $scope instead of closure.Instead of manual DOM manipulation and binding, modern data binding. Less “spaghetti” code and more dependency injection. From unorganized, to modular service architecture. Because i18next was not only built for jQuery, they could use ng-i18next and at least keep the same configuration and use the same localization files as before! To see how this could look like click here. During the next 3 to 4 years, Patty added more freelancers and contractors to the team.Shaun and Dorian started to recognize that making the simplest features work seems a struggle.There were more and more performance and complexity issues.Directives, services and filters theoretically were available, but ultimately, everything was built around controllers and their two-way bound $scope.Angular seemed to be fine for the beginning, when it was a simple application, but as the frontend application grew in complexity, this led to the scope soup problem amongst other issues.Additionally, the fear of Angular 2’s release was on the horizon. By trying some samples, Shaun said: “Is this still Angular?” In the meantime, the backend had turned into a solid foundation based on DDD, CQRS and event sourcing.During a late-night beer, Dorian told Shaun about React and Redux. He said that when he read about React, Redux and FLUX he immediately felt that this was a natural fit to the existing backend.Finally, they convinced Patty to rewrite the whole frontend with these arguments: Angular was a framework vs. React was a library the more flexible state management with Redux virtual DOM, one-way data flow, PropTypes and a well-defined component lifecycle the obvious natural fit with their backend single source of truth JSX, a natural evolution of Javascript React has faster learning curve. It feels like learning faster. As with the last technology change, this time there was an i18next option. Just used the new react-i18next library and still the same localization files! To see how this could look like click here. Around the year 2018, many freelancers and contractors were no longer in the team. Instead of them now younger developers started to ask for something new… “React is ok, but what’s about Vue?” Shaun and Dorian organized a little technical session and they explained that React and Vue had more similarities than differences: both were fast and lightweight both had a component based architecture both used a virtual DOM both could be dropped into a single HTML file or be a module in a more sophisticated webpack setup both had separate router and state management libraries Long talk short, the session ended with the following sentence by Shaun: “Ok, let’s try to write our web app in Vue and create a PoC…” Whether they’ve really switched to Vue, we do not know, but what we know is that if that’s the case, then they’re sure to use vue-i18next or a similar library. To see how this could look like click here. i18next was right: “learn once — translate everywhere”! Technologies and libraries come and go, but i18next remains! Post-credits sceneThere are voices who say that they have also replaced their i18next-xhr-backend with that of locize. To see how this could look like look at this video.","raw":"---\ntitle: A tale of the last 10 years in web development\n\ndate: 2018-08-28\ntags:\n  - locize\n  - localization\n  - internationalization\n  - web\n  - l10n\n  - i18n\n  - i18next\n\nthumbnail: a-tale-of-the-last-10-years-in-web-development/title.png\n\nredirect_from:\n- /2018-08-28-a-tale-of-the-last-10-years-in-web-development\n---\n\n![web development](title.png \"locize © inweso GmbH\")\n\n> This is a work of fiction. Names, characters, businesses, places, events, locales, and incidents depicted in this story are either the products of my imagination or used in a fictitious manner. Any resemblance to actual persons, living or dead, or actual events is purely coincidental.\n\n## An Introduction\n\nThis story is based on a true story of each of us. Over the past 10 years, many web developers have experienced such a journey. Starting from [jQuery](https://jquery.com/), passing through [Angular](https://angular.io/), using [React](https://reactjs.org/) and streak [Vue](https://vuejs.org/).\n\nWhen reading, “darker areas” of the beginnings of single page applications (SPA) are undergone. This can cause unwanted nervous muscle twitches from the past.\n\nFor risks and side effects read the package leaflet _(there is none)_ and consult your doctor or pharmacist _(I don’t know if they could understand)_.\n\n* * *\n\nOnce upon a time, in spring 2008 in a small company in Sheffield, there was a software developer called Dorian. He was working on a desktop application built with [Microsoft .NET](https://www.microsoft.com/net/download/dotnet-framework-runtime).  \nNot far from there, in Rotherham, Shaun worked in a similar company as web developer.  \nBoth companies were very similar and sometimes even had the same customers. So it happened that the top management of both companies met and they merged.  \nPatty, who had been promoted to development manager, had the task to assemble a new web development team. After she had already inducted Shaun into her team, she also found Dorian and noticed a possible team change.  \nShe beat him an offer and Dorian joined straight the team in Rotherham.  \nFor Dorian, professional development with Javascript was something new. He’d learned Javascript during his studies, but he’d used it rather than animate a website.  \nShaun, on the other hand, even showed him how to handle [node.js](https://nodejs.org/) and linux and mac. Dorian had always only worked with Windows so far. And from Javascript in the backend he was quite astonished and surprised.  \nPatty saw the first weeks relaxed and felt that she was uniting these two, the right thing.\n\nSoon it was time to productively implement a new web application. Together, they decided to try to use [node.js](https://nodejs.org/) in the backend and [jQuery](https://jquery.com/) in the frontend.  \nThey did choose [jQuery](https://jquery.com/) because the support of the community was great, it made DOM manipulation painless, played well with [AJAX](https://en.wikipedia.org/wiki/Ajax_%28programming%29), made basic animation a piece of cake, had a lot of plug-ins, etc…  \nSince the web application was not only for English speaking users, they used [jquery-i18next](https://github.com/i18next/jquery-i18next) as an internationalization (i18n) library.\n\n<script src=\"https://gist.github.com/adrai/14c32d1a5269c03bc42fe0683235296b.js\" alt=\"https://github.com/adrai/i18next-main-differentiator/tree/master/jquery\"></script>\n\n_To see how this could look like click_ [_here_](https://adrai.github.io/i18next-main-differentiator/jquery/)_._\n\n* * *\n\nAfter about 3 to 4 years, the first signs of weakness of the web application began.  \nThere were overusing big/clever plugins, had big/complex files and polluted the global namespace.  \nThe heavy use of long chains of selectors (_“ul#leftnav li p a.current“_) made the code brittle.  \nThey started to lose track of what’s where because of the neat idea to use _.data()_ to attach data to the DOM elements, to track the page state.  \nEverything started being slow…  \nPatty had new major features in the pipeline. But the team, which had problems to grow, recommended a refactoring phase.  \nQuickly the team got support from 2 freelancers, Serge and Martina. Patty introduced the new ones as “the experts”.  \nSerge and Martina had [Angular](https://angular.io/) know-how and persuaded everyone to replace the [jQuery](https://jquery.com/) solution with [Angular](https://angular.io/).  \nTheir arguments sounded promising:  \nInstead of unobtrusive Javascript with selectors, now declarative templates.  \nFrom semantic HTML, to semantic models. Instead of classic separation of concerns (HTML, CSS, JS), the usage of MVC pattern. No plug-ins but directives. _$scope_ instead of closure.  \nInstead of manual DOM manipulation and binding, modern data binding. Less “spaghetti” code and more dependency injection. From unorganized, to modular service architecture.\n\nBecause [i18next](https://www.i18next.com) was not only built for [jQuery](https://jquery.com/), they could use [ng-i18next](https://github.com/i18next/ng-i18next) and at least keep the same configuration and use the same [localization files](https://github.com/adrai/i18next-main-differentiator/tree/master/locales) as before!\n\n<script src=\"https://gist.github.com/adrai/54e3d4b2356dfd6934b4842f7c7b4dfc.js\" alt=\"https://github.com/adrai/i18next-main-differentiator/tree/master/angular\"></script>\n\n_To see how this could look like click_ [_here_](https://adrai.github.io/i18next-main-differentiator/angular/)_._\n\n* * *\n\nDuring the next 3 to 4 years, Patty added more freelancers and contractors to the team.  \nShaun and Dorian started to recognize that making the simplest features work seems a struggle.  \nThere were more and more performance and complexity issues.  \nDirectives, services and filters theoretically were available, but ultimately, everything was built around controllers and their two-way bound _$scope_.  \nAngular seemed to be fine for the beginning, when it was a simple application, but as the frontend application grew in complexity, this led to the [scope soup problem](https://toddmotto.com/no-scope-soup-bind-to-controller-angularjs/) amongst other issues.  \nAdditionally, the fear of [Angular](https://angular.io/) 2’s release was on the horizon. By trying some samples, Shaun said:\n\n> _“Is this still Angular?”_\n\nIn the meantime, the backend had turned into a solid foundation based on DDD, CQRS and event sourcing.  \nDuring a late-night beer, Dorian told Shaun about [React](https://reactjs.org/) and [Redux](https://redux.js.org/). He said that when he read about [React](https://reactjs.org/), [Redux](https://redux.js.org/) and FLUX he immediately felt that this was a natural fit to the existing backend.  \nFinally, they convinced Patty to rewrite the whole frontend with these arguments:\n\n![react](react.gif \"https://blog.gisspan.com\")\n\n\n*   [Angular](https://angular.io/) was a framework vs. [React](https://reactjs.org/) was a library\n*   the more flexible state management with [Redux](https://redux.js.org/)\n*   virtual DOM, one-way data flow, PropTypes and a well-defined component lifecycle\n*   the obvious natural fit with their backend\n*   single source of truth\n*   [JSX](https://jsx.github.io/), a natural evolution of Javascript\n*   [React](https://reactjs.org/) has faster learning curve. It feels like learning faster.\n\nAs with the last technology change, this time there was an [i18next](https://www.i18next.com) option. Just used the new [react-i18next](https://react.i18next.com/) library and still the same [localization files](https://github.com/adrai/i18next-main-differentiator/tree/master/locales)!\n\n\n<script src=\"https://gist.github.com/adrai/78ac88e6dd61b4249c05b535e896de35.js\" alt=\"https://github.com/adrai/i18next-main-differentiator/tree/master/react\"></script>\n\n_To see how this could look like click_ [_here_](https://adrai.github.io/i18next-main-differentiator/react/)_._\n\n* * *\n\nAround the year 2018, many freelancers and contractors were no longer in the team. Instead of them now younger developers started to ask for something new…\n\n> _“_[_React_](https://reactjs.org/) _is ok, but what’s about_ [_Vue_](https://vuejs.org/)_?”_\n\nShaun and Dorian organized a little technical session and they explained that [React](https://reactjs.org/) and [Vue](https://vuejs.org/) had more similarities than differences:\n\n*   both were fast and lightweight\n*   both had a component based architecture\n*   both used a virtual DOM\n*   both could be dropped into a single HTML file or be a module in a more sophisticated [webpack](https://webpack.js.org/) setup\n*   both had separate router and state management libraries\n\nLong talk short, the session ended with the following sentence by Shaun:\n\n> “Ok, let’s try to write our web app in [Vue](https://vuejs.org/) and create a PoC…”\n\nWhether they’ve really switched to [Vue](https://vuejs.org/), we do not know, but what we know is that if that’s the case, then they’re sure to use [vue-i18next](https://github.com/panter/vue-i18next) or a similar library.\n\n<script src=\"https://gist.github.com/adrai/54ccddbabbba736e0460c1f01e546179.js\" alt=\"https://github.com/adrai/i18next-main-differentiator/tree/master/vue\"></script>\n\n_To see how this could look like click_ [_here_](https://adrai.github.io/i18next-main-differentiator/vue/)_._\n\n* * *\n\n[i18next](https://www.i18next.com) was right:\n\n> “learn once — translate everywhere”!\n\n**_Technologies and libraries come and go, but_** [**_i18next_**](https://www.i18next.com) **_remains!_**\n\n#### Post-credits scene\n\nThere are voices who say that they have also replaced their [i18next-xhr-backend](https://github.com/i18next/i18next-xhr-backend) with that of [locize](https://github.com/locize/i18next-locize-backend).\n\n_To see how this could look like look at_ [_this video_](https://youtu.be/kw-GEQbgmSc)[_._](https://youtu.be/kw-GEQbgmSc%29.*)\n\n{% youtube kw-GEQbgmSc %}\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"web","slug":"web","permalink":"https://locize.com/blog/tags/web/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"}]},{"title":"Unleash the hidden superpowers of react-intl","slug":"unleash-the-hidden-superpowers-of-react-intl","date":"un22fin22","updated":"un55fin55","comments":true,"path":"unleash-the-hidden-superpowers-of-react-intl/","link":"","permalink":"https://locize.com/blog/unleash-the-hidden-superpowers-of-react-intl/","excerpt":"","text":"Let images speak to see what you will get: We do not like this clutter:123456const name = &#x27;John Doe&#x27;;&lt;FormattedMessage id=&quot;welcome&quot; defaultMessage=&#123;`Hello &#123;name&#125;!`&#125; values=&#123;&#123; name: &lt;b&gt;&#123;name&#125;&lt;/b&gt; &#125;&#125;/&gt; While react-intl works awesome having those FormattedMessage everywhere does not really help keeping your code nice and readable. Wouldn’t it be nicer you just could write: 1&lt;FormattedMessage id=&quot;welcome&quot;&gt;Hello &lt;b&gt;&#123;name&#125;&lt;/b&gt;!&lt;/FormattedMessage&gt; babel macros to the rescueYou could easily write a babel plugin to transform the above simplified markup to the needed react-intl FormattedMessage. But there is a better way using Kent C. Dodds babel macros (https://github.com/kentcdodds/babel-plugin-macros). There comes a big advantage with using macros (beside they are super simple to create) you can use those with applications created with create-react-app without ejecting (on time of writing needs an alpha build v2.x.x). A babel macro is basically just a function that gets a reference of the nodes using the macro: 12345678910const &#123; createMacro &#125; = require(&#x27;babel-plugin-macros&#x27;)module.exports = createMacro(myMacro)function myMacro(&#123;references, state, babel&#125;) &#123; // the FormattedMessage imported in below code snippet const &#123; FormattedMessage = [] &#125; = references; // transform each occurance FormattedMessage.forEach(referencePath =&gt; &#123; /* transform */ &#125;);&#125; We won’t go through all the details of the macro used to transform the simpler markup — but you can checkout the code here: https://github.com/locize/locize-react-intl-example/blob/master/src/intl.macro.js You can use the macro like: 1234// import the macro componentimport &#123; FormattedMessage &#125; from &quot;./intl.macro&quot;;// and use it&lt;FormattedMessage id=&quot;welcome&quot;&gt;Hello &lt;b&gt;&#123;name&#125;&lt;/b&gt;!&lt;/FormattedMessage&gt; The macro will transform it to the react-intl FormattedMessage: 12345&lt;FormattedMessage id=&quot;welcome&quot; defaultMessage=&#123;`Hello &#123;name&#125;!`&#125; values=&#123;&#123; name: &lt;b&gt;&#123;name&#125;&lt;/b&gt; &#125;&#125;/&gt; Plurals and SelectWe could add some more macro magic to also simpler plurals and selects: 1234567891011121314151617181920212223242526272829import &#123; Select, Plural &#125; from &quot;./intl.macro&quot;;// select&lt;FormattedMessage id=&quot;avoid_bugs&quot; defaultMessage=&quot;&#123;gender,select,he&#123;He avoids bugs.&#125;she&#123;She avoids bugs.&#125;other&#123;They avoid bugs.&#125;&#125;&quot; values=&#123;&#123; count: 10 &#125;&#125;/&gt;// will become&lt;Select id=&quot;avoid_bugs&quot; switch=&#123;gender&#125; male=&quot;He avoids bugs.&quot; female=&quot;She avoids bugs.&quot; other=&quot;They avoid bugs.&quot;/&gt;// plurals&lt;FormattedMessage id=&quot;items_count&quot; defaultMessage=&quot;&#123;count,plural,=0&#123;There is no item.&#125;one&#123;There is # item.&#125;other&#123;There are # items.&#125;&#125;&quot; values=&#123;&#123; count: 10 &#125;&#125;/&gt;// will become:&lt;Plural id=&quot;items_count&quot; count=&#123;itemsCount1&#125; $0=&quot;There is no item.&quot; one=&quot;There is # item.&quot; other=&quot;There are # items.&quot;/&gt; For more options (like nesting components) have a look at the sample usages: https://github.com/locize/locize-react-intl-example/blob/master/src/ComponentUsingMacro.js Now after adopting all the features of the demo project you will be able to: split translations into multiple files using an in-context editor loading translations from CDN detecting the user language automatically add new missing strings to your translation project updating changed strings in reference language submitting the description to translation context setting last used information so you can safely remove keys not used any longer From internationalization to localizationWhile the first part focused on helping developers writing nicer jsx markup we now will focus on helping your translators by making their work easier. One of the most important things in our fast-paced times is implementing a fast feedback loop, which is also recommended by all the common “Agile” methodologies. So let’s go a step further: From internationalization to continuous localizationWe like to innovate the localization process by breaking the old slow loop of exporting extracted translations, passing them to translators and importing them back again. This old process does not fit into a modern development environment using continuous development and agile methods. What we want: New content in your application should be immediately available in your translation management tool for your translators and newly finished translations should be passed down to the application without a developer needing to add a file to the repository or accepting a PR from the translation management. Connecting your application to your translation managementIn this sample we will use https://locize.com as our translation management tool — as it exposes all the needed functionality to bring localization to the level of continuous localization. There is the locizer script available to connect your application with the translation project: https://github.com/locize/locizer With it you can load translation files, save or update translation segments. Step 1: We need a way to extend react-intl components during developmentThis should be rather easy: 12345import &#123; FormattedMessage as FM &#125; from &#x27;react-intl&#x27;;// find out if our react app runs in dev modeconst IS_DEV = !process.env.NODE_ENV || process.env.NODE_ENV === &#x27;development&#x27;;// export a extended replacer component while development and original while in productionexport const FormattedMessage = IS_DEV ? supportLocize()(FM) : FM; Now let’s learn what the supportLocize() is: Step 2: Let the component send new content to the translation serviceIn our code we have FormattedMessages like in regular react-intl projects but we consume our overridden component during development: 123456789101112// see ./locize/index.js in development mode the// react-intl components are extended to provide// features like save of new ids, ...// in production you get the regular unextended// react-intl componentsimport &#123; FormattedMessage &#125; from &#x27;locize&#x27;;&lt;FormattedMessage id=&quot;app.title&quot; defaultMessage=&quot;Welcome to &#123;what&#125; combined with locize&quot; description=&quot;Welcome header on app main page&quot; values=&#123;&#123; what: &#x27;react-intl&#x27; &#125;&#125;/&gt; Our extended component will take those props and create new translation segments on locize using the id and defaultMessage 1234567891011121314151617181920212223242526272829303132// a hoc to extend components with locize featuresfunction supportLocize() &#123; return function Wrapper(WrappedComponent) &#123; class LocizeExtension extends Component &#123; constructor(props, context) &#123; super(props, context); // get needed props const &#123; id, defaultMessage, description, namespace &#125; = props; // get current value in message catalog const currentValue = translations[currentLocale] &amp;&amp; translations[currentLocale][namespace] &amp;&amp; translations[currentLocale][namespace][id] // depeding on not yet exists or changed // save or update the value on locize if (SAVE_NEW_VALUES &amp;&amp; !currentValue) &#123; locizer.add(namespace, id, defaultMessage, description); &#125; else if (UPDATE_VALUES &amp;&amp; currentValue !== defaultMessage) &#123; locizer.update(namespace, id, defaultMessage, description) &#125; &#125; // render the wrapped component (react-intl&#x27;s FormattedMessage) render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125; return withContext()(LocizeExtension); &#125;&#125; Based on the defaultMessage already exists in the translations catalog or not, or the defaultMessage has changed we use the locizer functions to create or update the translation segment in the source language. Awesome, now every time we add a new FormattedMessage or change a defaultMessage those values get added or changed in your translation project immediately. Step 3: Directly load translationsBy overriding the IntlProvider we could use the locizer script to directly load the translations that get published to the localization CDN provided by locize. What the component basically does is taking a prop namespace to load the translation file and the needed intl locale-data: 12345678910111213141516// load the given file form locize// and detect language while doing solocizer.load(namespace, (err, messages, locale) =&gt; &#123; currentLocale = locale; translations[locale] = messages;// load react intl locale data import(&#x27;react-intl/locale-data/&#x27; + locale) .then(localeData =&gt; &#123; addLocaleData(localeData);// update state to render children this.setState(&#123; locale, messages &#125;); &#125;);&#125;); The full code is very simple you can find the demo repository here: https://github.com/locize/locize-react-intl-example/blob/master/src/locize/index.js#L32 So this not only enables us to load one translation catalog, but by using that IntlProvider we could load multiple files and making translation a lot easier by splitting them into multiple smaller files. Step 4: Enable translations inside the context of your application The integration of the locize editor is very simple: 1234567locizeEditor.init(&#123; lng: locale, defaultNS: DEFAULTNAMESPACE, referenceLng: REFERENCELANGUAGE, projectId: PROJECTID, private: PRIVATE&#125;); Now you can open your website appending the querystring param ?locize=true and you will see the in-context editor. SummaryYou see internationalization is done rather easily and localization hasn’t to be harder. With the right tools you can not only keep your development — translation cycle short but you can also improve the quality, save time and money. You can find the full sample here: https://github.com/locize/locize-react-intl-example Take the chance and try it yourself locize.com comes with a 14 day free trial.","raw":"---\ntitle: Unleash the hidden superpowers of react-intl\ndate: 2018-08-21\ntags:\n  - i18next\n  - react\n  - react-intl\n  - formatjs\n  - locize\n  - localization\n  - internationalization\n  - translation\nthumbnail: unleash-the-hidden-superpowers-of-react-intl/title.png\n---\n\n![](title.png \"locize © inweso GmbH\")\n\nLet images speak to see what you will get:\n\n![](result.png \"locize © inweso GmbH\")\n\n## We do not like this clutter:\n\n```js\nconst name = 'John Doe';\n<FormattedMessage\n   id=\"welcome\"\n   defaultMessage={`Hello {name}!`}\n   values={{ name: <b>{name}</b> }}\n/>\n```\n\nWhile react-intl works awesome having those FormattedMessage everywhere does not really help keeping your code nice and readable. Wouldn’t it be nicer you just could write:\n\n```js\n<FormattedMessage id=\"welcome\">Hello <b>{name}</b>!</FormattedMessage>\n```\n\n## babel macros to the rescue\n\nYou could easily write a babel plugin to transform the above simplified markup to the needed react-intl FormattedMessage. But there is a better way using \nKent C. Dodds babel macros (https://github.com/kentcdodds/babel-plugin-macros). There comes a big advantage with using macros (beside they are super simple to create) you can use those with applications created with [create-react-app](https://github.com/facebook/create-react-app) without ejecting (on time of writing needs an alpha build v2.x.x).\n\nA babel macro is basically just a function that gets a reference of the nodes using the macro:\n\n```js\nconst { createMacro } = require('babel-plugin-macros')\n\nmodule.exports = createMacro(myMacro)\n\nfunction myMacro({references, state, babel}) {\n  // the FormattedMessage imported in below code snippet\n  const { FormattedMessage = [] } = references;\n  // transform each occurance\n  FormattedMessage.forEach(referencePath => { /* transform */ });\n}\n```\n\nWe won’t go through all the details of the macro used to transform the simpler markup — but you can checkout the code here:\n\n>https://github.com/locize/locize-react-intl-example/blob/master/src/intl.macro.js\n\nYou can use the macro like:\n\n```js\n// import the macro component\nimport { FormattedMessage } from \"./intl.macro\";\n// and use it\n<FormattedMessage id=\"welcome\">Hello <b>{name}</b>!</FormattedMessage>\n```\n\nThe macro will transform it to the react-intl FormattedMessage:\n\n```js\n<FormattedMessage\n   id=\"welcome\"\n   defaultMessage={`Hello {name}!`}\n   values={{ name: <b>{name}</b> }}\n/>\n```\n\n## Plurals and Select\n\nWe could add some more macro magic to also simpler plurals and selects:\n\n```js\nimport { Select, Plural } from \"./intl.macro\";\n// select\n<FormattedMessage\n  id=\"avoid_bugs\"\n  defaultMessage=\"{gender,select,he{He avoids bugs.}she{She avoids bugs.}other{They avoid bugs.}}\"\n  values={{ count: 10 }}\n/>\n// will become\n<Select\n  id=\"avoid_bugs\"\n  switch={gender}\n  male=\"He avoids bugs.\"\n  female=\"She avoids bugs.\"\n  other=\"They avoid bugs.\"\n/>\n// plurals\n<FormattedMessage\n  id=\"items_count\"\n  defaultMessage=\"{count,plural,=0{There is no item.}one{There is # item.}other{There are # items.}}\"\n  values={{ count: 10 }}\n/>\n// will become:\n<Plural\n  id=\"items_count\"\n  count={itemsCount1}\n  $0=\"There is no item.\"\n  one=\"There is # item.\"\n  other=\"There are # items.\"\n/>\n```\n\nFor more options (like nesting components) have a look at the sample usages:\n\n>https://github.com/locize/locize-react-intl-example/blob/master/src/ComponentUsingMacro.js\n\n---\n\n![](locize_editor.png)\n\nNow after adopting all the features of the [demo project](https://github.com/locize/locize-react-intl-example) you will be able to:\n\n- split translations into multiple files\n- using an in-context editor\n- loading translations from CDN\n- detecting the user language\n- automatically add new missing strings to your translation project\n- updating changed strings in reference language\n- submitting the description to translation context\n- setting last used information so you can safely remove keys not used any longer\n\n## From internationalization to localization\n\nWhile the first part focused on helping developers writing nicer jsx markup we now will focus on helping your translators by making their work easier. One of the most important things in our fast-paced times is implementing a fast feedback loop, which is also recommended by all the common “Agile” methodologies.\n\nSo let’s go a step further:\n\n## From internationalization to continuous localization\n\nWe like to innovate the localization process by breaking the old slow loop of exporting extracted translations, passing them to translators and importing them back again. This old process does not fit into a modern development environment using continuous development and agile methods.\n\n**What we want:** New content in your application should be immediately available in your translation management tool for your translators and newly finished translations should be passed down to the application without a developer needing to add a file to the repository or accepting a PR from the translation management.\n\n## Connecting your application to your translation management\n\nIn this sample we will use https://locize.com as our translation management tool — as it exposes all the needed functionality to bring localization to the level of continuous localization.\n\nThere is the locizer script available to connect your application with the translation project: https://github.com/locize/locizer\n\nWith it you can load translation files, save or update translation segments.\n\n### Step 1: We need a way to extend react-intl components during development\n\nThis should be rather easy:\n\n```js\nimport { FormattedMessage as FM } from 'react-intl';\n// find out if our react app runs in dev mode\nconst IS_DEV = !process.env.NODE_ENV || process.env.NODE_ENV === 'development';\n// export a extended replacer component while development and original while in production\nexport const FormattedMessage = IS_DEV ? supportLocize()(FM) : FM;\n```\n\nNow let’s learn what the supportLocize() is:\n\n### Step 2: Let the component send new content to the translation service\n\nIn our code we have FormattedMessages like in regular react-intl projects but we consume our overridden component during development:\n\n```js\n// see ./locize/index.js in development mode the\n// react-intl components are extended to provide\n// features like save of new ids, ...\n// in production you get the regular unextended\n// react-intl components\nimport { FormattedMessage } from 'locize';\n<FormattedMessage\n  id=\"app.title\"\n  defaultMessage=\"Welcome to {what} combined with locize\"\n  description=\"Welcome header on app main page\"\n  values={{ what: 'react-intl' }}\n/>\n```\n\nOur extended component will take those props and create new translation segments on locize using the *id* and *defaultMessage*\n\n```js\n// a hoc to extend components with locize features\nfunction supportLocize() {\n  return function Wrapper(WrappedComponent) {\n\n    class LocizeExtension extends Component {\n      constructor(props, context) {\n        super(props, context);\n\n        // get needed props\n        const { id, defaultMessage, description, namespace } = props;\n\n        // get current value in message catalog\n        const currentValue = translations[currentLocale] && translations[currentLocale][namespace] && translations[currentLocale][namespace][id]\n\n        // depeding on not yet exists or changed\n        // save or update the value on locize\n        if (SAVE_NEW_VALUES && !currentValue) {\n          locizer.add(namespace, id, defaultMessage, description);\n        } else if (UPDATE_VALUES && currentValue !== defaultMessage) {\n          locizer.update(namespace, id, defaultMessage, description)\n        }\n      }\n\n      // render the wrapped component (react-intl's FormattedMessage)\n      render() {\n        return <WrappedComponent {...this.props} />\n      }\n    }\n\n    return withContext()(LocizeExtension);\n  }\n}\n```\n\nBased on the defaultMessage already exists in the translations catalog or not, or the defaultMessage has changed we use the locizer functions to create or update the translation segment in the source language.\n\nAwesome, now every time we add a new `FormattedMessage` or change a `defaultMessage` those values get added or changed in your translation project immediately.\n\n### Step 3: Directly load translations\n\nBy overriding the `IntlProvider` we could use the [locizer](https://github.com/locize/locizer) script to directly load the translations that get published to the localization CDN provided by [locize](https://locize.com).\n\nWhat the component basically does is taking a prop namespace to load the translation file and the needed intl locale-data:\n\n```js\n// load the given file form locize\n// and detect language while doing so\nlocizer.load(namespace, (err, messages, locale) => {\n  currentLocale = locale;\n  translations[locale] = messages;\n// load react intl locale data\n  import('react-intl/locale-data/' + locale)\n    .then(localeData => {\n      addLocaleData(localeData);\n// update state to render children\n      this.setState({\n        locale,\n        messages\n      });\n    });\n});\n```\n\nThe full code is very simple you can find the demo repository here: https://github.com/locize/locize-react-intl-example/blob/master/src/locize/index.js#L32\n\nSo this not only enables us to load one translation catalog, but by using that IntlProvider we could load multiple files and making translation a lot easier by splitting them into multiple smaller files.\n\n### Step 4: Enable translations inside the context of your application\n\n![](locize_editor.png)\n\nThe integration of the locize editor is very simple:\n\n```js\nlocizeEditor.init({\n  lng: locale,\n  defaultNS: DEFAULTNAMESPACE,\n  referenceLng: REFERENCELANGUAGE,\n  projectId: PROJECTID,\n  private: PRIVATE\n});\n```\n\nNow you can open your website appending the querystring param `?locize=true` and you will see the in-context editor.\n\n## Summary\n\nYou see internationalization is done rather easily and localization hasn’t to be harder. With the right tools you can not only keep your development — translation cycle short but you can also improve the quality, save time and money.\n\nYou can find the full sample here: https://github.com/locize/locize-react-intl-example\n\nTake the chance and try it yourself [locize.com](https://locize.com) comes with a 14 day free trial.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"formatjs","slug":"formatjs","permalink":"https://locize.com/blog/tags/formatjs/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-intl","slug":"react-intl","permalink":"https://locize.com/blog/tags/react-intl/"}]},{"title":"vue.js - from internationalization (i18n) to localization (l10n) and back again","slug":"vue-js-from-internationalization-i18n-to-localization-l10n-and-back-again","date":"un44fin44","updated":"un66fin66","comments":true,"path":"vue-js-from-internationalization-i18n-to-localization-l10n-and-back-again/","link":"","permalink":"https://locize.com/blog/vue-js-from-internationalization-i18n-to-localization-l10n-and-back-again/","excerpt":"","text":"What is internationalization?!? Internationalization is the designing of a product in such a way that it will meet the needs of users in many countries or can be easily adapted to do so. Internationalization might mean designing a website so that when it is translated from English to Spanish the layout still works — many words in Spanish have more characters and therefore take up more space on the page in Spanish than in English. quote by: https://www.investopedia.com/terms/i/internationalization.asp Open Source to the rescueThanks to the restless open source community you won’t have to reinvent an i18n solution. Just to give you an idea let’s mention two mature solutions to translate your vue.js app here: vue-i18n by kazuya kawaguchi (@kazupon on github) Made by @kazupon a core contributor of vue.js Easy to get started with powerful enough for most use cases (lacks some features like proper pluralization for - languages having multiple pluralforms or possibility for gender specific translations) learn more reading the documentation vue-i18next by Claudio Romano (@panter on github) based on i18next: learn once — translate everywhere extendable, powerful i18n features plugins for language detection, loading, caching, … learn more reading the documentation and the i18next documentation for translation functionalities like plural, context, … From internationalization to localizationAs you can see in the getting started guide of vue-i18n making your vue.js application fit for translation is not as daunting as it seemed first. Honestly it’s rather easy. Now let us show you how easy the next step could be doing the same for localization. After enabling the developers it’s time to enable your localization team to translate your product. Step 1: Creating a fast translation loop — continuous localizationOur goal is to extend vue-i18n to to use it’s existing missing function to directly send new texts to the translation managment tool and to directly load translations from there. This enables the localization team / translators to start with translations immediately plus keeps a fast feedback loop by having the translations in development without having to export and copy those files from the translation management to the codebase. To make this magic happen we will use locize.com as our weapon of choice: locize is a new online service that offers true continuous localization. quote by: https://alternativeto.net/software/locize/ It’s time for some code — show me your code First we will need to add the provided locizer script to our page to connect the locize translation management with our code: 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=”https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=”https://unpkg.com/vue-i18n/dist/vue-i18n.js&quot;&gt;&lt;/script&gt; &lt;script src=”https://unpkg.com/locizer/locizer.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;!-- ... Now let’s use the new script to automatically detect the user language and to load the translations from locize: 123456789101112131415161718192021&lt;script&gt;locizer .init(&#123; fallbackLng: &#x27;en&#x27;, // load this if detected lng is not support referenceLng: &#x27;en&#x27;, // the source language projectId: [PROJECTID], // your locize project id apiKey: [APIKEY] // your locize api key &#125;) .load(&#x27;translations&#x27;, (err, translations, detectedLng) =&gt; &#123; // build message catalog format var messages = &#123;&#125;; messages[detectedLng] = translations;// Create VueI18n instance with options const i18n = new VueI18n(&#123; locale: detectedLng, // set locale messages: messages, // set locale messages &#125;)// Create a Vue instance with `i18n` option new Vue(&#123; i18n &#125;).$mount(&#x27;#app&#x27;) &#125;)&lt;/script&gt; So now we’re already loading the translations from the locize CDN directly from our project. To switch language only append ?lng=[yourLanguage] to your url (for more options have a look detection options). Our translators could easily add new languages, translate the content or change existing content. Time to have new paths sent to locize automatically Just use the existing missing function of vue-i18n and pipe that call to the locizer script: 123456789// Create VueI18n instance with optionsconst i18n = new VueI18n(&#123; locale: detectedLng, // set locale messages: messages, // set locale messages missing: function(locale, path, vue) &#123; // pipe to locize - that key will be created for you locizer.add(&#x27;translations&#x27;, path, path); &#125;&#125;) Awesome. Now we have our code connected with our translation management. Developers could create new content that is automatically passed to the translation management. Translators could do their job without having to beg for latest source files and do not need to send latest translations to development and wait for those files to be integrated into the latest build. The power of true continuous localization Step 2: Enable translations to be in high qualityLocalization is hard. Even harder if you have to guess the context during translations. So lets improve this by enabling translations directly inside your vue.js app. To add the incontext editor we will need to add an additional script first: 1&lt;script src=&quot;https://unpkg.com/locize-editor/locize-editor.js&quot;&gt;&lt;/script&gt; A little configuration: 123456locizeEditor.init(&#123; lng: detectedLng, defaultNS: &#x27;translations&#x27;, referenceLng: &#x27;en&#x27;, projectId: [PROJECTID]&#125;) Now open your website with ?locize=true and you will see the incontext editor. While turned on you can click on any text element on your page to directly jump to it and make the initial translation or the changes needed. SummaryYou see internationalization is done rather easily and localization hasn’t to be harder. With the right tools you can not only keep your development — translation cycle short but you can also improve the quality, save time and money. You can find the full sample here: https://github.com/locize/locize-vue-i18n-example Take the chance and try it yourself locize.com comes with a 14 day free trial. Prefer using vue-i18next? Doing the same is easier by just using the i18next plugin system. Simply add https://github.com/locize/i18next-locize-backend and the editor https://github.com/locize/locize-editor to i18next. DONE.","raw":"---\ntitle: vue.js - from internationalization (i18n) to localization (l10n) and back again\ndate: 2018-07-05\ntags:\n  - vue\n  - vue-i18n\n  - vue-i18next\n  - i18n\n  - l10n\n  - locize\n  - localization\n  - internationalization\n  - translation\nthumbnail: vue-js-from-internationalization-i18n-to-localization-l10n-and-back-again/title.jpeg\n---\n\n![](title.jpeg \"locize © inweso GmbH\")\n\n## What is internationalization?!?\n\n>Internationalization is the designing of a product in such a way that it will meet the needs of users in many countries or can be easily adapted to do so. Internationalization might mean designing a website so that when it is translated from English to Spanish the layout still works — many words in Spanish have more characters and therefore take up more space on the page in Spanish than in English.\n\n*quote by: https://www.investopedia.com/terms/i/internationalization.asp*\n\n## Open Source to the rescue\n\nThanks to the restless open source community you won’t have to reinvent an i18n solution. Just to give you an idea let’s mention two mature solutions to translate your vue.js app here:\n\n[vue-i18n](https://github.com/kazupon/vue-i18n) by kazuya kawaguchi (@kazupon on github)\n\n- Made by @kazupon a core contributor of vue.js\n- Easy to get started with\n- powerful enough for most use cases *(lacks some features like proper pluralization for - languages having multiple pluralforms or possibility for gender specific translations)*\n- learn more reading the [documentation](https://kazupon.github.io/vue-i18n/)\n\n[vue-i18next](https://github.com/panter/vue-i18next/commits/master) by Claudio Romano (@panter on github)\n\n- based on [i18next](https://www.i18next.com): learn once — translate everywhere\n- extendable, powerful i18n features\n- plugins for language detection, loading, caching, …\n- learn more reading the [documentation](https://github.com/panter/vue-i18next) and the [i18next documentation](https://www.i18next.com/translation-function/essentials) for translation functionalities like plural, context, …\n\n## From internationalization to localization\n\nAs you can see in the [getting started guide](https://kazupon.github.io/vue-i18n/guide/started.html) of vue-i18n making your vue.js application fit for translation is not as daunting as it seemed first. Honestly it’s rather easy.\n\nNow let us show you how easy the next step could be doing the same for localization.\n\n>After enabling the developers it’s time to enable your localization team to translate your product.\n\n### Step 1: Creating a fast translation loop — continuous localization\n\nOur goal is to extend vue-i18n to to use it’s existing missing function to directly send new texts to the translation managment tool and to directly load translations from there.\n\nThis enables the localization team / translators to start with translations immediately plus keeps a fast feedback loop by having the translations in development without having to export and copy those files from the translation management to the codebase.\n\nTo make this magic happen we will use [locize.com](https://locize.com) as our weapon of choice:\n\n>locize is a new online service that offers true continuous localization.\n\n*quote by: https://alternativeto.net/software/locize/*\n\n>It’s time for some code — show me your code\n\nFirst we will need to add the provided [locizer script](https://github.com/locize/locizer) to our page to connect the locize translation management with our code:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=”https://unpkg.com/vue/dist/vue.js\"></script>\n    <script src=”https://unpkg.com/vue-i18n/dist/vue-i18n.js\"></script> \n    <script src=”https://unpkg.com/locizer/locizer.min.js\"></script>\n  </head>\n<!-- ...\n```\n\nNow let’s use the new script to automatically detect the user language and to load the translations from locize:\n\n```html\n<script>\nlocizer\n  .init({\n    fallbackLng: 'en', // load this if detected lng is not support\n    referenceLng: 'en', // the source language\n    projectId: [PROJECTID], // your locize project id\n    apiKey: [APIKEY] // your locize api key\n  })\n  .load('translations', (err, translations, detectedLng) => {\n     // build message catalog format\n     var messages = {};\n     messages[detectedLng] = translations;\n// Create VueI18n instance with options\n     const i18n = new VueI18n({\n       locale: detectedLng, // set locale\n       messages: messages, // set locale messages\n     })\n// Create a Vue instance with `i18n` option\n     new Vue({ i18n }).$mount('#app')\n  })\n</script>\n```\n\nSo now we’re already loading the translations from the locize CDN directly from our project. To switch language only append `?lng=[yourLanguage]` to your url (for more options have a look [detection options](https://github.com/locize/locizer#init-options)).\n\n![](locize_editor.png)\n\nOur translators could easily add new languages, translate the content or change existing content.\n\n>Time to have new paths sent to locize automatically\n\nJust use the existing missing function of vue-i18n and pipe that call to the locizer script:\n\n```js\n// Create VueI18n instance with options\nconst i18n = new VueI18n({\n  locale: detectedLng, // set locale\n  messages: messages, // set locale messages\n  missing: function(locale, path, vue) {\n    // pipe to locize - that key will be created for you\n    locizer.add('translations', path, path);\n  }\n})\n```\n\nAwesome. Now we have our code connected with our translation management. Developers could create new content that is automatically passed to the translation management. Translators could do their job without having to beg for latest source files and do not need to send latest translations to development and wait for those files to be integrated into the latest build.\n\n>The power of true continuous localization\n\n### Step 2: Enable translations to be in high quality\n\nLocalization is hard. Even harder if you have to guess the context during translations. So lets improve this by enabling translations directly inside your vue.js app.\n\n![](locize_editor2.png)\n\nTo add the incontext editor we will need to add an additional script first:\n\n```html\n<script src=\"https://unpkg.com/locize-editor/locize-editor.js\"></script>\n```\n\nA little configuration:\n\n```js\nlocizeEditor.init({\n  lng: detectedLng,\n  defaultNS: 'translations',\n  referenceLng: 'en',\n  projectId: [PROJECTID]\n})\n```\n\nNow open your website with `?locize=true` and you will see the incontext editor. While turned on you can click on any text element on your page to directly jump to it and make the initial translation or the changes needed.\n\n## Summary\n\nYou see internationalization is done rather easily and localization hasn’t to be harder. With the right tools you can not only keep your development — translation cycle short but you can also improve the quality, save time and money.\n\n**You can find the full sample here:** https://github.com/locize/locize-vue-i18n-example\n\nTake the chance and try it yourself [locize.com](https://locize.com) comes with a 14 day free trial.\n\n**Prefer using vue-i18next?**\n\nDoing the same is easier by just using the i18next plugin system. Simply add https://github.com/locize/i18next-locize-backend and the editor https://github.com/locize/locize-editor to i18next. DONE.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"vue","slug":"vue","permalink":"https://locize.com/blog/tags/vue/"},{"name":"vue-i18n","slug":"vue-i18n","permalink":"https://locize.com/blog/tags/vue-i18n/"},{"name":"vue-i18next","slug":"vue-i18next","permalink":"https://locize.com/blog/tags/vue-i18next/"}]},{"title":"locize - Translation Software Distinguished by Platform for SaaS Reviews as a Great User Experience and Rising Star for 2018","slug":"locize-double-win-2018-for-translation-software","date":"un11fin11","updated":"un55fin55","comments":true,"path":"locize-double-win-2018-for-translation-software/","link":"","permalink":"https://locize.com/blog/locize-double-win-2018-for-translation-software/","excerpt":"","text":"Efficient localization need not to be expensive, disorganized, and time-consuming for development and localization teams. We designed locize with this core ideas in mind, and a popular software review platform has recently recognized our efforts and affirmed that we have succeeded in our endeavor. FinancesOnline recently distinguished locize with the Great User Experience and Rising Star awards for 2018 due to our localization and internationalization software’s capability to satisfy the large demands of global businesses. locize earned FinancesOnline’s Great User Experience award under their best translation software for our offering an incredibly pleasing to use software for continuously localizing all kinds of languages and software. Project versioning for easy tracking of file changes, multiple file management and project progress tracking through the dashboard, and third-party integrations are some of the factors that contributed to this award. Their experts also praised our platform’s flexibility and responsiveness reflecting all translations on one’s website by simply embedding a single line of code, a feature that makes locize among the best translation software competitors. This also negates the need for manual inputting of all translations. The FinancesOnline review team also regarded locize as a Rising Star for 2018 due to our highly positive traction with clients. It isn’t a surprise to see our software receive this distinction after FinancesOnline wrote positive remarks in their locize review such as “cost-effective”, “always safe” content thanks to our two-factor authentication, and accelerated and streamlined localization processes.","raw":"---\ntitle: locize - Translation Software Distinguished by Platform for SaaS Reviews as a Great User Experience and Rising Star for 2018\n\ndate: 2018-04-30\ntags:\n  - locize\n  - award\n  - continuous localization\nthumbnail: locize-double-win-2018-for-translation-software/title.png\nredirect_from:\n- /2018-04-30-locize-double-win-2018-for-translation-software\n---\n\nEfficient localization need not to be expensive, disorganized, and time-consuming for development and localization teams. We designed locize with this core ideas in mind, and a popular software review platform has recently recognized our efforts and affirmed that we have succeeded in our endeavor. FinancesOnline recently distinguished [locize](https://reviews.financesonline.com/p/locize/) with the **Great User Experience** and **Rising Star** awards for 2018 due to our localization and internationalization software’s capability to satisfy the large demands of global businesses. \n\n\n![user experience 2018](User-Experience2018.png \"locize © inweso GmbH\")\n\nlocize earned FinancesOnline’s **Great User Experience** award under their [best translation software](https://translation.financesonline.com/) for our offering an incredibly pleasing to use software for continuously localizing all kinds of languages and software. Project versioning for easy tracking of file changes, multiple file management and project progress tracking through the dashboard, and third-party integrations are some of the factors that contributed to this award. Their experts also praised our platform’s flexibility and responsiveness reflecting all translations on one’s website by simply embedding a single line of code, a feature that makes locize among the best [translation software competitors](https://financesonline.com/top-10-alternatives-one-hour-translation-popular-translation-software-solutions/). This also negates the need for manual inputting of all translations.\n\n\n![rising star 2018](Risign-Star2018.png \"locize © inweso GmbH\")\n\nThe FinancesOnline review team also regarded locize as a **Rising Star** for 2018 due to our highly positive traction with clients. It isn’t a surprise to see our software receive this distinction after FinancesOnline wrote positive remarks in their locize review such as *“cost-effective”*, *“always safe”* content thanks to our two-factor authentication, and accelerated and streamlined localization processes. \n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"https://locize.com/blog/tags/continuous-localization/"},{"name":"award","slug":"award","permalink":"https://locize.com/blog/tags/award/"}]},{"title":"Is your software ready for localization?","slug":"is-your-software-ready-for-localization","date":"un55fin55","updated":"un55fin55","comments":true,"path":"is-your-software-ready-for-localization/","link":"","permalink":"https://locize.com/blog/is-your-software-ready-for-localization/","excerpt":"","text":"So you want people from all around the world to use and understand your software... ...but how to achieve that? Which format should I use?Think about the workflow of exporting strings of the software, having them translated and then importing them back into your software. This will give you many ideas on how to structure your strings. Sometimes the used library already pretends a format. For web projects for example this can be: JSON (i.e. used by i18next) ICU Message syntax (i.e. used by formatjs) ... For mobile projects for example this can be: Localizable.strings (i.e. used by iOS) XML String Resource (i.e. used by Android) ... For system apps for example this can be: Java properties files (i.e. used by Java) ResX files (i.e. used by .Net) ... Do you hardcode text strings in the source code?Resource files should store all text used in the software; do not leave text strings hardcoded!Just don&#39;t! Can the order of variables in localized strings be changed?Implement a token system to ensure nouns, verbs, etc. can be placed in unique order by language. Different languages needs to know more information about the context. For example for pluralization or gender. The Italian language for example relies on gender. The words in the sentence change depending on whether you&#39;re talking about a man or a woman. Polish suppose you have a singular and then you have a different plural depending on whether the number of things ends with 2, 3 and 4 or some other digit. And Romanian need a different plural for any group of objects greater than 20. Does the interface allow for long translations?What about long translations in areas with single line text? Are there areas with multi-line text in your software? Sentences that take five syllables in English actually take a whole two paragraph description in some other language. Do you use unique string IDs?Unique string IDs help keep development, translation and QA teams on the same page. Another reason for this is: if you have for example a text in English that is visible in 2 different places on your UI, but is potentially translated differently in other languages (because it fits better). What about fonts? Who selects their types and sizes in the software?Both localization and development teams should select fonts as a cooperative effort. And how do you decide on the proportion of fonts? While fonts for North American and European languages should be &quot;Proportional&quot;, &quot;Monospace&quot; is the right type for Asian languages. Are the fonts compatible with special characters for all languages? Different languages, different needs: for special characters, word order, even numbers. How are date, time, currency, and numbers displayed?Allow date, time, currency, and numbers to be displayed with differing figures and number separators by language or even region. Make sure the date format is right because Americans do month/day/year Brit day/month/year and by the way in America the week starts on a Sunday and in Britain the week starts on Monday. Europe wants 24 hour clocks and America wants 12 hour clocks.Regarding numbers, here a little list: source What encoding do you use for your text assets? Choose an encoding that supports all target languages. If you don&#39;t know, just choose UTF-8. If you want to know Why UTF-8 is the best encoding? read this article. By the way, to tell apart assets intended for a particular locale use ISO 693-1 &amp; 3166-1 language and country codes to mark assets by locale. Do the art assets of your software UI have text?Be ready to swap art assets if they contain legible text. Sometimes even if there is no legible text you may want to adapt the art asset (i.e. an image) because of cultural reasons. There are some libraries that can help with this issue i.e. Fragment replacement for links and images Did you put the original text through a spelling, grammar, and style check?Prevent back-and-forth rechecking that may stall the whole process. As an alternative you should be thinking of making some sort of Continuous Localization. With Continuous Localization you can take care of the translations from the first day and keep up with changes with ease. The process of translation and development are separated. Do you use a tracking system?Tracking every change on localizable content can be important to ensure that no content will be left behind when distributing your software. For certain projects or industries it&#39;s important to know which translator has done what change for auditing reasons. Some translation management systems offer a dedicated history feature. This empowers you to prove anytime when a content fragment was changed. What file formats are you sending for translation work?JSON, XML (or a derivative format i.e. XLIFF) is preferred over plain text or Excel files. Even better are localization management systems that offers a completely integrated approach. Where are the localization assets?Store localization assets in an easy to access location, for swift access, import and export. With a proper Continuous Localization solution translations can be updated without the need to release an update of your app. For example: translations deployed to a CDN and consumed from your application. Do you intend to have the texts translated into more than one language?Process resource files into separate language ones so all translators can work in parallel. A good localization management solution can really help here. All team members can collaboratively work in parallel. In this way, you can get to your objective in a faster way. How do you track which language is fully translated?To say it in one sentence: &quot;Start thinking about the localization process early!&quot; The biggest mistake one can do is looking on localization as it’s only based on instrumenting your code and extract texts into resource files so you can translate them later. You should keep full overview about what is translated and what not — even more if you order translations from the translation providers you also should keep track of your open orders. What do you say now? Are you ready to &quot;play&quot; software localization monopoly? Don&#39;t worry, locize can help! Watch the demo video to learn more: locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.","raw":"---\ntitle: Is your software ready for localization?\ndescription: Verify if your software is ready for localization with the software localization monopoly.\n\ndate: 2018-02-23\ntags:\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n  - continuous development\n  - continuous integration\n  - continuous localization\n  - continuous delivery\n  - continuous translation\n  - i18next\n  - formatjs\nthumbnail: is-your-software-ready-for-localization/title.png\nredirect_from:\n- /2018-02-23-is-your-software-ready-for-localization\n\nlabel: is-your-software-ready-for-localization\nlang: en\n---\n\n![software ready for localization](title.png \"locize © inweso GmbH\")\n\n> So you want people from all around the world to use and understand your software...\n\n> ...but how to achieve that?\n\n## Which format should I use?\nThink about the workflow of exporting strings of the software, having them translated and then importing them back into your software. This will give you many ideas on how to structure your strings.\n\nSometimes the used library already pretends a format.\n\n#### For web projects for example this can be:\n- JSON (i.e. used by [i18next](https://i18next.com))\n- ICU Message syntax (i.e. used by [formatjs](https://formatjs.io/))\n- [...](../i18n-formats-javascript/)\n\n#### For mobile projects for example this can be:\n- Localizable.strings (i.e. used by iOS)\n- XML String Resource (i.e. used by Android)\n- ...\n\n#### For system apps for example this can be:\n- Java properties files (i.e. used by Java)\n- ResX files (i.e. used by .Net)\n- ...\n\n\n## Do you hardcode text strings in the source code?\nResource files should store all text used in the software; do not leave text strings hardcoded!<br />Just don't!\n\n\n## Can the order of variables in localized strings be changed?\nImplement a token system to ensure nouns, verbs, etc. can be placed in unique order by language.\nDifferent languages needs to know more information about the context. For example for pluralization or gender.\nThe Italian language for example relies on gender. The words in the sentence change depending on whether you're talking about a man or a woman.\nPolish suppose you have a singular and then you have a different plural depending on whether the number of things ends with 2, 3 and 4 or some other digit.\nAnd Romanian need a different plural for any group of objects greater than 20.\n\n\n## Does the interface allow for long translations?\nWhat about long translations in areas with single line text? Are there areas with multi-line text in your software?\nSentences that take five syllables in English actually take a whole two paragraph description in some other language.\n\n\n## Do you use unique string IDs?\nUnique string IDs help keep development, translation and QA teams on the same page.\nAnother reason for this is: if you have for example a text in English that is visible in 2 different places on your UI, but is potentially translated differently in other languages (because it fits better).\n\n\n## What about fonts? Who selects their types and sizes in the software?\nBoth localization and development teams should select fonts as a cooperative effort.\nAnd how do you decide on the proportion of fonts?\nWhile fonts for North American and European languages should be \"Proportional\", \"Monospace\" is the right type for Asian languages.\nAre the fonts compatible with special characters for all languages?\nDifferent languages, different needs: for special characters, word order, even numbers.\n\n\n## How are date, time, currency, and numbers displayed?\nAllow date, time, currency, and numbers to be displayed with differing figures and number separators by language or even region.\nMake sure the date format is right because Americans do month/day/year Brit day/month/year and by the way in America the week starts on a Sunday and in Britain the week starts on Monday. Europe wants 24 hour clocks and America wants 12 hour clocks.<br />Regarding numbers, here a little list:\n![numbers](numbers.png \"locize © inweso GmbH\")\n[source](https://en.wikipedia.org/wiki/Decimal_separator)\n\n\n## What encoding do you use for your text assets? <a name=\"encoding\"></a>\nChoose an encoding that supports all target languages.\nIf you don't know, just choose UTF-8.\nIf you want to know [Why UTF-8 is the best encoding?](http://codel10n.com/why-utf8-is-best-encoding-for-your-customers/) read this [article](http://codel10n.com/why-utf8-is-best-encoding-for-your-customers/).\nBy the way, to tell apart assets intended for a particular locale use ISO 693-1 & 3166-1 language and country codes to mark assets by locale.\n\n\n## Do the art assets of your software UI have text?\nBe ready to swap art assets if they contain legible text.\nSometimes even if there is no legible text you may want to adapt the art asset (i.e. an image) because of cultural reasons.\nThere are some libraries that can help with this issue i.e. [Fragment replacement for links and images](https://github.com/i18next/i18nextify#fragment-replacement-for-links-and-images)\n\n\n## Did you put the original text through a spelling, grammar, and style check?\nPrevent back-and-forth rechecking that may stall the whole process.\nAs an alternative you should be thinking of making some sort of [Continuous Localization](../continuous-development-integration-and-localization-cd/).\nWith [Continuous Localization](../continuous-development-integration-and-localization-cd/) you can take care of the translations from the first day and keep up with changes with ease.\nThe process of translation and development are separated.\n\n\n## Do you use a tracking system?\nTracking every change on localizable content can be important to ensure that no content will be left behind when distributing your software.\nFor certain projects or industries it's important to know which translator has done what change for auditing reasons.\nSome translation management systems offer a dedicated [history feature](https://docs.locize.com/whats-inside/history). This [empowers](https://medium.com/@jamuhl/empower-your-localization-team-33e10ca9e333) you to prove anytime when a content fragment was changed.\n\n\n## What file formats are you sending for translation work?\nJSON, XML (or a derivative format i.e. XLIFF) is preferred over plain text or Excel files.\nEven better are localization management systems that offers a completely [integrated approach](https://docs.locize.com/guides-tips-and-tricks/working-with-translators).\n\n\n## Where are the localization assets?\nStore localization assets in an easy to access location, for swift access, import and export.\nWith a proper [Continuous Localization](../continuous-development-integration-and-localization-cd/) solution translations can be updated without the need to release an update of your app.\nFor example: translations deployed to a [CDN](https://docs.locize.com/whats-inside/cdn-content-delivery-network) and consumed from your application.\n\n\n## Do you intend to have the texts translated into more than one language?\nProcess resource files into separate language ones so all translators can work in parallel.\nA good [localization management solution](https://locize.com) can really help here. All team members can collaboratively work in parallel. In this way, you can get to your objective in a faster way.\n\n\n## How do you track which language is fully translated?\nTo say it in one sentence: \"Start thinking about the localization process early!\"\nThe biggest mistake one can do is looking on localization as it’s only based on instrumenting your code and extract texts into resource files so you can translate them later.\n\nYou should keep full overview about what is translated and what not — even more if you order translations from the translation providers you also should keep track of your open orders.\n\n\n\n# What do you say now? Are you ready to \"play\" software localization monopoly?\n\n> Don't worry, [locize](https://locize.com) can help!\n\nWatch the demo video to learn more:\n{% youtube ds-yEEYP1Ks %}\n\n[locize](https://locize.com) removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translators can keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"continuous development","slug":"continuous-development","permalink":"https://locize.com/blog/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"https://locize.com/blog/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"https://locize.com/blog/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"https://locize.com/blog/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"https://locize.com/blog/tags/continuous-translation/"},{"name":"formatjs","slug":"formatjs","permalink":"https://locize.com/blog/tags/formatjs/"}]},{"title":"8 signs you should improve your localization process","slug":"8-signs-you-should-improve-your-localization-process","date":"un22fin22","updated":"un55fin55","comments":true,"path":"8-signs-you-should-improve-your-localization-process/","link":"","permalink":"https://locize.com/blog/8-signs-you-should-improve-your-localization-process/","excerpt":"","text":"Very often, when you&#39;re engrossed in the everyday work, you do not realize how easily your localization process could be improved. For this reason, it is important to me to show you the following 8 warning signs you should look out for: 1. Waste of timeAre you mailing translation files around the world? Always struggling with this translation files? Other people ask for the resource files to be translated and you hand them out and deep in your mind you know there will be some last minute changes the day before release and even more changes after release. Some time later (days or weeks) some translated files lands in your inbox and you copy them to your repository... But there are already a lot of changes... Some terms are not used anymore others are new and not yet translated and others are modified by the developers in the meanwhile. 2. Waterfall processAre you trying to switch the development process to a more agile approach but the localization process does not fit? Is there no time to translate during the development iteration or sprint? By implementing more SaaS (Software as a Service) products today&#39;s organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment). Developers focuses on instrumenting the code with the help of some i18n libraries and extract texts into resource files so someone can translate them later. Normally during a development iteration or sprint there is no time to translate the resources. That’s why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted. This “freeze” period gives technical writers and translators the necessary time to work. The more text needs to be handled the longer this period while take. This process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment process anymore. 3. Missing contextAre the translated texts too long? Do you feel the translator did not understand what the product is? By handing over the resource files to the translators, it is very difficult for them to imagine the translated texts in the real product. That&#39;s why very often the translated texts feels wrong when imported back to the product. Doing proper translations needs more information by providing the context or even better by being done incontext. 4. Hard translation managementAre translation texts suddenly deleted while translating? Is the format of the text corrupt after translating? Translators and technical editors are humans too. Not only the lack of technical know how (html or markdown formatting, etc...) but also the power of their tooling is important and crucial. The worse the tooling the greater the danger of getting corrupt texts. 5. Poor integrationDo you wish using the same localization process for your product and other systems simultaneously, like your marketing website? Mostly the product development and the marketing department are split in multiple teams. In that way the localization process evolves in different ways. Not having a central team being responsible for offering internationalization libraries, apis and localization guidelines makes it difficult to find synergies across different products and teams. 6. Locked inDo you have troubles in finding open internationalization libraries compatible with your existing resource files or vice-versa find a localization solution compatible with your internationalization library? Very often the localization process enforces to develop very customized tools and helper scripts if not standardized or at least based on open specifications, formats and protocols. 7. Unclear project progressAre your resource files all fully translated? What is missing? What is the expected effort to complete? Not having a centralized collaborative translation management system that is actively used by developers and translation editors makes it very difficult to forecast when a translation is fully translated and to plan its release. 8. ExpensiveAre your translation orders too expensive? Do you have multiple dedicated personal resources? There is not only the employee salary, but also the wasted time &quot;waiting&quot;, proofreading and correcting the translated resources. And finally, each delay of your time-to-market costs a lot of money. Advice As we learned, localizing software releases is a nightmare and no translation tool really supports product managers, developers and translators well in software translations with continuous changes and additions. Someone started to work on locize.com to bridge the gap between translation and development. Watch the introduction video to learn more. locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translator could keep up with changes from day one. The continuous localization process keeps up with your demanding business. Stop waiting - start localizing.","raw":"---\ntitle: 8 signs you should improve your localization process\n\ndate: 2017-08-15\ntags:\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - i18n\n\nthumbnail: 8-signs-you-should-improve-your-localization-process/title.png\nredirect_from:\n- /2017-08-15-8-signs-you-should-improve-your-localization-process\n---\n\n![localization process improvements](title.png \"locize © inweso GmbH\")\n\nVery often, when you're engrossed in the everyday work, you do not realize how easily your localization process could be improved.\nFor this reason, it is important to me to show you the following 8 warning signs you should look out for:\n\n## 1. Waste of time\n***Are you mailing translation files around the world? Always struggling with this translation files?***\n\n![waste](waste.gif \"locize © inweso GmbH\")\n\nOther people ask for the resource files to be translated and you hand them out and deep in your mind you know there will be some last minute changes the day before release and even more changes after release.\nSome time later (days or weeks) some translated files lands in your inbox and you copy them to your repository... But there are already a lot of changes... Some terms are not used anymore others are new and not yet translated and others are modified by the developers in the meanwhile.\n\n\n## 2. Waterfall process\n***Are you trying to switch the development process to a more agile approach but the localization process does not fit? Is there no time to translate during the development iteration or sprint?***\n\n![process](process.gif \"locize © inweso GmbH\")\n\nBy implementing more SaaS (Software as a Service) products today's organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment).\nDevelopers focuses on instrumenting the code with the help of some i18n libraries and extract texts into resource files so someone can translate them later.\nNormally during a development iteration or sprint there is no time to translate the resources.\nThat’s why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted.\nThis **“freeze”** period gives technical writers and translators the necessary time to work. The more text needs to be handled the longer this period while take.\nThis process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment process anymore.\n\n\n## 3. Missing context\n***Are the translated texts too long? Do you feel the translator did not understand what the product is?***\n\n![context](context.png \"locize © inweso GmbH\")\n\nBy handing over the resource files to the translators, it is very difficult for them to imagine the translated texts in the real product. That's why very often the translated texts feels wrong when imported back to the product.\nDoing proper translations needs more information by providing the context or even better by being done incontext.\n\n\n## 4. Hard translation management\n***Are translation texts suddenly deleted while translating? Is the format of the text corrupt after translating?***\n\n![translation](translation.gif \"locize © inweso GmbH\")\n\nTranslators and technical editors are humans too. Not only the lack of technical know how (html or markdown formatting, etc...) but also the power of their tooling is important and crucial.\nThe worse the tooling the greater the danger of getting corrupt texts.\n\n## 5. Poor integration\n***Do you wish using the same localization process for your product and other systems simultaneously, like your marketing website?***\n\n![integration](integration.png \"locize © inweso GmbH\")\n\nMostly the product development and the marketing department are split in multiple teams. In that way the localization process evolves in different ways. Not having a central team being responsible for offering internationalization libraries, apis and localization guidelines makes it difficult to find synergies across different products and teams.\n\n## 6. Locked in\n***Do you have troubles in finding open internationalization libraries compatible with your existing resource files or vice-versa find a localization solution compatible with your internationalization library?***\n\n![locked](locked.png \"locize © inweso GmbH\")\n\nVery often the localization process enforces to develop very customized tools and helper scripts if not standardized or at least based on open specifications, formats and protocols.\n\n## 7. Unclear project progress\n***Are your resource files all fully translated? What is missing? What is the expected effort to complete?***\n\n![progress](progress.png \"locize © inweso GmbH\")\n\nNot having a centralized collaborative translation management system that is actively used by developers and translation editors makes it very difficult to forecast when a translation is fully translated and to plan its release.\n\n## 8. Expensive\n***Are your translation orders too expensive? Do you have multiple dedicated personal resources?***\n\n![costs](costs.png \"locize © inweso GmbH\")\n\nThere is not only the employee salary, but also the wasted time \"waiting\", proofreading and correcting the translated resources.\nAnd finally, each delay of your time-to-market costs a lot of money.\n\n\n## Advice\n\n![infographic](infographic.png \"locize © inweso GmbH\")\n\n\nAs we learned, localizing software releases is a nightmare and no translation tool really supports product managers, developers and translators well in software translations with continuous changes and additions. Someone started to work on [locize.com](http://locize.com) to bridge the gap between translation and development.\n\n\n\nWatch the [introduction video](http://locize.com/#video) to learn more.\n{% youtube YQryHo1iHb8 %}\n\n[locize](http://locize.com) removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translator could keep up with changes from day one. The continuous localization process keeps up with your demanding business.\n\nStop waiting - start localizing.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"}]},{"title":"How locize leverages serverless","slug":"how-locize-leverages-serverless","date":"un44fin44","updated":"un55fin55","comments":true,"path":"how-locize-leverages-serverless/","link":"","permalink":"https://locize.com/blog/how-locize-leverages-serverless/","excerpt":"","text":"slides Why we choose serverless? When we started with locize we did not know how fast it would scale… serverless means we didn’t need to make that choice. The serverless architecture scales with our business model. The next argument is, we hate maintaining and operating infrastructure. We believe in NoOps. Here serverless saves not only computing power but human resources too. Finally you may ask: Why not a PaaS solution? =&gt; We are working with PaaS solutions since early 2011 and we always had the dream to have a platform where you really pay only when something is used (i.e. call of a function, query of a table, etc…) so you can fully concentrate to the business code. And last but not least: serverless is really cool! Why we choose AWS? We think AWS is the only production-ready FaaS provider (and more) that works out of the box and scales like you expected. It’s designed with an API-first approach, so everything can be automated. We think AWS has in mind a possible future where you can also run functions directly on the edge (directly on hardware). Additionally AWS has not only lambda but completes the serverless offering with: API Gateway DynamoDB Simple Storage Service (S3) CloudFront Simple Email Service (SES) and a lot more... The basic setup When Developers/Translation Editors/Managers, etc… goes to www.locize.app, the locize-app-client (which is hosted on S3 and exposed by CloudFront) is served. The client then accesses our lambda backend through the API-Gateway also exposed by CloudFront. Our main working storage (DynamoDB) is then accessed by our lambda functions. Each time someone publishes (or auto-publishes) a translation resource a lambda function will save that resource to S3. When published, the endusers of your product can access them via CDN edge locations offered and exposed by CloudFront too. Full-Stack JavaScript locize is a single language solution! Everything is JavaScript! The complete application backend, the api, the cli and other tools runs on node.js… and the locize-app-client is a modern SPA based on React and Redux. Lambda functions locize uses 3 different base lambda types. These are not real „AWS-defined“ lambda types but we&#39;ve defined these types ourself. Express The first type is the express type. It defines RESTful APIs using the normal express framework. You see the app.js file looks like a normal express based project. But at the end of the file you see that if this file is executed directly (like node app.js) it will start to listen on port 3000 and can be used to test locally. But if required by another file it exports the configured express app. For this scenario there is an additional file (lambda.js) that uses the help of the npm module „aws-serverless-express“ to proxy and map the lambda function calls to http requests and responses. Async The second type is the async type. This lambda function is triggered by other lambda functions to compute non blocking tasks. i.e. calculation of current words in project, or publishing translation resources to S3, etc… The key element here is that a lambda function is able to call another lambda function by simply using the official aws-sdk npm module. With the help of AWS policies you can define exactly which function can be invoked. S3 event The last type is the S3 event type. This lambda function is i.e. triggered by a new CloudFront log file that was saved to s3 (this feature can be enabled on CloudFront). We use this to i.e. calculate the amount of downloads or to generate statistics. Our tooling Because we have a pure JavaScript landscape we’ve chosen claudia.js It automatically installs and configures a lot on AWS. From API-Gateway to Lambda versioning. Claudia.js does not abstract away AWS services. It’s really transparent and easy to understand. That’s why our advice is: if you want to build simple services and run them with AWS lambda, and you&#39;re looking for something low-overhead, easy to get started with, and you only want to use the node.js runtime, Claudia is a good choice.","raw":"---\ntitle: How locize leverages serverless\n\ndate: 2017-06-22\ntags:\n  - serverless\n  - backend\n  - aws\n  - service\n\nthumbnail: how-locize-leverages-serverless/title.png\nredirect_from:\n- /2017-06-22--how-locize-leverages-serverless\n---\n\n![](title.png \"locize © inweso GmbH\")\n\n_[slides](https://www.slideshare.net/adrai/locize-tech-talk)_\n\n## Why we choose serverless?\n\n![why](why.png \"locize © inweso GmbH\")\n\nWhen we started with [locize](http://www.locize.com) we did not know how fast it would scale… serverless means we didn’t need to make that choice. The serverless architecture scales with our business model.\n\nThe next argument is, we hate maintaining and operating infrastructure. We believe in NoOps. Here serverless saves not only computing power but human resources too.\n\nFinally you may ask: Why not a PaaS solution? => We are working with PaaS solutions since early 2011 and we always had the dream to have a platform where you really pay only when something is used (i.e. call of a function, query of a table, etc…) so you can fully concentrate to the business code.\nAnd last but not least: serverless is really cool!\n\n\n## Why we choose AWS?\n\n![why aws](why_aws.png \"locize © inweso GmbH\")\n\nWe think AWS is the only production-ready FaaS provider (and more) that works out of the box and scales like you expected. It’s designed with an API-first approach, so everything can be automated.\nWe think AWS has in mind a possible future where you can also run functions directly on the edge (directly on hardware).\nAdditionally AWS has not only lambda but completes the serverless offering with:\n\n- API Gateway\n- DynamoDB\n- Simple Storage Service (S3)\n- CloudFront\n- Simple Email Service (SES)\n- and a lot more...\n\n\n## The basic setup\n\n![setup](setup.png \"locize © inweso GmbH\")\n\nWhen Developers/Translation Editors/Managers, etc… goes to www.locize.app, the locize-app-client (which is hosted on S3 and exposed by CloudFront) is served. The client then accesses our lambda backend through the API-Gateway also exposed by CloudFront. Our main working storage (DynamoDB) is then accessed by our lambda functions.\nEach time someone publishes (or auto-publishes) a translation resource a lambda function will save that resource to S3. When published, the endusers of your product can access them via CDN edge locations offered and exposed by CloudFront too.\n\n\n## Full-Stack JavaScript\n\n![full js](full_js.png \"locize © inweso GmbH\")\n\nlocize is a single language solution! Everything is JavaScript!\nThe complete application backend, the api, the cli and other tools runs on [node.js](https://nodejs.org)… and the locize-app-client is a modern SPA based on [React](https://facebook.github.io/react/) and [Redux](http://redux.js.org/).\n\n\n## Lambda functions\n\n![types](types.png \"locize © inweso GmbH\")\n\nlocize uses 3 different base lambda types.\nThese are not real „AWS-defined“ lambda types but we've defined these types ourself.\n\n### Express\n\n![express](express.png \"locize © inweso GmbH\")\n\nThe first type is the express type.\nIt defines RESTful APIs using the normal [express](http://expressjs.com/) framework.\nYou see the app.js file looks like a normal [express](http://expressjs.com/)  based project.\nBut at the end of the file you see that if this file is executed directly (like `node app.js`) it will start to listen on port 3000 and can be used to test locally.\nBut if required by another file it exports the configured [express](http://expressjs.com/) app.\nFor this scenario there is an additional file (lambda.js) that uses the help of the npm module „aws-serverless-express“ to proxy and map the lambda function calls to http requests and responses. \n\n### Async\n\n![async](async.png \"locize © inweso GmbH\")\n\nThe second type is the async type.\nThis lambda function is triggered by other lambda functions to compute non blocking tasks. i.e. calculation of current words in project, or publishing translation resources to S3, etc…\nThe key element here is that a lambda function is able to call another lambda function by simply using the official aws-sdk npm module.\nWith the help of AWS policies you can define exactly which function can be invoked.\n\n### S3 event\n\n![s3](s3.png \"locize © inweso GmbH\")\n\nThe last type is the S3 event type.\nThis lambda function is i.e. triggered by a new CloudFront log file that was saved to s3 (this feature can be enabled on CloudFront).\nWe use this to i.e. calculate the amount of downloads or to generate statistics.\n\n## Our tooling\n\n![claudia js](claudia.png \"locize © inweso GmbH\")\n\nBecause we have a pure JavaScript landscape we’ve chosen [claudia.js](https://claudiajs.com/)\nIt automatically installs and configures a lot on AWS. From API-Gateway to Lambda versioning.\n[Claudia.js](https://claudiajs.com/) does not abstract away AWS services. It’s really transparent and easy to understand.\nThat’s why our advice is: if you want to build simple services and run them with AWS lambda, and you're looking for something low-overhead, easy to get started with, and you only want to use the [node.js](https://nodejs.org) runtime, Claudia is a good choice.\n","categories":[],"tags":[{"name":"serverless","slug":"serverless","permalink":"https://locize.com/blog/tags/serverless/"},{"name":"backend","slug":"backend","permalink":"https://locize.com/blog/tags/backend/"},{"name":"aws","slug":"aws","permalink":"https://locize.com/blog/tags/aws/"},{"name":"service","slug":"service","permalink":"https://locize.com/blog/tags/service/"}]},{"title":"locizify v2 - improvements","slug":"locizify-v2","date":"un22fin22","updated":"un55fin55","comments":true,"path":"locizify-v2/","link":"","permalink":"https://locize.com/blog/locizify-v2/","excerpt":"","text":"We use the unpkg CDNIn the past we deployed the locizify script to our own CDN space. While this was ok migrating over to https://unpkg.com allows us to provide you an improved usage. In the past your code was bound to the latest deployed script on our CDN. As we strongly respect semver we just were able to update the script with non breaking updates. Now as you could use the source from unpkg you&#39;re able to fix the version in your code like: 123https://unpkg.com/locizify // latesthttps://unpkg.com/locizify@2.0.1 // specific versionhttps://unpkg.com/locizify@^2.0.0 // latest non breaking version 2.x.x full sample: 1234&lt;script id=&quot;locizify&quot; projectid=&quot;[PROJECT_ID]&quot; apikey=&quot;[API_KEY]&quot; referencelng=&quot;[LNG]&quot; fallbacklng=&quot;[LNG]&quot; saveMissing=&quot;true&quot; src=&quot;https://unpkg.com/locizify@^2.0.0&quot; /&gt; New FeaturesmergingSometimes you want to keep innerHTML of an element together to make it easier to translate. Before: 1&lt;p&gt;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot;Might be easier to translate this &quot;: &quot;Might be easier to translate this &quot;, &quot;the new way&quot;: &quot;the new way&quot;&#125; Using merge: 1&lt;p merge&gt;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&lt;/p&gt; 1234// resulting keys&#123; &quot;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&quot;: &quot;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&quot;&#125; While you can set the merge attribute on every element you like to have this behaviour. You can also specify this globally on init: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // merging content (eg. a tags in p tags) mergeTags: [], // tags to merge innerHtml to one key inlineTags: [], // tags to inline (eg. a, span, abbr, ...) ignoreInlineOn: [], // tags to ignore inlining tags under inlineTags &#125;); &lt;/script&gt; &lt;/head&gt; ... cleanup for keysWith v2 we improved the key generation from content by removing unused whitespaces: Before: 12345&lt;p&gt; Having text over multiple lines &lt;span&gt; with space in front&lt;/span&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot; Having text/n over multiple lines&quot;: &quot; Having text/n over multiple lines&quot;, &quot; with space in front&quot;: &quot; with space in front&quot;&#125; Using cleanup (default enabled in v2): 12345&lt;p&gt; Having text over multiple lines &lt;span&gt; with space in front&lt;/span&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot;Having text over multiple lines&quot;: &quot;Having text over multiple lines&quot;, &quot;with space in front&quot;: &quot;with space in front&quot;&#125; All the unnecessary whitespaces get removed making translation more easy. You can manually toggle this off or ignore it for certain tags: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // cleanup for keys cleanIndent: true, // removes indent, eg. if a p tag spans multiple lines ignoreCleanIndentFor: [&#x27;PRE&#x27;, &#x27;CODE&#x27;], // ignores cleaning up of indent for those tags needing that extra spaceing cleanWhitespace: true, // removes surrounding whitespace from key &#125;); &lt;/script&gt; &lt;/head&gt; ... Fragment replacement for links and images12&lt;img src=&quot;/images/&#123;&#123;a.png&#125;&#125;&quot; alt=&quot;big A&quot; /&gt;&lt;a href=&quot;/&#123;&#123;statistic&#125;&#125;&quot;&gt;Open my statistics&lt;/a&gt; You will find a.png and statistic to be a key in your translations - it&#39;s value can be replaced to eg. a-de.png for german (all other languages will fallback to a.png) Translate other then default attributes on elementseg: for validation error messages 1&lt;input data-parsley-error-message=&quot;This field is required&quot; /&gt; Just add data-parsley-error-message to the translateAttributes Array on init: 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; translateAttributes: [&#x27;placeholder&#x27;, &#x27;title&#x27;, &#x27;alt&#x27;, &#x27;value#input.type=button&#x27;, &#x27;value#input.type=submit&#x27;], &#125;); &lt;/script&gt; &lt;/head&gt; ... You can define rules like: ``[attributeToTranslate]#element.andOrAttributeWithValue` 123value#input // all values on inputvalue#type // all values on elements having an attribute typevalue#input.type=button // all values on input element having an attribute type set to button Migration from v1To make v2 having the same behaviour as v1 you could change the init options like: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // cleanup for keys cleanIndent: false, cleanWhitespace: false, ... &#125;); &lt;/script&gt; &lt;/head&gt; ... This way you assert keys get not cleaned of whitespaces so they match the counterpart of v1.","raw":"---\ntitle: locizify v2 - improvements\ndate: 2017-02-21\ntags:\n  - locizify\nthumbnail: images/locize_color.svg\nredirect_from:\n- /2017-02-21-locizify-v2\n---\n\n## We use the unpkg CDN\n\nIn the past we deployed the locizify script to our own CDN space. While this was ok migrating over to [https://unpkg.com](https://unpkg.com) allows us to provide you an improved usage. In the past your code was bound to the latest deployed script on our CDN. As we strongly respect [semver](http://semver.org/) we just were able to update the script with non breaking updates.\n\nNow as you could use the source from unpkg you're able to fix the version in your code like:\n\n```\nhttps://unpkg.com/locizify // latest\nhttps://unpkg.com/locizify@2.0.1 // specific version\nhttps://unpkg.com/locizify@^2.0.0 // latest non breaking version 2.x.x\n```\n\nfull sample:\n\n```html\n<script id=\"locizify\" projectid=\"[PROJECT_ID]\"\n    apikey=\"[API_KEY]\" referencelng=\"[LNG]\"\n    fallbacklng=\"[LNG]\" saveMissing=\"true\"\n    src=\"https://unpkg.com/locizify@^2.0.0\" />\n```\n\n## New Features\n\n### merging\n\nSometimes you want to keep innerHTML of an element together to make it easier to translate.\n\nBefore:\n\n```html\n<p>Might be easier to translate this <a href=\"#\">the new way</a></p>\n```\n\n```js\n// resulting keys\n{\n  \"Might be easier to translate this \": \"Might be easier to translate this \",\n  \"the new way\": \"the new way\"\n}\n```\n\nUsing merge:\n\n```html\n<p merge>Might be easier to translate this <a href=\"#\">the new way</a></p>\n```\n\n```js\n// resulting keys\n{\n  \"Might be easier to translate this <a href=\"#\">the new way</a>\": \"Might be easier to translate this <a href=\"#\">the new way</a>\"\n}\n```\n\nWhile you can set the `merge` attribute on every element you like to have this behaviour. You can also specify this globally on init:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"https://unpkg.com/locizify@^2.0.0\"></script>\n    <script>\n      locizify.init({\n        // merging content (eg. a tags in p tags)\n        mergeTags: [], // tags to merge innerHtml to one key\n        inlineTags: [], // tags to inline (eg. a, span, abbr, ...)\n        ignoreInlineOn: [], // tags to ignore inlining tags under inlineTags\n      });\n    </script>\n  </head>\n  ...\n```\n\n### cleanup for keys\n\nWith v2 we improved the key generation from content by removing unused whitespaces:\n\nBefore:\n\n```html\n<p>\n  Having text\n  over multiple lines\n  <span> with space in front</span>\n</p>\n```\n\n```js\n// resulting keys\n{\n  \"  Having text/n  over multiple lines\": \"  Having text/n  over multiple lines\",\n  \" with space in front\": \" with space in front\"\n}\n```\n\nUsing cleanup (default enabled in v2):\n\n```html\n<p>\n  Having text\n  over multiple lines\n  <span> with space in front</span>\n</p>\n```\n\n```js\n// resulting keys\n{\n  \"Having text over multiple lines\": \"Having text over multiple lines\",\n  \"with space in front\": \"with space in front\"\n}\n```\n\nAll the unnecessary whitespaces get removed making translation more easy. You can manually toggle this off or ignore it for certain tags:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"https://unpkg.com/locizify@^2.0.0\"></script>\n    <script>\n      locizify.init({\n        // cleanup for keys\n        cleanIndent: true, // removes indent, eg. if a p tag spans multiple lines\n        ignoreCleanIndentFor: ['PRE', 'CODE'], // ignores cleaning up of indent for those tags needing that extra spaceing\n        cleanWhitespace: true, // removes surrounding whitespace from key\n      });\n    </script>\n  </head>\n  ...\n```\n\n### Fragment replacement for links and images\n\n```html\n<img src=\"/images/{{a.png}}\" alt=\"big A\" />\n<a href=\"/{{statistic}}\">Open my statistics</a>\n```\n\nYou will find `a.png` and `statistic` to be a key in your translations - it's value can be replaced to eg. a-de.png for german (all other languages will fallback to a.png)\n\n### Translate other then default attributes on elements\n\neg: for validation error messages\n```html\n<input data-parsley-error-message=\"This field is required\" />\n```\n\nJust add `data-parsley-error-message` to the `translateAttributes` Array on init:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"https://unpkg.com/locizify@^2.0.0\"></script>\n    <script>\n      locizify.init({\n        translateAttributes: ['placeholder', 'title', 'alt', 'value#input.type=button', 'value#input.type=submit'],\n      });\n    </script>\n  </head>\n  ...\n```\n\nYou can define rules like:\n\n``[attributeToTranslate]#element.andOrAttributeWithValue`\n\n```js\nvalue#input // all values on input\nvalue#type // all values on elements having an attribute type\nvalue#input.type=button // all values on input element having an attribute type set to button\n```\n\n## Migration from v1\n\nTo make v2 having the same behaviour as v1 you could change the init options like:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"https://unpkg.com/locizify@^2.0.0\"></script>\n    <script>\n      locizify.init({\n        // cleanup for keys\n        cleanIndent: false,\n        cleanWhitespace: false,\n\n        ...\n      });\n    </script>\n  </head>\n  ...\n```\n\nThis way you assert keys get not cleaned of whitespaces so they match the counterpart of v1.\n","categories":[],"tags":[{"name":"locizify","slug":"locizify","permalink":"https://locize.com/blog/tags/locizify/"}]},{"title":"Localization should be fun","slug":"localization-fun","date":"un33fin33","updated":"un55fin55","comments":true,"path":"localization-fun/","link":"","permalink":"https://locize.com/blog/localization-fun/","excerpt":"","text":"Learn from our experience we made during using the locize service on our own new webapplication. In an early stage of drafting out our plan to completely rewrite our locize webclient we decided to use our own service to manage the content on it. There was no plan on providing it in another language then english - but we strongly believed even not having the demand of translating we could profit of separating the content from the application logic. This way we could go full speed during development while working on final terminology later. As a plus we could change all the texts in production without having to deploy a new client. Another reason was - we wanted to get a better feeling on how the experience is - creating a new project using our service. Our goal was to get a workflow that is faster, less error prone and more fun for everyone being part of the localization process. Our past workflowTo have a comparison with the updated workflow we like to describe how things got done before using locize. If you like to direcly see how things worked with locize just skip this section. Developers path Create a new component, page and get functionality to work Replace all texts with instrumented code (calls to translation function) Add all the new keys to the correct json file (manually resolving the nesting) Restart server to load and serve the new translations files See the json has an error -&gt; fix it -&gt; Restart again See that some keys are still missing -&gt; add -&gt; Restart again Technical editor / Translator path Ask developer for latest resource files Getting them a few days later -&gt; start changing texts to match terminology Save the file and pass it back to development Ask for new texts - getting only a file having all texts -&gt; going crazy as having no idea which stuff is new...start to compare with last file Pass new texts to development ... Poor guys path tries to merge files coming from development and technical editor Goes crazy and starts searching for a new job ;) Doing agile / continuous localization could be hard...you can improve this by doing the steps in waterfall manner: development -&gt; technical editor -&gt; translations. But not only takes this a lot longer but also the problems come back as soon as development starts work on next version having semi-finished texts from the technical editor. Things need to get better - so lets have a look on how our experience was using locize: Having locize in the flow earlyDeveloping new components / pages we directly instrumented the code. In the early stage we still started with having the texts in code and instrument after being functional working. With getting more used to the new workflow we just removed that step and directly used to call the translation function. Using webpacks hot-module-reload feature we just needed to save the file and the webapplication did it&#39;s reload magic: This triggered the save missing feature which was enabled during development. So all the untranslated texts were passed automatically to our locize project. Time to reload the new data on our locize project using the new filter &quot;was created by missing&quot; to only show newly submitted texts: Just fill the newly added keys with the content it should have - press save - and done. Reload the application and all the new texts are there: From here the technical editor / translators could change texts as needed and verify those in the test environment completely independent of the development. Never ask for resource files again Never wait for the new texts / translations to be merged and deployed No need to beg your developers to change a text - not even in production What happened to the poor guy? He was not needed any longer and lost his job before having the chance to search for a new one - just kidding ;) Separating development and content editing made both sides work more efficient, with less errors and a lot faster. Developers, technical editor and translators could work hand in hand without disturbing each others work.","raw":"---\ntitle: Localization should be fun\ndate: 2016-11-16\ntags:\n  - locize\nthumbnail: localization-fun/thumb.png\nredirect_from:\n- /2016-11-16-localization-fun\n---\n\nLearn from our experience we made during using the locize service on our own new webapplication.\n\n![](thumb.png \"working hard\")\n\nIn an early stage of drafting out our plan to completely rewrite our locize webclient we decided to use our own service to manage the content on it. There was no plan on providing it in another language then english - but we strongly believed even not having the demand of translating we could profit of separating the content from the application logic. This way we could go full speed during development while working on final terminology later. As a plus we could change all the texts in production without having to deploy a new client.\n\nAnother reason was - we wanted to get a better feeling on how the experience is - creating a new project using our service. Our goal was to get a workflow that is faster, less error prone and more fun for everyone being part of the localization process.\n\n### Our past workflow\n\nTo have a comparison with the updated workflow we like to describe how things got done before using locize. **If you like to direcly see how things worked with locize just skip this section**.\n\n##### Developers path\n\n- Create a new component, page and get functionality to work\n- Replace all texts with instrumented code (calls to translation function)\n- Add all the new keys to the correct json file (manually resolving the nesting)\n- Restart server to load and serve the new translations files\n- See the json has an error -> fix it -> Restart again\n- See that some keys are still missing -> add -> Restart again\n\n##### Technical editor / Translator path\n\n- Ask developer for latest resource files\n- Getting them a few days later -> start changing texts to match terminology\n- Save the file and pass it back to development\n- Ask for new texts - getting only a file having all texts -> going crazy as having no idea which stuff is new...start to compare with last file\n- Pass new texts to development\n- ...\n\n##### Poor guys path\n\n- tries to merge files coming from development and technical editor\n- Goes crazy and starts searching for a new job ;)\n\n\nDoing agile / continuous localization could be hard...you can improve this by doing the steps in waterfall manner: development -> technical editor -> translations. But not only takes this a lot longer but also the problems come back as soon as development starts work on next version having semi-finished texts from the technical editor.\n\nThings need to get better - so lets have a look on how our experience was using locize:\n\n## Having locize in the flow early\n\nDeveloping new components / pages we directly instrumented the code. In the early stage we still started with having the texts in code and instrument after being functional working. With getting more used to the new workflow we just removed that step and directly used to call the translation function.\n\n![](1_instrument_code.png \"instrumented code\")\n\nUsing webpacks hot-module-reload feature we just needed to save the file and the webapplication did it's reload magic:\n\n![](2_trigger_savemissing.png \"save missing was triggered\")\n\nThis triggered the save missing feature which was enabled during development. So all the untranslated texts were passed automatically to our locize project.\n\nTime to reload the new data on our locize project using the new filter \"was created by missing\" to only show newly submitted texts:\n\n![](3_managecontent.png \"edit content\")\n\nJust fill the newly added keys with the content it should have - press save - and done. Reload the application and all the new texts are there:\n\n![](4_done.png \"content loaded from locize\")\n\nFrom here the technical editor / translators could change texts as needed and verify those in the test environment completely independent of the development.\n\n- Never ask for resource files again\n- Never wait for the new texts / translations to be merged and deployed\n- No need to beg your developers to change a text - not even in production\n\nWhat happened to the **poor guy**? He was not needed any longer and lost his job before having the chance to search for a new one - just kidding ;)\n\n-----\n\nSeparating development and content editing made both sides work more efficient, with less errors and a lot faster. Developers, technical editor and translators could work hand in hand without disturbing each others work.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"}]},{"title":"Continuous Development, Integration and Localization => Continuous Deployment","slug":"continuous-development-integration-and-localization-cd","date":"un33fin33","updated":"un55fin55","comments":true,"path":"continuous-development-integration-and-localization-cd/","link":"","permalink":"https://locize.com/blog/continuous-development-integration-and-localization-cd/","excerpt":"","text":"Past timesIn the past most organizations that have to write some software planned, developed and released their product in one-year or even multiple-year cycles. =&gt;Typical waterfall process. Every time the developer team had finished implementing the features, the product manager could start to organize and initiate the translation process. So the only thing the developers had to guarantee, was to be able to export and import text resources. That way the texts could be translated all together, by sending them to different agencies or regional market organizations, etc… When translations were done (after days, weeks or even months), they’d be sent back to the product manager who forwarded them to the developers. They then had taken the translations, imported and merged them into the product, and (re-)released. Status QuoMost of today’s organizations are trying to switch the development process to a more agile approach. By implementing more SaaS (Software as a Service) products today’s organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment). Developers focuses on instrumenting the code with the help of some i18n libraries like: http://airbnb.io/polyglot.js/ and extract texts into resource files so someone can translate them later. Normally during a development iteration or sprint there is no time to translate the resources, and not just because most people have this sort of attitude: &lt;&lt; We are not interested in the translation process itself. &gt;&gt; That’s why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted. This “freeze” period gives technical writers and translators the necessary time to work on. The more text needs to be handled the longer is this period. This process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment. True Continuous Deployment with Continuous LocalizationBecause software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously. Your localization and translation process should follow the same pattern as your software development. You should be able to deploy your translation files separated from your software so you can update and manage them independently. And if you do so, you have to make sure you can have more then one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software! Cool, but isn’t this a little over the top… an extra tooling and deployment — doesn’t all this just add more complexity and effort? You don’t have to build this yourself!!! — There is locize ...give it a try: Register!","raw":"---\ntitle: Continuous Development, Integration and Localization => Continuous Deployment\n\ndate: 2016-10-05\ntags:\n  - locize\n  - localization\n  - l10n\n  - internationalization\n  - continuous development\n  - continuous integration\n  - continuous localization\n  - continuous delivery\n  - continuous translation\n  - i18next\n  - polyglot\n  - formatjs\n\nthumbnail: continuous-development-integration-and-localization-cd/hands_world.jpg\nredirect_from:\n- /2016-10-05-continuous-development-integration-and-localization-cd\n---\n\n![](hands_world.jpg \"localization\")\n\n### Past times\n\nIn the past most organizations that have to write some software planned, developed and released their product in one-year or even multiple-year cycles. =>Typical waterfall process.\nEvery time the developer team had finished implementing the features, the product manager could start to organize and initiate the translation process.\nSo the only thing the developers had to guarantee, was to be able to export and import text resources.\nThat way the texts could be translated all together, by sending them to different agencies or regional market organizations, etc…\nWhen translations were done (after days, weeks or even months), they’d be sent back to the product manager who forwarded them to the developers.\nThey then had taken the translations, imported and merged them into the product, and (re-)released.\n\n\n### Status Quo\n\nMost of today’s organizations are trying to switch the development process to a more agile approach.\nBy implementing more SaaS (Software as a Service) products today’s organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment).\nDevelopers focuses on instrumenting the code with the help of some i18n libraries like:\n\n[![http://i18next.com/](i18next.png)](http://i18next.com/)\n\n[![http://formatjs.io/](formatjs.png)](http://formatjs.io/)\n\n[http://airbnb.io/polyglot.js/](http://airbnb.io/polyglot.js/)\n\nand extract texts into resource files so someone can translate them later.\nNormally during a development iteration or sprint there is no time to translate the resources, and not just because most people have this sort of attitude:\n\n> << We are not interested in the translation process itself. >>\n\nThat’s why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted.\nThis **“freeze”** period gives technical writers and translators the necessary time to work on. The more text needs to be handled the longer is this period.\nThis process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment.\n\n\n### True Continuous Deployment with Continuous Localization\n\nBecause software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) — continuously.\nYour localization and translation process should follow the same pattern as your software development.\nYou should be able to deploy your translation files separated from your software so you can update and manage them independently. And if you do so, you have to make sure you can have more then one version of your translations; at least one for the current released version and one for the current development branch.\nThat way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease.\nBy doing this it is even possible to change or add translations without shipping a new release of your software!\n\n> Cool, but isn’t this a little over the top… an extra tooling and deployment — doesn’t all this just add more complexity and effort?\n\n#### You don’t have to build this yourself!!! — There is locize\n\n<div class=\"contact\" style=\"margin-top: 0px;\">\n<hr />\n<p class=\"callout extra-margin\">...give it a try: <strong><a href=\"https://www.locize.app/register\">Register!</a></strong></p>\n</div>\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"continuous development","slug":"continuous-development","permalink":"https://locize.com/blog/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"https://locize.com/blog/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"https://locize.com/blog/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"https://locize.com/blog/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"https://locize.com/blog/tags/continuous-translation/"},{"name":"polyglot","slug":"polyglot","permalink":"https://locize.com/blog/tags/polyglot/"},{"name":"formatjs","slug":"formatjs","permalink":"https://locize.com/blog/tags/formatjs/"}]},{"title":"The freedom of choice…i18next, polyglot or formatJS","slug":"the-freedom-of-choice","date":"un44fin44","updated":"un55fin55","comments":true,"path":"the-freedom-of-choice/","link":"","permalink":"https://locize.com/blog/the-freedom-of-choice/","excerpt":"","text":"When we started work on locize.com our localization as a service platform we basically had in mind to solve the translation process for developers using our i18n framework i18next.com. Translation Management Systems are a great help. But still there is a gap between development and translation process. Files need to be exported / imported / merged and all while new content get added to be translated. The chaos is inevitable. locize.com comes to the rescue. It’s like a translation service on steroid directly connected to your i18next instrumented webproject. (i18next) A few weeks after the successful beta launch and adding a lot of third party services to order translations directly out of your locize project, we started wondering if we could also bring the awesomeness to other frontend internationalization frameworks like airbnb’s polyglot or yahoo’s formatJS? polyglot + locize.comOur first look at polyglot revealed that the implementation is rather similar to the i18next json format only the plurals are stored in a single key and separated by ||||. We decided to do a short spike using a node.js express server loading the resources from locize.com using its API and return a demo page using polyglot to translate it. Using request to load the translations: 123456function load(lng, callback) &#123; var url = &#x27;https://api.locize.app/[YOUR_PROJECT_ID]/latest/&#123;&#123;lng&#125;&#125;/translation&#x27;.replace(&#x27;&#123;&#123;lng&#125;&#125;&#x27;, lng); request(url, function(err, res, body) &#123; callback(err, lng, body); &#125;);&#125; The JSON we load from the locize project looks like: https://api.locize.app/897381a6-125c-40b8-9b28-2f80ae9a3612/latest/en/translation 123456789&#123; &quot;interpolate&quot;: &quot;Hello, %&#123;name&#125;.&quot;, &quot;intro&quot;: &quot;The locize.com platform is fully compatible with airbnb’s polyglot i18n module.&quot;, &quot;plural&quot;: &quot;%&#123;smart_count&#125; car |||| %&#123;smart_count&#125; cars&quot;, &quot;something&quot;: &#123; &quot;nested&quot;: &quot;Nested value something.nested&quot; &#125;, &quot;title&quot;: &quot;Using polyglot with locize.com&quot;&#125; We return a html file injecting the loaded json when requesting the root: 1234567891011app.get(&#x27;/&#x27;, function(req, res) &#123; var lng = req.query.lng || &#x27;en&#x27;; fs.readFile(__dirname + &#x27;/index.html&#x27;, (err, data) =&gt; &#123; if (err) console.log(err); data = data.toString().replace(&#x27;###locals###&#x27;, JSON.stringify(locals[lng])).replace(&#x27;###lng###&#x27;, lng); res.set(&#x27;content-type&#x27;, &#x27;text/html&#x27;); res.send(data); &#125;);&#125;); In the html we basically use polyglot as described on it’s website: 1234567&lt;script&gt; // initialize polyglot by settings phrases on server var polyglot = new Polyglot(&#123; phrases: JSON.parse(&#x27;###locals###&#x27;), locale: &#x27;###lng###&#x27; &#125;); // translate document.getElementById(&#x27;headline&#x27;).innerHTML = polyglot.t(&#x27;title&#x27;); ...&lt;/script&gt; You can checkout this example on github: https://github.com/locize/locize-polyglot-example. While it is a very basic sample the main focus stays on proving just that you can profit from using locize.com using polyglot. Adapt the sample to your backend language or just use xhr directly to load the data inside your client. You directly benefit from the same benefits just i18next developers had until now using locize.com. formatJS + locize.comformatJS is well known for using the intl API to parse dates and numbers plus uses the ICU message format for translations. The format is rather different from what was used in i18next, but still it’s just keybased json. So we started from what we did with polyglot. For the backend there was no change needed, so just scroll up to the polyglot sample where we use request o load the translations. The JSON we load from the locize project looks like: https://api.locize.app/9ac4fb1f-be22-4028-bcbc-0da13010b35e/latest/en/translation 123456&#123; &quot;interpolate&quot;: &quot;Hello, &#123;name&#125;.&quot;, &quot;intro&quot;: &quot;The locize.com platform is fully compatible with yahoo&#x27;s format.js i18n module.&quot;, &quot;plural&quot;: &quot;You have &#123;numPhotos, plural, =0 &#123;no photos.&#125;=1 &#123;one photo.&#125;other &#123;# photos.&#125;&#125;&quot;, &quot;title&quot;: &quot;Using format.js with locize.com&quot;&#125; In the html we use the IntlMessageFormat module and created a little helper function 1234567891011121314&lt;script&gt; // initialize var resources = JSON.parse(&#x27;###locals###&#x27;); var lng = &#x27;###lng###&#x27;; // translation helper function t(key, opts) &#123; opts = opts || &#123;&#125;; var m = new IntlMessageFormat(resources[key], lng); return m.format(opts); &#125; // translate document.getElementById(&#x27;headline&#x27;).innerHTML = t(&#x27;title&#x27;); ...&lt;/script&gt; You can see the full example on github: https://github.com/locize/locize-formatjs-example. The sample can easily be adapted to react-intl, ember-intl, handlebars-intl, dust-intl or any other framework using icu messageformat like eg. https://github.com/messageformat/messageformat.js. ConclusionWhile initially focused on i18next json format when building locize.com we found out that you can profit from the locize.com service using polyglot or any libary using messageformat (formatJS and others) too. We love flexibility so we’re looking forward to our first customer creating a project using airbnb’s or yahoo’s i18n framework.","raw":"---\ntitle: The freedom of choice…i18next, polyglot or formatJS\ndate: 2016-08-18\ntags:\n  - locize\n  - locizify\n  - i18next\n  - polyglot\n  - formatjs\nthumbnail: the-freedom-of-choice/idea.jpg\nredirect_from:\n- /2016-08-18-the-freedom-of-choice\n---\n\n\n![](idea.jpg \"locize flexibility\")\n\nWhen we started work on locize.com our localization as a service platform we basically had in mind to solve the translation process for developers using our i18n framework [i18next.com](http://i18next.com).\n\n> Translation Management Systems are a great help. But still there is a gap between development and translation process. Files need to be exported / imported / merged and all while new content get added to be translated. The chaos is inevitable. locize.com comes to the rescue. It’s like a translation service on steroid directly connected to your i18next instrumented webproject. ([i18next](http://i18next.com/docs/process/))\n\nA few weeks after the successful beta launch and adding a lot of third party services to order translations directly out of your locize project, we started wondering if we could also bring the awesomeness to other frontend internationalization frameworks like airbnb’s [polyglot](http://airbnb.io/polyglot.js/) or yahoo’s [formatJS](http://formatjs.io/)?\n\n### polyglot + locize.com\n\nOur first look at polyglot revealed that the implementation is rather similar to the i18next json format only the plurals are stored in a single key and separated by `||||`.\n\nWe decided to do a short spike using a node.js express server loading the resources from locize.com using its API and return a demo page using polyglot to translate it.\n\n**Using request to load the translations:**\n\n```js\nfunction load(lng, callback) {\n  var url = 'https://api.locize.app/[YOUR_PROJECT_ID]/latest/{{lng}}/translation'.replace('{{lng}}', lng);\n  request(url, function(err, res, body) {\n    callback(err, lng, body);\n  });\n}\n```\n\n**The JSON we load from the locize project looks like:**\n\n[https://api.locize.app/897381a6-125c-40b8-9b28-2f80ae9a3612/latest/en/translation](https://api.locize.app/897381a6-125c-40b8-9b28-2f80ae9a3612/latest/en/translation)\n\n```json\n{\n  \"interpolate\": \"Hello, %{name}.\",\n  \"intro\": \"The locize.com platform is fully compatible with airbnb’s polyglot i18n module.\",\n  \"plural\": \"%{smart_count} car |||| %{smart_count} cars\",\n  \"something\": {\n    \"nested\": \"Nested value something.nested\"\n  },\n  \"title\": \"Using polyglot with locize.com\"\n}\n```\n\n**We return a html file injecting the loaded json when requesting the root:**\n\n```js\napp.get('/', function(req, res) {\n  var lng = req.query.lng || 'en';\n\n  fs.readFile(__dirname + '/index.html', (err, data) => {\n    if (err) console.log(err);\n    data = data.toString().replace('###locals###', JSON.stringify(locals[lng])).replace('###lng###', lng);\n\n    res.set('content-type', 'text/html');\n    res.send(data);\n  });\n});\n```\n\n**In the html we basically use polyglot as described on it’s website:**\n\n```html\n<script>\n  // initialize polyglot by settings phrases on server\n  var polyglot = new Polyglot({ phrases: JSON.parse('###locals###'), locale: '###lng###' });\n  // translate\n  document.getElementById('headline').innerHTML = polyglot.t('title');\n  ...\n</script>\n```\n\nYou can checkout this example on github: [https://github.com/locize/locize-polyglot-example](https://github.com/locize/locize-polyglot-example).\n\nWhile it is a very basic sample the main focus stays on proving just that you can profit from using locize.com using polyglot. Adapt the sample to your backend language or just use xhr directly to load the data inside your client. You directly benefit from the same benefits just i18next developers had until now using locize.com.\n\n### formatJS + locize.com\n\nformatJS is well known for using the intl API to parse dates and numbers plus uses the ICU message format for translations. The format is rather different from what was used in i18next, but still it’s just keybased json.\n\nSo we started from what we did with polyglot. For the backend there was no change needed, so just scroll up to the polyglot sample where we use request o load the translations.\n\n**The JSON we load from the locize project looks like:**\n\n[https://api.locize.app/9ac4fb1f-be22-4028-bcbc-0da13010b35e/latest/en/translation](https://api.locize.app/9ac4fb1f-be22-4028-bcbc-0da13010b35e/latest/en/translation)\n\n```json\n{\n  \"interpolate\": \"Hello, {name}.\",\n  \"intro\": \"The locize.com platform is fully compatible with yahoo's format.js i18n module.\",\n  \"plural\": \"You have {numPhotos, plural, =0 {no photos.}=1 {one photo.}other {# photos.}}\",\n  \"title\": \"Using format.js with locize.com\"\n}\n```\n\n**In the html we use the [IntlMessageFormat](https://github.com/yahoo/intl-messageformat) module and created a little helper function**\n\n```html\n<script>\n  // initialize\n  var resources = JSON.parse('###locals###');\n  var lng = '###lng###';\n  // translation helper\n  function t(key, opts) {\n    opts = opts || {};\n    var m = new IntlMessageFormat(resources[key], lng);\n    return m.format(opts);\n  }\n  // translate\n  document.getElementById('headline').innerHTML = t('title');\n  ...\n</script>\n```\n\nYou can see the full example on github: [https://github.com/locize/locize-formatjs-example](https://github.com/locize/locize-formatjs-example).\n\nThe sample can easily be adapted to react-intl, ember-intl, handlebars-intl, dust-intl or any other framework using icu messageformat like eg. [https://github.com/messageformat/messageformat.js](https://github.com/messageformat/messageformat.js).\n\n### Conclusion\n\nWhile initially focused on [i18next json format](http://i18next.com/docs/jsons/) when building locize.com we found out that you can profit from the locize.com service using [polyglot](http://airbnb.io/polyglot.js/) or any libary using messageformat ([formatJS](http://formatjs.io/) and others) too.\n\nWe love flexibility so we’re looking forward to our first customer creating a project using airbnb’s or yahoo’s i18n framework.\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"polyglot","slug":"polyglot","permalink":"https://locize.com/blog/tags/polyglot/"},{"name":"formatjs","slug":"formatjs","permalink":"https://locize.com/blog/tags/formatjs/"},{"name":"locizify","slug":"locizify","permalink":"https://locize.com/blog/tags/locizify/"}]},{"title":"how we eat our own dogfood","slug":"eat-our-own-dogfood","date":"un66fin66","updated":"un55fin55","comments":true,"path":"eat-our-own-dogfood/","link":"","permalink":"https://locize.com/blog/eat-our-own-dogfood/","excerpt":"","text":"After relaunching our website with new templates for our documentation, post pages and adding a new landing page, we decided to have at least the landing page translated. As we use hexo to generate our static content it was just a natural fit to use our locizify script so we don&#39;t have to instrument the page ourself. As we might add other areas later we decided to have a fixed namespace (filename) for the landing page. We used the advanced option to init locizify like described here. We ended with following snipplet: 123456789101112131415161718&lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt;&lt;script&gt; locizify.init(&#123; namespace: &#x27;landingpage&#x27;, saveMissing: true, fallbackLng: &#x27;en&#x27;, backend: &#123; projectId: &#x27;3d0aa5aa-4660-4154-b6d9-907dbef10bb2&#x27;, apiKey: &#x27;******** private ********&#x27;, referenceLng: &#x27;en&#x27;, version: &#x27;production&#x27; &#125;, // ignore some dynamic widgets ignoreIds: [&#x27;nudgespotInappContainer&#x27;, &#x27;nudgespotInappMessagesContainer&#x27;, &#x27;nudgespotInappConversationsContainer&#x27;, &#x27;__bs_notify__&#x27;], ignoreClasses: [&#x27;nudgespot-clean&#x27;] &#125;);&lt;/script&gt; After reloading the page we had the source content in english inside our project. We translated that to german and italian in no time using our editor. As the latest version gets auto published reloading the page with the additional querystring parameter ?lng=de (or switching browser language) was enough to test the translation. Next we created a production version (going to project settings -&gt; versions) so we can change or prepare new content during development without messing with the currently released page version. After that we wanted to avoid the flickering on initial load where the page first gets displayed in the source language until locizify loaded and initial translated the page. To optimize this we just needed to add display: none to body (more info): 1&lt;body style=&quot;display: none&quot;&gt; Finally we needed a solution to let the user change the language on our page. We started with a simple list of links: 12345&lt;ul&gt; &lt;a href=&quot;/?lng=en&quot;&gt;english&lt;/a&gt; &lt;a href=&quot;/?lng=de&quot;&gt;deutsch&lt;/a&gt; &lt;a href=&quot;/?lng=it&quot;&gt;italiano&lt;/a&gt;&lt;/ul&gt; But decided a select element would fit more to our current layout. We needed to add binding to i18next changeLanguage event to select current language and handle the select onChange event. Further we use locizify.getLanguages to get current available languages in our project, so we don&#39;t have to touch the code when we add new languages: the select element: 12&lt;select id=&quot;languageSelect&quot; onChange=&quot;handleSelectChange()&quot; translated&gt;&lt;/select&gt; the script: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// the select elementvar ele = document.getElementById(&#x27;languageSelect&#x27;);var availableLngs = [];// create select options based on project languageslocizify.getLanguages(function(err, lngs) &#123; availableLngs = Object.keys(lngs || &#123;&#125;); availableLngs.forEach(function(l) &#123; var lng = lngs[l]; // return if not at least 90% is translated if (lng.translated.production &lt; 0.9) return; // append ele var optEle = document.createElement(&quot;OPTION&quot;); optEle.setAttribute(&#x27;value&#x27;, l); optEle.innerHTML = lng.nativeName; ele.appendChild(optEle); &#125;); updateSelect();&#125;);// selects the value based on i18next lngsfunction updateSelect() &#123; var selected; locizify.i18next.languages.forEach(function(l) &#123; if (!selected &amp;&amp; availableLngs.indexOf(l) &gt; -1) selected = l; &#125;); ele.value = selected || &#x27;en&#x27;;&#125;// reload page on selectionfunction handleSelectChange() &#123; var value = ele.options[ele.selectedIndex].value; window.location = updateQueryStringParameter(window.location.href, &#x27;lng&#x27;, value);&#125;// bind i18next change language eventlocizify.i18next.on(&#x27;languageChanged&#x27;, function(lng) &#123; updateSelect();&#125;);// just a helper to update uri with new paramsfunction updateQueryStringParameter(uri, key, value) &#123; var re = new RegExp(&quot;([?&amp;])&quot; + key + &quot;=.*?(&amp;|$)&quot;, &quot;i&quot;); var separator = uri.indexOf(&#x27;?&#x27;) !== -1 ? &quot;&amp;&quot; : &quot;?&quot;; if (uri.match(re)) &#123; return uri.replace(re, &#x27;$1&#x27; + key + &quot;=&quot; + value + &#x27;$2&#x27;); &#125; else &#123; return uri + separator + key + &quot;=&quot; + value; &#125;&#125; That&#39;s all. Our project was translated in no time including a custom language selector: We are very pleased with the outcome of eating our own dogfood. Next step will be to order professional translations for the languages we can&#39;t translate ourself...","raw":"---\ntitle: how we eat our own dogfood\n\ndate: 2016-06-11\ntags:\n  - locize\n  - locizify\n\nthumbnail: eat-our-own-dogfood/result.png\nredirect_from:\n- /2016-06-11-eat-our-own-dogfood\n---\n\nAfter relaunching our website with new templates for our documentation, post pages and adding a new landing page, we decided to have at least the landing page translated.\n\nAs we use [hexo](https://hexo.io/) to generate our static content it was just a natural fit to use our [locizify script](http://locize.com/integration.html) so we don't have to instrument the page ourself.\n\nAs we might add other areas later we decided to have a fixed namespace (filename) for the landing page. We used the advanced option to init locizify like described [here](https://github.com/locize/locizify#via-init-function).\n\nWe ended with following snipplet:\n\n```js\n<script src=\"https://unpkg.com/locizify@^2.0.0\"></script>\n<script>\n  locizify.init({\n    namespace: 'landingpage',\n    saveMissing: true,\n    fallbackLng: 'en',\n    backend: {\n      projectId: '3d0aa5aa-4660-4154-b6d9-907dbef10bb2',\n      apiKey: '******** private ********',\n      referenceLng: 'en',\n      version: 'production'\n    },\n\n    // ignore some dynamic widgets\n    ignoreIds: ['nudgespotInappContainer', 'nudgespotInappMessagesContainer', 'nudgespotInappConversationsContainer', '__bs_notify__'],\n    ignoreClasses: ['nudgespot-clean']\n  });\n</script>\n```\n\nAfter reloading the page we had the source content in english inside our project. We translated that to german and italian in no time using our editor.\n\n![](translate.png \"translate to german\")\n\nAs the latest version gets auto published reloading the page with the additional querystring parameter `?lng=de` (or switching browser language) was enough to test the translation.\n\nNext we created a production version (going to project settings -> versions) so we can change or prepare new content during development without messing with the currently released page version.\n\n\n![](version.png \"translate to german\")\n\nAfter that we wanted to avoid the flickering on initial load where the page first gets displayed in the source language until locizify loaded and initial translated the page.\n\nTo optimize this we just needed to add `display: none` to body [(more info)](https://github.com/locize/locizify#avoid-flickering-on-initial-load):\n\n```html\n<body style=\"display: none\">\n```\n\nFinally we needed a solution to let the user change the language on our page. We started with a simple list of links:\n\n```html\n<ul>\n  <a href=\"/?lng=en\">english</a>\n  <a href=\"/?lng=de\">deutsch</a>\n  <a href=\"/?lng=it\">italiano</a>\n</ul>\n```\n\nBut decided a select element would fit more to our current layout. We needed to add binding to i18next [changeLanguage event](http://i18next.com/docs/api/#on-language-changed) to select current language and handle the select `onChange` event.\n\nFurther we use `locizify.getLanguages` to get current available languages in our project, so we don't have to touch the code when we add new languages:\n\n**the select element:**\n\n```html\n<select id=\"languageSelect\" onChange=\"handleSelectChange()\" translated>\n</select>\n```\n\n**the script:**\n\n```js\n// the select element\nvar ele = document.getElementById('languageSelect');\nvar availableLngs = [];\n\n// create select options based on project languages\nlocizify.getLanguages(function(err, lngs) {\n  availableLngs = Object.keys(lngs || {});\n  availableLngs.forEach(function(l) {\n    var lng = lngs[l];\n\n    // return if not at least 90% is translated\n    if (lng.translated.production < 0.9) return;\n\n    // append ele\n    var optEle = document.createElement(\"OPTION\");\n    optEle.setAttribute('value', l);\n    optEle.innerHTML = lng.nativeName;\n    ele.appendChild(optEle);\n  });\n\n  updateSelect();\n});\n\n// selects the value based on i18next lngs\nfunction updateSelect() {\n  var selected;\n  locizify.i18next.languages.forEach(function(l) {\n    if (!selected && availableLngs.indexOf(l) > -1) selected = l;\n  });\n\n  ele.value = selected || 'en';\n}\n\n// reload page on selection\nfunction handleSelectChange() {\n  var value = ele.options[ele.selectedIndex].value;\n  window.location = updateQueryStringParameter(window.location.href, 'lng', value);\n}\n\n// bind i18next change language event\nlocizify.i18next.on('languageChanged', function(lng) {\n  updateSelect();\n});\n\n// just a helper to update uri with new params\nfunction updateQueryStringParameter(uri, key, value) {\n  var re = new RegExp(\"([?&])\" + key + \"=.*?(&|$)\", \"i\");\n  var separator = uri.indexOf('?') !== -1 ? \"&\" : \"?\";\n  if (uri.match(re)) {\n    return uri.replace(re, '$1' + key + \"=\" + value + '$2');\n  }\n  else {\n    return uri + separator + key + \"=\" + value;\n  }\n}\n```\n\nThat's all. Our project was translated in no time including a custom language selector:\n\n![](result.png \"translated to german\")\n\nWe are very pleased with the outcome of eating our own dogfood. Next step will be to order professional translations for the languages we can't translate ourself...\n","categories":[],"tags":[{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"locizify","slug":"locizify","permalink":"https://locize.com/blog/tags/locizify/"}]},{"title":"technology stack - locize is serverless","slug":"technology-stack","date":"un44fin44","updated":"un55fin55","comments":true,"path":"technology-stack/","link":"","permalink":"https://locize.com/blog/technology-stack/","excerpt":"","text":"No Servers?We believe that the best DevOps is NoOps. Nothing against DevOps or DevOps people. On the contrary, but we think we could do differently! Instead of spending time on setting up virtual machines and maintaining them, we setup our stack directly on different services – leaving ourselves more time to work on great features. locize gave us a chance to have a look around at new paths for building long lasting components. We used a set of AWS solutions: AWS DynamoDB AWS CloudFront CDN AWS Simple Storage Service S3 but specifically: AWS API Gateway AWS Lambda Amazon LambdaAWS Lambda is a compute service where you can upload your code to AWS Lambda and the service can run the code on your behalf using AWS infrastructure. All this without the hassle of own virtual machines, containers or any infrastructure for that matter. It integrates very well with S3 (where we serve the localized files) and with DynamoDB (our main work storage). We don’t have to worry about scaling, multi-server communication and other problems related to distributed systems. We use the node.js runtime for all our lambda functions. Amazon API GatewayAWS API Gateway lets you create a RESTful API to expose selected back-end features. The back end can be another AWS service, such as AWS Lambda or AWS DynamoDB, or it can be an existing web application. Below you can see how locize uses this services What about the client side?In an other blog post ;-)","raw":"---\ntitle: technology stack - locize is serverless\ndate: 2016-04-07\ntags:\n  - technology\n  - backend\n  - aws\n  - service\nthumbnail: technology-stack/nodejs-new-pantone-black.png\nredirect_from:\n- /2016-04-07-technology-stack\n---\n\n### No Servers?\n\nWe believe that the best DevOps is **NoOps**.\nNothing against DevOps or DevOps people. On the contrary, but we think we could do differently!\n\nInstead of spending time on setting up virtual machines and maintaining them, we setup our stack directly on different services – leaving ourselves more time to work on great features.\n\n**locize** gave us a chance to have a look around at new paths for building long lasting components.\n\nWe used a set of AWS solutions:\n- [AWS DynamoDB](https://aws.amazon.com/dynamodb)\n- [AWS CloudFront CDN](https://aws.amazon.com/de/cloudfront)\n- [AWS Simple Storage Service S3](https://aws.amazon.com/s3)\n\nbut specifically:\n- [AWS API Gateway](https://aws.amazon.com/api-gateway)\n- [AWS Lambda](https://aws.amazon.com/lambda)\n\n### Amazon Lambda\n[AWS Lambda](https://aws.amazon.com/lambda) is a compute service where you can upload your code to AWS Lambda and the service can run the code on your behalf using AWS infrastructure.\nAll this without the hassle of own virtual machines, containers or any infrastructure for that matter.\nIt integrates very well with [S3](https://aws.amazon.com/s3) _(where we serve the localized files)_ and with [DynamoDB](https://aws.amazon.com/dynamodb) _(our main work storage)_.\nWe don’t have to worry about scaling, multi-server communication and other problems related to distributed systems.\nWe use the [node.js](https://nodejs.org) runtime for all our lambda functions.\n![](nodejs-new-pantone-black.png \"node.js\")\n\n### Amazon API Gateway\n[AWS API Gateway](https://aws.amazon.com/api-gateway) lets you create a RESTful API to expose selected back-end features. The back end can be another AWS service, such as [AWS Lambda](https://aws.amazon.com/lambda) or [AWS DynamoDB](https://aws.amazon.com/dynamodb), or it can be an existing web application.\n\n### Below you can see how **locize** uses this services\n![](aws.png \"locize © inweso GmbH\")\n\n\n### What about the client side?\nIn an other blog post ;-)\n","categories":[],"tags":[{"name":"backend","slug":"backend","permalink":"https://locize.com/blog/tags/backend/"},{"name":"aws","slug":"aws","permalink":"https://locize.com/blog/tags/aws/"},{"name":"service","slug":"service","permalink":"https://locize.com/blog/tags/service/"},{"name":"technology","slug":"technology","permalink":"https://locize.com/blog/tags/technology/"}]},{"title":"day zero - how all began","slug":"day-zero","date":"un66fin66","updated":"un55fin55","comments":true,"path":"day-zero/","link":"","permalink":"https://locize.com/blog/day-zero/","excerpt":"","text":"Back in 2011All started back in 2011 when we were in search for a internationalization library that meets our demand - allowing to run both on serverside node.js and on our clientside singlepage applications. I18next was born and fastly grown to one of the most used frameworks for translating webapplications and in node.js. The response of the community was amazing and a fast growing ecosystem established itself around i18next. internationalization is not enoughOur community provided us with great feedback. Out of that response and our own experiences we learnt providing instrumentation for doing proper internationalization just is not enough. Helping developers to get their applications translated is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How do you handle proper versioning? How do you deploy translation changes without deploying your complete application? locize to the rescueHaving created the foundation with i18next it was a long journey to localization as a service. But the journey ends this year with locize. Easy to integrate Order professional translations Analytics &amp; Statistics Profit from our content delivery network Versioning of your translations Riskfree: Take your data with you Transparent and fair pricing","raw":"---\ntitle: day zero - how all began\n\ndate: 2016-02-27\ntags:\n  - beginning\n  - i18next\n\nthumbnail: images/locize_color.svg\nredirect_from:\n- /2016-02-27-day-zero\n---\n\n### Back in 2011\n\nAll started back in 2011 when we were in search for a internationalization library that meets our demand - allowing to run both on serverside node.js and on our clientside singlepage applications. [I18next](http://www.i18next.com) was born and fastly grown to one of the most used frameworks for translating webapplications and in node.js. The response of the community was amazing and a fast growing ecosystem established itself around i18next.\n\n\n### internationalization is not enough\n\nOur community provided us with great feedback. Out of that response and our own experiences we learnt providing instrumentation for doing proper internationalization just is not enough.\n\nHelping developers to get their applications translated is great - but there is more to it.\n\n- How do you integrate any translation services / agency?\n- How do you keep track of new or removed content?\n- How do you handle proper versioning?\n- How do you deploy translation changes without deploying your complete application?\n\n\n### locize to the rescue\n\nHaving created the foundation with **i18next** it was a long journey to **localization as a service**.\n\nBut the journey ends this year with **locize**.\n\n- Easy to integrate\n- Order professional translations\n- Analytics & Statistics\n- Profit from our content delivery network\n- Versioning of your translations\n- Riskfree: Take your data with you\n- Transparent and fair pricing\n","categories":[],"tags":[{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"beginning","slug":"beginning","permalink":"https://locize.com/blog/tags/beginning/"}]}],"categories":[],"tags":[{"name":"localization","slug":"localization","permalink":"https://locize.com/blog/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"https://locize.com/blog/tags/internationalization/"},{"name":"guest post","slug":"guest-post","permalink":"https://locize.com/blog/tags/guest-post/"},{"name":"l10n","slug":"l10n","permalink":"https://locize.com/blog/tags/l10n/"},{"name":"i18n","slug":"i18n","permalink":"https://locize.com/blog/tags/i18n/"},{"name":"translation","slug":"translation","permalink":"https://locize.com/blog/tags/translation/"},{"name":"machine translation","slug":"machine-translation","permalink":"https://locize.com/blog/tags/machine-translation/"},{"name":"website internationalization","slug":"website-internationalization","permalink":"https://locize.com/blog/tags/website-internationalization/"},{"name":"best practices","slug":"best-practices","permalink":"https://locize.com/blog/tags/best-practices/"},{"name":"web app translation","slug":"web-app-translation","permalink":"https://locize.com/blog/tags/web-app-translation/"},{"name":"process","slug":"process","permalink":"https://locize.com/blog/tags/process/"},{"name":"workflow","slug":"workflow","permalink":"https://locize.com/blog/tags/workflow/"},{"name":"testing","slug":"testing","permalink":"https://locize.com/blog/tags/testing/"},{"name":"software development","slug":"software-development","permalink":"https://locize.com/blog/tags/software-development/"},{"name":"international strategy","slug":"international-strategy","permalink":"https://locize.com/blog/tags/international-strategy/"},{"name":"globalization","slug":"globalization","permalink":"https://locize.com/blog/tags/globalization/"},{"name":"g11n","slug":"g11n","permalink":"https://locize.com/blog/tags/g11n/"},{"name":"global localization","slug":"global-localization","permalink":"https://locize.com/blog/tags/global-localization/"},{"name":"locize","slug":"locize","permalink":"https://locize.com/blog/tags/locize/"},{"name":"service","slug":"service","permalink":"https://locize.com/blog/tags/service/"},{"name":"translation management","slug":"translation-management","permalink":"https://locize.com/blog/tags/translation-management/"},{"name":"tms","slug":"tms","permalink":"https://locize.com/blog/tags/tms/"},{"name":"order","slug":"order","permalink":"https://locize.com/blog/tags/order/"},{"name":"tech lead","slug":"tech-lead","permalink":"https://locize.com/blog/tags/tech-lead/"},{"name":"engineering manager","slug":"engineering-manager","permalink":"https://locize.com/blog/tags/engineering-manager/"},{"name":"how to choose","slug":"how-to-choose","permalink":"https://locize.com/blog/tags/how-to-choose/"},{"name":"i18next","slug":"i18next","permalink":"https://locize.com/blog/tags/i18next/"},{"name":"react","slug":"react","permalink":"https://locize.com/blog/tags/react/"},{"name":"react-i18next","slug":"react-i18next","permalink":"https://locize.com/blog/tags/react-i18next/"},{"name":"typescript","slug":"typescript","permalink":"https://locize.com/blog/tags/typescript/"},{"name":"types","slug":"types","permalink":"https://locize.com/blog/tags/types/"},{"name":"marketing campaigns","slug":"marketing-campaigns","permalink":"https://locize.com/blog/tags/marketing-campaigns/"},{"name":"products","slug":"products","permalink":"https://locize.com/blog/tags/products/"},{"name":"brand","slug":"brand","permalink":"https://locize.com/blog/tags/brand/"},{"name":"competitors","slug":"competitors","permalink":"https://locize.com/blog/tags/competitors/"},{"name":"cultures","slug":"cultures","permalink":"https://locize.com/blog/tags/cultures/"},{"name":"markets","slug":"markets","permalink":"https://locize.com/blog/tags/markets/"},{"name":"serverless","slug":"serverless","permalink":"https://locize.com/blog/tags/serverless/"},{"name":"aws","slug":"aws","permalink":"https://locize.com/blog/tags/aws/"},{"name":"mobile app","slug":"mobile-app","permalink":"https://locize.com/blog/tags/mobile-app/"},{"name":"android","slug":"android","permalink":"https://locize.com/blog/tags/android/"},{"name":"app store","slug":"app-store","permalink":"https://locize.com/blog/tags/app-store/"},{"name":"localization tools","slug":"localization-tools","permalink":"https://locize.com/blog/tags/localization-tools/"},{"name":"software","slug":"software","permalink":"https://locize.com/blog/tags/software/"},{"name":"language","slug":"language","permalink":"https://locize.com/blog/tags/language/"},{"name":"open-source","slug":"open-source","permalink":"https://locize.com/blog/tags/open-source/"},{"name":"github","slug":"github","permalink":"https://locize.com/blog/tags/github/"},{"name":"guide","slug":"guide","permalink":"https://locize.com/blog/tags/guide/"},{"name":"localization techniques","slug":"localization-techniques","permalink":"https://locize.com/blog/tags/localization-techniques/"},{"name":"refining website content","slug":"refining-website-content","permalink":"https://locize.com/blog/tags/refining-website-content/"},{"name":"native language","slug":"native-language","permalink":"https://locize.com/blog/tags/native-language/"},{"name":"localization project","slug":"localization-project","permalink":"https://locize.com/blog/tags/localization-project/"},{"name":"language translation","slug":"language-translation","permalink":"https://locize.com/blog/tags/language-translation/"},{"name":"project management","slug":"project-management","permalink":"https://locize.com/blog/tags/project-management/"},{"name":"translation tools","slug":"translation-tools","permalink":"https://locize.com/blog/tags/translation-tools/"},{"name":"next","slug":"next","permalink":"https://locize.com/blog/tags/next/"},{"name":"next-i18next","slug":"next-i18next","permalink":"https://locize.com/blog/tags/next-i18next/"},{"name":"marketing","slug":"marketing","permalink":"https://locize.com/blog/tags/marketing/"},{"name":"transnational strategy","slug":"transnational-strategy","permalink":"https://locize.com/blog/tags/transnational-strategy/"},{"name":"successful global localization","slug":"successful-global-localization","permalink":"https://locize.com/blog/tags/successful-global-localization/"},{"name":"software architecture","slug":"software-architecture","permalink":"https://locize.com/blog/tags/software-architecture/"},{"name":"cloud","slug":"cloud","permalink":"https://locize.com/blog/tags/cloud/"},{"name":"multi-tenancy","slug":"multi-tenancy","permalink":"https://locize.com/blog/tags/multi-tenancy/"},{"name":"customers","slug":"customers","permalink":"https://locize.com/blog/tags/customers/"},{"name":"data","slug":"data","permalink":"https://locize.com/blog/tags/data/"},{"name":"translation project management","slug":"translation-project-management","permalink":"https://locize.com/blog/tags/translation-project-management/"},{"name":"language localization","slug":"language-localization","permalink":"https://locize.com/blog/tags/language-localization/"},{"name":"examples","slug":"examples","permalink":"https://locize.com/blog/tags/examples/"},{"name":"globalisation","slug":"globalisation","permalink":"https://locize.com/blog/tags/globalisation/"},{"name":"gatsby","slug":"gatsby","permalink":"https://locize.com/blog/tags/gatsby/"},{"name":"gatsby-plugin-react-i18next","slug":"gatsby-plugin-react-i18next","permalink":"https://locize.com/blog/tags/gatsby-plugin-react-i18next/"},{"name":"vue","slug":"vue","permalink":"https://locize.com/blog/tags/vue/"},{"name":"i18next-vue","slug":"i18next-vue","permalink":"https://locize.com/blog/tags/i18next-vue/"},{"name":"svelte","slug":"svelte","permalink":"https://locize.com/blog/tags/svelte/"},{"name":"svelte-i18n","slug":"svelte-i18n","permalink":"https://locize.com/blog/tags/svelte-i18n/"},{"name":"remix-i18next","slug":"remix-i18next","permalink":"https://locize.com/blog/tags/remix-i18next/"},{"name":"remix","slug":"remix","permalink":"https://locize.com/blog/tags/remix/"},{"name":"continuous development","slug":"continuous-development","permalink":"https://locize.com/blog/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"https://locize.com/blog/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"https://locize.com/blog/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"https://locize.com/blog/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"https://locize.com/blog/tags/continuous-translation/"},{"name":"jquery","slug":"jquery","permalink":"https://locize.com/blog/tags/jquery/"},{"name":"jquery-i18next","slug":"jquery-i18next","permalink":"https://locize.com/blog/tags/jquery-i18next/"},{"name":"backend","slug":"backend","permalink":"https://locize.com/blog/tags/backend/"},{"name":"server","slug":"server","permalink":"https://locize.com/blog/tags/server/"},{"name":"serverside","slug":"serverside","permalink":"https://locize.com/blog/tags/serverside/"},{"name":"cli","slug":"cli","permalink":"https://locize.com/blog/tags/cli/"},{"name":"deno","slug":"deno","permalink":"https://locize.com/blog/tags/deno/"},{"name":"abc","slug":"abc","permalink":"https://locize.com/blog/tags/abc/"},{"name":"ejs","slug":"ejs","permalink":"https://locize.com/blog/tags/ejs/"},{"name":"dejs","slug":"dejs","permalink":"https://locize.com/blog/tags/dejs/"},{"name":"video game","slug":"video-game","permalink":"https://locize.com/blog/tags/video-game/"},{"name":"example","slug":"example","permalink":"https://locize.com/blog/tags/example/"},{"name":"problems","slug":"problems","permalink":"https://locize.com/blog/tags/problems/"},{"name":"mail","slug":"mail","permalink":"https://locize.com/blog/tags/mail/"},{"name":"angular","slug":"angular","permalink":"https://locize.com/blog/tags/angular/"},{"name":"vue-i18n","slug":"vue-i18n","permalink":"https://locize.com/blog/tags/vue-i18n/"},{"name":"web","slug":"web","permalink":"https://locize.com/blog/tags/web/"},{"name":"formatjs","slug":"formatjs","permalink":"https://locize.com/blog/tags/formatjs/"},{"name":"react-intl","slug":"react-intl","permalink":"https://locize.com/blog/tags/react-intl/"},{"name":"vue-i18next","slug":"vue-i18next","permalink":"https://locize.com/blog/tags/vue-i18next/"},{"name":"award","slug":"award","permalink":"https://locize.com/blog/tags/award/"},{"name":"locizify","slug":"locizify","permalink":"https://locize.com/blog/tags/locizify/"},{"name":"polyglot","slug":"polyglot","permalink":"https://locize.com/blog/tags/polyglot/"},{"name":"technology","slug":"technology","permalink":"https://locize.com/blog/tags/technology/"},{"name":"beginning","slug":"beginning","permalink":"https://locize.com/blog/tags/beginning/"}]}